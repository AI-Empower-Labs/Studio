/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package org.openapitools.client.apis

import java.io.IOException
import okhttp3.Call
import okhttp3.HttpUrl

import org.openapitools.client.models.ApiExtractThematicSimilarityClusterPostRequest
import org.openapitools.client.models.EmbeddingRequest
import org.openapitools.client.models.EmbeddingResponse
import org.openapitools.client.models.HttpValidationProblemDetails
import org.openapitools.client.models.KMeansCluster
import org.openapitools.client.models.KeywordExtractionRequestBody
import org.openapitools.client.models.KeywordExtractionResponse
import org.openapitools.client.models.NamedEntityRecognitionRequest
import org.openapitools.client.models.NamedEntityRecognitionResponse
import org.openapitools.client.models.ProblemDetails
import org.openapitools.client.models.SemanticSimilarityRequest
import org.openapitools.client.models.SemanticSimilarityResponse
import org.openapitools.client.models.TokenCountRequest
import org.openapitools.client.models.TokenCountResponse
import org.openapitools.client.models.TokenizerRequest
import org.openapitools.client.models.TokenizerResponse
import org.openapitools.client.models.TranscriptionResponse

import com.squareup.moshi.Json

import org.openapitools.client.infrastructure.ApiClient
import org.openapitools.client.infrastructure.ApiResponse
import org.openapitools.client.infrastructure.ClientException
import org.openapitools.client.infrastructure.ClientError
import org.openapitools.client.infrastructure.ServerException
import org.openapitools.client.infrastructure.ServerError
import org.openapitools.client.infrastructure.MultiValueMap
import org.openapitools.client.infrastructure.PartConfig
import org.openapitools.client.infrastructure.RequestConfig
import org.openapitools.client.infrastructure.RequestMethod
import org.openapitools.client.infrastructure.ResponseType
import org.openapitools.client.infrastructure.Success
import org.openapitools.client.infrastructure.toMultiValue

class DataExtractionApi(basePath: kotlin.String = defaultBasePath, client: Call.Factory = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://studio.aiempowerlabs.com")
        }
    }

    /**
     * Generate thematic similarity clusters using the K-Means algorithm
     * 
     * @param apiExtractThematicSimilarityClusterPostRequest 
     * @return KMeansCluster
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiExtractThematicSimilarityClusterPost(apiExtractThematicSimilarityClusterPostRequest: ApiExtractThematicSimilarityClusterPostRequest) : KMeansCluster {
        val localVarResponse = apiExtractThematicSimilarityClusterPostWithHttpInfo(apiExtractThematicSimilarityClusterPostRequest = apiExtractThematicSimilarityClusterPostRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as KMeansCluster
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Generate thematic similarity clusters using the K-Means algorithm
     * 
     * @param apiExtractThematicSimilarityClusterPostRequest 
     * @return ApiResponse<KMeansCluster?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun apiExtractThematicSimilarityClusterPostWithHttpInfo(apiExtractThematicSimilarityClusterPostRequest: ApiExtractThematicSimilarityClusterPostRequest) : ApiResponse<KMeansCluster?> {
        val localVariableConfig = apiExtractThematicSimilarityClusterPostRequestConfig(apiExtractThematicSimilarityClusterPostRequest = apiExtractThematicSimilarityClusterPostRequest)

        return request<ApiExtractThematicSimilarityClusterPostRequest, KMeansCluster>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation apiExtractThematicSimilarityClusterPost
     *
     * @param apiExtractThematicSimilarityClusterPostRequest 
     * @return RequestConfig
     */
    fun apiExtractThematicSimilarityClusterPostRequestConfig(apiExtractThematicSimilarityClusterPostRequest: ApiExtractThematicSimilarityClusterPostRequest) : RequestConfig<ApiExtractThematicSimilarityClusterPostRequest> {
        val localVariableBody = apiExtractThematicSimilarityClusterPostRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json, application/problem+json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/extract/thematic-similarity-cluster",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * Converts data to a numerical vector array
     * The embedding endpoint is a sophisticated API designed for transforming textual data into high-dimensional vectors, facilitating a wide array of natural language processing (NLP) tasks. This transformation process encodes the semantic properties and contextual meanings of the input text into a vector space, enabling machines to understand and process language in a manner analogous to human comprehension.  ## Core Features:  * Semantic Encoding: Leverages advanced machine learning models, particularly those based on transformer architectures, to capture the deep semantic and syntactic nuances of the input text. This ensures that similar words and phrases are positioned closely in the vector space, reflecting their semantic proximity. * High-Dimensional Representation: Transforms texts into vectors in a high-dimensional space, typically ranging from hundreds to thousands of dimensions. This rich representation captures a comprehensive spectrum of linguistic features and relationships. * Scalability: Engineered to handle a wide range of text sizes, from short tweets to extensive documents, without compromising on the accuracy of the vector representations.
     * @param embeddingRequest 
     * @return EmbeddingResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun embedding(embeddingRequest: EmbeddingRequest) : EmbeddingResponse {
        val localVarResponse = embeddingWithHttpInfo(embeddingRequest = embeddingRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EmbeddingResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Converts data to a numerical vector array
     * The embedding endpoint is a sophisticated API designed for transforming textual data into high-dimensional vectors, facilitating a wide array of natural language processing (NLP) tasks. This transformation process encodes the semantic properties and contextual meanings of the input text into a vector space, enabling machines to understand and process language in a manner analogous to human comprehension.  ## Core Features:  * Semantic Encoding: Leverages advanced machine learning models, particularly those based on transformer architectures, to capture the deep semantic and syntactic nuances of the input text. This ensures that similar words and phrases are positioned closely in the vector space, reflecting their semantic proximity. * High-Dimensional Representation: Transforms texts into vectors in a high-dimensional space, typically ranging from hundreds to thousands of dimensions. This rich representation captures a comprehensive spectrum of linguistic features and relationships. * Scalability: Engineered to handle a wide range of text sizes, from short tweets to extensive documents, without compromising on the accuracy of the vector representations.
     * @param embeddingRequest 
     * @return ApiResponse<EmbeddingResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun embeddingWithHttpInfo(embeddingRequest: EmbeddingRequest) : ApiResponse<EmbeddingResponse?> {
        val localVariableConfig = embeddingRequestConfig(embeddingRequest = embeddingRequest)

        return request<EmbeddingRequest, EmbeddingResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation embedding
     *
     * @param embeddingRequest 
     * @return RequestConfig
     */
    fun embeddingRequestConfig(embeddingRequest: EmbeddingRequest) : RequestConfig<EmbeddingRequest> {
        val localVariableBody = embeddingRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json, application/problem+json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/extract/embed",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * Performs keyword extraction on source text
     * This endpoint accepts a string of text and returns a list of key words or phrases that best describe the content of the text. This can be used for tagging, summarizing, indexing, or categorizing content.
     * @param keywordExtractionRequestBody 
     * @return KeywordExtractionResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun keywordExtraction(keywordExtractionRequestBody: KeywordExtractionRequestBody) : KeywordExtractionResponse {
        val localVarResponse = keywordExtractionWithHttpInfo(keywordExtractionRequestBody = keywordExtractionRequestBody)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as KeywordExtractionResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Performs keyword extraction on source text
     * This endpoint accepts a string of text and returns a list of key words or phrases that best describe the content of the text. This can be used for tagging, summarizing, indexing, or categorizing content.
     * @param keywordExtractionRequestBody 
     * @return ApiResponse<KeywordExtractionResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun keywordExtractionWithHttpInfo(keywordExtractionRequestBody: KeywordExtractionRequestBody) : ApiResponse<KeywordExtractionResponse?> {
        val localVariableConfig = keywordExtractionRequestConfig(keywordExtractionRequestBody = keywordExtractionRequestBody)

        return request<KeywordExtractionRequestBody, KeywordExtractionResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation keywordExtraction
     *
     * @param keywordExtractionRequestBody 
     * @return RequestConfig
     */
    fun keywordExtractionRequestConfig(keywordExtractionRequestBody: KeywordExtractionRequestBody) : RequestConfig<KeywordExtractionRequestBody> {
        val localVariableBody = keywordExtractionRequestBody
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json, application/problem+json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/extract/keywords",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * Extracts named entities from provided text
     * This endpoint accepts a string of text and returns a list of identified entities classified into categories such as email, location, organisation, etc.
     * @param namedEntityRecognitionRequest 
     * @return NamedEntityRecognitionResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun namedEntityRecognition(namedEntityRecognitionRequest: NamedEntityRecognitionRequest) : NamedEntityRecognitionResponse {
        val localVarResponse = namedEntityRecognitionWithHttpInfo(namedEntityRecognitionRequest = namedEntityRecognitionRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as NamedEntityRecognitionResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Extracts named entities from provided text
     * This endpoint accepts a string of text and returns a list of identified entities classified into categories such as email, location, organisation, etc.
     * @param namedEntityRecognitionRequest 
     * @return ApiResponse<NamedEntityRecognitionResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun namedEntityRecognitionWithHttpInfo(namedEntityRecognitionRequest: NamedEntityRecognitionRequest) : ApiResponse<NamedEntityRecognitionResponse?> {
        val localVariableConfig = namedEntityRecognitionRequestConfig(namedEntityRecognitionRequest = namedEntityRecognitionRequest)

        return request<NamedEntityRecognitionRequest, NamedEntityRecognitionResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation namedEntityRecognition
     *
     * @param namedEntityRecognitionRequest 
     * @return RequestConfig
     */
    fun namedEntityRecognitionRequestConfig(namedEntityRecognitionRequest: NamedEntityRecognitionRequest) : RequestConfig<NamedEntityRecognitionRequest> {
        val localVariableBody = namedEntityRecognitionRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json, application/problem+json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/extract/entities",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * Generate semantic similarity queries from text
     * Upon receiving a user-defined query and a set of texts, the endpoint processes this information through its semantic analysis engine. This engine leverages state-of-the-art machine learning models, such as transformer-based architectures, to encode the texts and the query into high-dimensional vectors. By operating in this semantic space, it can accurately measure the distances between the query vector and each of the text vectors, reflecting how closely the meanings align.  Use Cases:  * Content Discovery: Helps users find articles, posts, or documents that are most relevant to their query.  * Customer Support: Automatically matches customer queries to the most relevant FAQs or support documents.  * Research and Study: Assists researchers in quickly finding academic papers or resources that are closely related to their field of inquiry.  By utilizing the semantic similarity endpoint, organizations and individuals can greatly enhance the efficiency and effectiveness of their information retrieval processes, ensuring that users are connected with the content most pertinent to their needs.
     * @param semanticSimilarityRequest 
     * @return SemanticSimilarityResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun semanticSimilarity(semanticSimilarityRequest: SemanticSimilarityRequest) : SemanticSimilarityResponse {
        val localVarResponse = semanticSimilarityWithHttpInfo(semanticSimilarityRequest = semanticSimilarityRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SemanticSimilarityResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Generate semantic similarity queries from text
     * Upon receiving a user-defined query and a set of texts, the endpoint processes this information through its semantic analysis engine. This engine leverages state-of-the-art machine learning models, such as transformer-based architectures, to encode the texts and the query into high-dimensional vectors. By operating in this semantic space, it can accurately measure the distances between the query vector and each of the text vectors, reflecting how closely the meanings align.  Use Cases:  * Content Discovery: Helps users find articles, posts, or documents that are most relevant to their query.  * Customer Support: Automatically matches customer queries to the most relevant FAQs or support documents.  * Research and Study: Assists researchers in quickly finding academic papers or resources that are closely related to their field of inquiry.  By utilizing the semantic similarity endpoint, organizations and individuals can greatly enhance the efficiency and effectiveness of their information retrieval processes, ensuring that users are connected with the content most pertinent to their needs.
     * @param semanticSimilarityRequest 
     * @return ApiResponse<SemanticSimilarityResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun semanticSimilarityWithHttpInfo(semanticSimilarityRequest: SemanticSimilarityRequest) : ApiResponse<SemanticSimilarityResponse?> {
        val localVariableConfig = semanticSimilarityRequestConfig(semanticSimilarityRequest = semanticSimilarityRequest)

        return request<SemanticSimilarityRequest, SemanticSimilarityResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation semanticSimilarity
     *
     * @param semanticSimilarityRequest 
     * @return RequestConfig
     */
    fun semanticSimilarityRequestConfig(semanticSimilarityRequest: SemanticSimilarityRequest) : RequestConfig<SemanticSimilarityRequest> {
        val localVariableBody = semanticSimilarityRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json, application/problem+json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/extract/similarity",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * Count tokens in a text
     * The tokenCount endpoint designed for counting tokens in text data.
     * @param tokenCountRequest 
     * @return TokenCountResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun tokenCount(tokenCountRequest: TokenCountRequest) : TokenCountResponse {
        val localVarResponse = tokenCountWithHttpInfo(tokenCountRequest = tokenCountRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as TokenCountResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Count tokens in a text
     * The tokenCount endpoint designed for counting tokens in text data.
     * @param tokenCountRequest 
     * @return ApiResponse<TokenCountResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun tokenCountWithHttpInfo(tokenCountRequest: TokenCountRequest) : ApiResponse<TokenCountResponse?> {
        val localVariableConfig = tokenCountRequestConfig(tokenCountRequest = tokenCountRequest)

        return request<TokenCountRequest, TokenCountResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation tokenCount
     *
     * @param tokenCountRequest 
     * @return RequestConfig
     */
    fun tokenCountRequestConfig(tokenCountRequest: TokenCountRequest) : RequestConfig<TokenCountRequest> {
        val localVariableBody = tokenCountRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json, application/problem+json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/extract/tokenCount",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * Converts data to a integer token array
     * The tokenizer endpoint designed for transforming textual data into integer tokens.
     * @param tokenizerRequest 
     * @return TokenizerResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun tokenize(tokenizerRequest: TokenizerRequest) : TokenizerResponse {
        val localVarResponse = tokenizeWithHttpInfo(tokenizerRequest = tokenizerRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as TokenizerResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Converts data to a integer token array
     * The tokenizer endpoint designed for transforming textual data into integer tokens.
     * @param tokenizerRequest 
     * @return ApiResponse<TokenizerResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun tokenizeWithHttpInfo(tokenizerRequest: TokenizerRequest) : ApiResponse<TokenizerResponse?> {
        val localVariableConfig = tokenizeRequestConfig(tokenizerRequest = tokenizerRequest)

        return request<TokenizerRequest, TokenizerResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation tokenize
     *
     * @param tokenizerRequest 
     * @return RequestConfig
     */
    fun tokenizeRequestConfig(tokenizerRequest: TokenizerRequest) : RequestConfig<TokenizerRequest> {
        val localVariableBody = tokenizerRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json, application/problem+json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/extract/tokenize",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter model
     */
     enum class ModelTranscriptionSynchronous(val value: kotlin.String) {
         @Json(name = "tiny") tiny("tiny"),
         @Json(name = "tiny.en") tinyPeriodEn("tiny.en"),
         @Json(name = "base") base("base"),
         @Json(name = "base.en") basePeriodEn("base.en"),
         @Json(name = "small") small("small"),
         @Json(name = "small.en") smallPeriodEn("small.en"),
         @Json(name = "medium") medium("medium"),
         @Json(name = "medium.en") mediumPeriodEn("medium.en"),
         @Json(name = "large_v1") large_v1("large_v1"),
         @Json(name = "large_v2") large_v2("large_v2"),
         @Json(name = "large_v3") large_v3("large_v3");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * Synchronous transcribe audio
     * The audio transcription endpoint is a specialized web service designed to convert spoken words from audio or video files into written text. This technology relies on advanced speech recognition algorithms to accurately transcribe the content of audio or video recordings. The endpoint typically accepts files in various formats, such as MP3, WAV for audio, and MP4, AVI for video, among others. Users can upload their files directly to the service, which then processes the audio track to extract the spoken words.  The transcription process involves several steps, including noise reduction to improve audio clarity, speaker diarization to identify and differentiate between different speakers, and the actual speech-to-text conversion. The result is a detailed transcript that captures the spoken content, often including timestamps and speaker labels for easy reference.  This service is particularly useful for journalists, researchers, podcasters, and professionals who need to convert meetings, interviews, lectures, or presentations into written form for analysis, sharing, or archival purposes. The endpoint may offer additional features like language detection, support for multiple languages, and customization options to improve transcription accuracy based on specific vocabulary or industry terms.  To use the audio transcription endpoint, developers typically integrate it into applications via API calls. These calls specify the file to be transcribed and any additional parameters required by the service, such as language preference.   Upon completion, the service returns the transcription in a JSON text format, which can then be displayed, stored, or further processed according to the user&#39;s needs.
     * @param files The file object to ingest.
     * @param model Model to use for transcription (Optional, default &#x3D; Base) (optional)
     * @param language The language of the input audio. Supplying the input language in [ISO-639-1](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) format will improve accuracy and latency.  (optional) (optional)
     * @param prompt An optional text to guide the model&#39;s style or continue a previous audio segment. The prompt should match the audio language.  (optional) (optional)
     * @param temperature The sampling temperature, between 0 and 1. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. If set to 0, the model will use [log probability](https://en.wikipedia.org/wiki/Log_probability) to automatically increase the temperature until certain thresholds are hit.  (optional, default to 0M) (optional, default to 0.0)
     * @param splitOnWord Split into word segments. (optional, default is false) (optional, default to false)
     * @param languageDetection Enable transcription language detection (Optional. default is false) (optional, default to false)
     * @param enableNoiseReduction Enable noise reduction from audio stream before transcription (Optional. default is false) (optional, default to false)
     * @return TranscriptionResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun transcriptionSynchronous(files: kotlin.collections.List<java.io.File>, model: ModelTranscriptionSynchronous? = null, language: kotlin.String? = null, prompt: kotlin.String? = null, temperature: kotlin.Double? = 0.0, splitOnWord: kotlin.Boolean? = false, languageDetection: kotlin.Boolean? = false, enableNoiseReduction: kotlin.Boolean? = false) : TranscriptionResponse {
        val localVarResponse = transcriptionSynchronousWithHttpInfo(files = files, model = model, language = language, prompt = prompt, temperature = temperature, splitOnWord = splitOnWord, languageDetection = languageDetection, enableNoiseReduction = enableNoiseReduction)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as TranscriptionResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Synchronous transcribe audio
     * The audio transcription endpoint is a specialized web service designed to convert spoken words from audio or video files into written text. This technology relies on advanced speech recognition algorithms to accurately transcribe the content of audio or video recordings. The endpoint typically accepts files in various formats, such as MP3, WAV for audio, and MP4, AVI for video, among others. Users can upload their files directly to the service, which then processes the audio track to extract the spoken words.  The transcription process involves several steps, including noise reduction to improve audio clarity, speaker diarization to identify and differentiate between different speakers, and the actual speech-to-text conversion. The result is a detailed transcript that captures the spoken content, often including timestamps and speaker labels for easy reference.  This service is particularly useful for journalists, researchers, podcasters, and professionals who need to convert meetings, interviews, lectures, or presentations into written form for analysis, sharing, or archival purposes. The endpoint may offer additional features like language detection, support for multiple languages, and customization options to improve transcription accuracy based on specific vocabulary or industry terms.  To use the audio transcription endpoint, developers typically integrate it into applications via API calls. These calls specify the file to be transcribed and any additional parameters required by the service, such as language preference.   Upon completion, the service returns the transcription in a JSON text format, which can then be displayed, stored, or further processed according to the user&#39;s needs.
     * @param files The file object to ingest.
     * @param model Model to use for transcription (Optional, default &#x3D; Base) (optional)
     * @param language The language of the input audio. Supplying the input language in [ISO-639-1](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) format will improve accuracy and latency.  (optional) (optional)
     * @param prompt An optional text to guide the model&#39;s style or continue a previous audio segment. The prompt should match the audio language.  (optional) (optional)
     * @param temperature The sampling temperature, between 0 and 1. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. If set to 0, the model will use [log probability](https://en.wikipedia.org/wiki/Log_probability) to automatically increase the temperature until certain thresholds are hit.  (optional, default to 0M) (optional, default to 0.0)
     * @param splitOnWord Split into word segments. (optional, default is false) (optional, default to false)
     * @param languageDetection Enable transcription language detection (Optional. default is false) (optional, default to false)
     * @param enableNoiseReduction Enable noise reduction from audio stream before transcription (Optional. default is false) (optional, default to false)
     * @return ApiResponse<TranscriptionResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun transcriptionSynchronousWithHttpInfo(files: kotlin.collections.List<java.io.File>, model: ModelTranscriptionSynchronous?, language: kotlin.String?, prompt: kotlin.String?, temperature: kotlin.Double?, splitOnWord: kotlin.Boolean?, languageDetection: kotlin.Boolean?, enableNoiseReduction: kotlin.Boolean?) : ApiResponse<TranscriptionResponse?> {
        val localVariableConfig = transcriptionSynchronousRequestConfig(files = files, model = model, language = language, prompt = prompt, temperature = temperature, splitOnWord = splitOnWord, languageDetection = languageDetection, enableNoiseReduction = enableNoiseReduction)

        return request<Map<String, PartConfig<*>>, TranscriptionResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation transcriptionSynchronous
     *
     * @param files The file object to ingest.
     * @param model Model to use for transcription (Optional, default &#x3D; Base) (optional)
     * @param language The language of the input audio. Supplying the input language in [ISO-639-1](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) format will improve accuracy and latency.  (optional) (optional)
     * @param prompt An optional text to guide the model&#39;s style or continue a previous audio segment. The prompt should match the audio language.  (optional) (optional)
     * @param temperature The sampling temperature, between 0 and 1. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. If set to 0, the model will use [log probability](https://en.wikipedia.org/wiki/Log_probability) to automatically increase the temperature until certain thresholds are hit.  (optional, default to 0M) (optional, default to 0.0)
     * @param splitOnWord Split into word segments. (optional, default is false) (optional, default to false)
     * @param languageDetection Enable transcription language detection (Optional. default is false) (optional, default to false)
     * @param enableNoiseReduction Enable noise reduction from audio stream before transcription (Optional. default is false) (optional, default to false)
     * @return RequestConfig
     */
    fun transcriptionSynchronousRequestConfig(files: kotlin.collections.List<java.io.File>, model: ModelTranscriptionSynchronous?, language: kotlin.String?, prompt: kotlin.String?, temperature: kotlin.Double?, splitOnWord: kotlin.Boolean?, languageDetection: kotlin.Boolean?, enableNoiseReduction: kotlin.Boolean?) : RequestConfig<Map<String, PartConfig<*>>> {
        val localVariableBody = mapOf(
            "files" to PartConfig(body = files, headers = mutableMapOf()),)
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (model != null) {
                    put("model", listOf(model.value))
                }
                if (language != null) {
                    put("language", listOf(language.toString()))
                }
                if (prompt != null) {
                    put("prompt", listOf(prompt.toString()))
                }
                if (temperature != null) {
                    put("temperature", listOf(temperature.toString()))
                }
                if (splitOnWord != null) {
                    put("splitOnWord", listOf(splitOnWord.toString()))
                }
                if (languageDetection != null) {
                    put("languageDetection", listOf(languageDetection.toString()))
                }
                if (enableNoiseReduction != null) {
                    put("enableNoiseReduction", listOf(enableNoiseReduction.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "multipart/form-data")
        localVariableHeaders["Accept"] = "application/json, application/problem+json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/extract/transcription",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
