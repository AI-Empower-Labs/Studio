/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package org.openapitools.client.apis

import java.io.IOException
import okhttp3.Call
import okhttp3.HttpUrl

import org.openapitools.client.models.AskDocumentRequest
import org.openapitools.client.models.AskDocumentResponse
import org.openapitools.client.models.DataPipelineStatus
import org.openapitools.client.models.HttpValidationProblemDetails
import org.openapitools.client.models.IngestDocumentResponse
import org.openapitools.client.models.IngestTextDocumentRequest
import org.openapitools.client.models.IngestWebPageDocumentRequest
import org.openapitools.client.models.KMeansCluster
import org.openapitools.client.models.ListDocumentParameters
import org.openapitools.client.models.ListDocumentResponse
import org.openapitools.client.models.ProblemDetails
import org.openapitools.client.models.QueryDocumentRequest
import org.openapitools.client.models.QueryDocumentResponse
import org.openapitools.client.models.ReRankDocumentsRequest
import org.openapitools.client.models.ReRankDocumentsResponse
import org.openapitools.client.models.SemanticSearchQueryResultsClusteringRequest

import com.squareup.moshi.Json

import org.openapitools.client.infrastructure.ApiClient
import org.openapitools.client.infrastructure.ApiResponse
import org.openapitools.client.infrastructure.ClientException
import org.openapitools.client.infrastructure.ClientError
import org.openapitools.client.infrastructure.ServerException
import org.openapitools.client.infrastructure.ServerError
import org.openapitools.client.infrastructure.MultiValueMap
import org.openapitools.client.infrastructure.PartConfig
import org.openapitools.client.infrastructure.RequestConfig
import org.openapitools.client.infrastructure.RequestMethod
import org.openapitools.client.infrastructure.ResponseType
import org.openapitools.client.infrastructure.Success
import org.openapitools.client.infrastructure.toMultiValue

class SemanticSearchApi(basePath: kotlin.String = defaultBasePath, client: Call.Factory = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://studio.aiempowerlabs.com")
        }
    }

    /**
     * 
     * Ask questions over ingested documents
     * @param askDocumentRequest 
     * @return AskDocumentResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun semanticSearchAsk(askDocumentRequest: AskDocumentRequest) : AskDocumentResponse {
        val localVarResponse = semanticSearchAskWithHttpInfo(askDocumentRequest = askDocumentRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AskDocumentResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Ask questions over ingested documents
     * @param askDocumentRequest 
     * @return ApiResponse<AskDocumentResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun semanticSearchAskWithHttpInfo(askDocumentRequest: AskDocumentRequest) : ApiResponse<AskDocumentResponse?> {
        val localVariableConfig = semanticSearchAskRequestConfig(askDocumentRequest = askDocumentRequest)

        return request<AskDocumentRequest, AskDocumentResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation semanticSearchAsk
     *
     * @param askDocumentRequest 
     * @return RequestConfig
     */
    fun semanticSearchAskRequestConfig(askDocumentRequest: AskDocumentRequest) : RequestConfig<AskDocumentRequest> {
        val localVariableBody = askDocumentRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json, application/problem+json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/semantic/ask",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * 
     * Delete specific document by id
     * @param documentId 
     * @param index 
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun semanticSearchDeleteDocument(documentId: kotlin.String, index: kotlin.String) : Unit {
        val localVarResponse = semanticSearchDeleteDocumentWithHttpInfo(documentId = documentId, index = index)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Delete specific document by id
     * @param documentId 
     * @param index 
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun semanticSearchDeleteDocumentWithHttpInfo(documentId: kotlin.String, index: kotlin.String) : ApiResponse<Unit?> {
        val localVariableConfig = semanticSearchDeleteDocumentRequestConfig(documentId = documentId, index = index)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation semanticSearchDeleteDocument
     *
     * @param documentId 
     * @param index 
     * @return RequestConfig
     */
    fun semanticSearchDeleteDocumentRequestConfig(documentId: kotlin.String, index: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("index", listOf(index.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/problem+json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/api/semantic/{documentId}".replace("{"+"documentId"+"}", encodeURIComponent(documentId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * 
     * Delete specific index by name
     * @param name 
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun semanticSearchDeleteIndex(name: kotlin.String) : Unit {
        val localVarResponse = semanticSearchDeleteIndexWithHttpInfo(name = name)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Delete specific index by name
     * @param name 
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun semanticSearchDeleteIndexWithHttpInfo(name: kotlin.String) : ApiResponse<Unit?> {
        val localVariableConfig = semanticSearchDeleteIndexRequestConfig(name = name)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation semanticSearchDeleteIndex
     *
     * @param name 
     * @return RequestConfig
     */
    fun semanticSearchDeleteIndexRequestConfig(name: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/problem+json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/api/semantic/index".replace("{"+"name"+"}", encodeURIComponent(name.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * 
     * Import file document into semantic search
     * @param files The file object to ingest.
     * @param documentId Id that uniquely identifies content within an index. Previously ingested documents with the same id will be overwritten schema. (optional)
     * @param index Optional value to specify with index the document should be ingested. Defaults to &#39;default&#39;. (optional)
     * @param pipeline Optional value to specify ingestion pipeline steps. Defaults to server configured defaults. (optional)
     * @param webHookUrl Url to use for webhook callback when operation finishes or fails. (optional)
     * @param embeddingModel Embedding model to use in ingestion. Optional. Default to configured default. (optional)
     * @param args  (optional)
     * @param tags Tags to associate with ingestion (optional)
     * @return IngestDocumentResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun semanticSearchFileIngestion(files: kotlin.collections.List<java.io.File>, documentId: kotlin.String? = null, index: kotlin.String? = null, pipeline: kotlin.collections.List<kotlin.String>? = null, webHookUrl: kotlin.String? = null, embeddingModel: kotlin.String? = null, args: kotlin.collections.Map<kotlin.String, kotlin.Any>? = null, tags: kotlin.collections.Map<kotlin.String, kotlin.Any>? = null) : IngestDocumentResponse {
        val localVarResponse = semanticSearchFileIngestionWithHttpInfo(files = files, documentId = documentId, index = index, pipeline = pipeline, webHookUrl = webHookUrl, embeddingModel = embeddingModel, args = args, tags = tags)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as IngestDocumentResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Import file document into semantic search
     * @param files The file object to ingest.
     * @param documentId Id that uniquely identifies content within an index. Previously ingested documents with the same id will be overwritten schema. (optional)
     * @param index Optional value to specify with index the document should be ingested. Defaults to &#39;default&#39;. (optional)
     * @param pipeline Optional value to specify ingestion pipeline steps. Defaults to server configured defaults. (optional)
     * @param webHookUrl Url to use for webhook callback when operation finishes or fails. (optional)
     * @param embeddingModel Embedding model to use in ingestion. Optional. Default to configured default. (optional)
     * @param args  (optional)
     * @param tags Tags to associate with ingestion (optional)
     * @return ApiResponse<IngestDocumentResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun semanticSearchFileIngestionWithHttpInfo(files: kotlin.collections.List<java.io.File>, documentId: kotlin.String?, index: kotlin.String?, pipeline: kotlin.collections.List<kotlin.String>?, webHookUrl: kotlin.String?, embeddingModel: kotlin.String?, args: kotlin.collections.Map<kotlin.String, kotlin.Any>?, tags: kotlin.collections.Map<kotlin.String, kotlin.Any>?) : ApiResponse<IngestDocumentResponse?> {
        val localVariableConfig = semanticSearchFileIngestionRequestConfig(files = files, documentId = documentId, index = index, pipeline = pipeline, webHookUrl = webHookUrl, embeddingModel = embeddingModel, args = args, tags = tags)

        return request<Map<String, PartConfig<*>>, IngestDocumentResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation semanticSearchFileIngestion
     *
     * @param files The file object to ingest.
     * @param documentId Id that uniquely identifies content within an index. Previously ingested documents with the same id will be overwritten schema. (optional)
     * @param index Optional value to specify with index the document should be ingested. Defaults to &#39;default&#39;. (optional)
     * @param pipeline Optional value to specify ingestion pipeline steps. Defaults to server configured defaults. (optional)
     * @param webHookUrl Url to use for webhook callback when operation finishes or fails. (optional)
     * @param embeddingModel Embedding model to use in ingestion. Optional. Default to configured default. (optional)
     * @param args  (optional)
     * @param tags Tags to associate with ingestion (optional)
     * @return RequestConfig
     */
    fun semanticSearchFileIngestionRequestConfig(files: kotlin.collections.List<java.io.File>, documentId: kotlin.String?, index: kotlin.String?, pipeline: kotlin.collections.List<kotlin.String>?, webHookUrl: kotlin.String?, embeddingModel: kotlin.String?, args: kotlin.collections.Map<kotlin.String, kotlin.Any>?, tags: kotlin.collections.Map<kotlin.String, kotlin.Any>?) : RequestConfig<Map<String, PartConfig<*>>> {
        val localVariableBody = mapOf(
            "files" to PartConfig(body = files, headers = mutableMapOf()),
            "args" to PartConfig(body = args, headers = mutableMapOf()),
            "tags" to PartConfig(body = tags, headers = mutableMapOf()),)
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (documentId != null) {
                    put("documentId", listOf(documentId.toString()))
                }
                if (index != null) {
                    put("index", listOf(index.toString()))
                }
                if (pipeline != null) {
                    put("pipeline", toMultiValue(pipeline.toList(), "multi"))
                }
                if (webHookUrl != null) {
                    put("webHookUrl", listOf(webHookUrl.toString()))
                }
                if (embeddingModel != null) {
                    put("embeddingModel", listOf(embeddingModel.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "multipart/form-data")
        localVariableHeaders["Accept"] = "application/json, application/problem+json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/ingest/file",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get queue status for ingestion job
     * @param id 
     * @return DataPipelineStatus
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun semanticSearchIngestionStatus(id: java.util.UUID) : DataPipelineStatus {
        val localVarResponse = semanticSearchIngestionStatusWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DataPipelineStatus
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get queue status for ingestion job
     * @param id 
     * @return ApiResponse<DataPipelineStatus?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun semanticSearchIngestionStatusWithHttpInfo(id: java.util.UUID) : ApiResponse<DataPipelineStatus?> {
        val localVariableConfig = semanticSearchIngestionStatusRequestConfig(id = id)

        return request<Unit, DataPipelineStatus>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation semanticSearchIngestionStatus
     *
     * @param id 
     * @return RequestConfig
     */
    fun semanticSearchIngestionStatusRequestConfig(id: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("id", listOf(id.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json, application/problem+json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/ingest/status",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * 
     * List - and filter - for ingested documents
     * @param listDocumentParameters 
     * @return ListDocumentResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun semanticSearchList(listDocumentParameters: ListDocumentParameters) : ListDocumentResponse {
        val localVarResponse = semanticSearchListWithHttpInfo(listDocumentParameters = listDocumentParameters)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ListDocumentResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * List - and filter - for ingested documents
     * @param listDocumentParameters 
     * @return ApiResponse<ListDocumentResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun semanticSearchListWithHttpInfo(listDocumentParameters: ListDocumentParameters) : ApiResponse<ListDocumentResponse?> {
        val localVariableConfig = semanticSearchListRequestConfig(listDocumentParameters = listDocumentParameters)

        return request<ListDocumentParameters, ListDocumentResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation semanticSearchList
     *
     * @param listDocumentParameters 
     * @return RequestConfig
     */
    fun semanticSearchListRequestConfig(listDocumentParameters: ListDocumentParameters) : RequestConfig<ListDocumentParameters> {
        val localVariableBody = listDocumentParameters
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json, application/problem+json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/semantic/list",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * 
     * Query ingested documents using semantic search
     * @param queryDocumentRequest 
     * @return QueryDocumentResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun semanticSearchQuery(queryDocumentRequest: QueryDocumentRequest) : QueryDocumentResponse {
        val localVarResponse = semanticSearchQueryWithHttpInfo(queryDocumentRequest = queryDocumentRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as QueryDocumentResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Query ingested documents using semantic search
     * @param queryDocumentRequest 
     * @return ApiResponse<QueryDocumentResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun semanticSearchQueryWithHttpInfo(queryDocumentRequest: QueryDocumentRequest) : ApiResponse<QueryDocumentResponse?> {
        val localVariableConfig = semanticSearchQueryRequestConfig(queryDocumentRequest = queryDocumentRequest)

        return request<QueryDocumentRequest, QueryDocumentResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation semanticSearchQuery
     *
     * @param queryDocumentRequest 
     * @return RequestConfig
     */
    fun semanticSearchQueryRequestConfig(queryDocumentRequest: QueryDocumentRequest) : RequestConfig<QueryDocumentRequest> {
        val localVariableBody = queryDocumentRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json, application/problem+json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/semantic/query",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * 
     * Perform k-means clustering over semantic search log entries
     * @param semanticSearchQueryResultsClusteringRequest 
     * @return KMeansCluster
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun semanticSearchQueryResultsClustering(semanticSearchQueryResultsClusteringRequest: SemanticSearchQueryResultsClusteringRequest) : KMeansCluster {
        val localVarResponse = semanticSearchQueryResultsClusteringWithHttpInfo(semanticSearchQueryResultsClusteringRequest = semanticSearchQueryResultsClusteringRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as KMeansCluster
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Perform k-means clustering over semantic search log entries
     * @param semanticSearchQueryResultsClusteringRequest 
     * @return ApiResponse<KMeansCluster?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun semanticSearchQueryResultsClusteringWithHttpInfo(semanticSearchQueryResultsClusteringRequest: SemanticSearchQueryResultsClusteringRequest) : ApiResponse<KMeansCluster?> {
        val localVariableConfig = semanticSearchQueryResultsClusteringRequestConfig(semanticSearchQueryResultsClusteringRequest = semanticSearchQueryResultsClusteringRequest)

        return request<SemanticSearchQueryResultsClusteringRequest, KMeansCluster>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation semanticSearchQueryResultsClustering
     *
     * @param semanticSearchQueryResultsClusteringRequest 
     * @return RequestConfig
     */
    fun semanticSearchQueryResultsClusteringRequestConfig(semanticSearchQueryResultsClusteringRequest: SemanticSearchQueryResultsClusteringRequest) : RequestConfig<SemanticSearchQueryResultsClusteringRequest> {
        val localVariableBody = semanticSearchQueryResultsClusteringRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json, application/problem+json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/semantic/query-results-clustering",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * 
     * Rerank documents
     * @param reRankDocumentsRequest 
     * @return ReRankDocumentsResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun semanticSearchRerank(reRankDocumentsRequest: ReRankDocumentsRequest) : ReRankDocumentsResponse {
        val localVarResponse = semanticSearchRerankWithHttpInfo(reRankDocumentsRequest = reRankDocumentsRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ReRankDocumentsResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Rerank documents
     * @param reRankDocumentsRequest 
     * @return ApiResponse<ReRankDocumentsResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun semanticSearchRerankWithHttpInfo(reRankDocumentsRequest: ReRankDocumentsRequest) : ApiResponse<ReRankDocumentsResponse?> {
        val localVariableConfig = semanticSearchRerankRequestConfig(reRankDocumentsRequest = reRankDocumentsRequest)

        return request<ReRankDocumentsRequest, ReRankDocumentsResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation semanticSearchRerank
     *
     * @param reRankDocumentsRequest 
     * @return RequestConfig
     */
    fun semanticSearchRerankRequestConfig(reRankDocumentsRequest: ReRankDocumentsRequest) : RequestConfig<ReRankDocumentsRequest> {
        val localVariableBody = reRankDocumentsRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json, application/problem+json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/semantic/rerank",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * 
     * Import plain text into semantic search
     * @param ingestTextDocumentRequest 
     * @return IngestDocumentResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun semanticSearchTextIngestion(ingestTextDocumentRequest: IngestTextDocumentRequest) : IngestDocumentResponse {
        val localVarResponse = semanticSearchTextIngestionWithHttpInfo(ingestTextDocumentRequest = ingestTextDocumentRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as IngestDocumentResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Import plain text into semantic search
     * @param ingestTextDocumentRequest 
     * @return ApiResponse<IngestDocumentResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun semanticSearchTextIngestionWithHttpInfo(ingestTextDocumentRequest: IngestTextDocumentRequest) : ApiResponse<IngestDocumentResponse?> {
        val localVariableConfig = semanticSearchTextIngestionRequestConfig(ingestTextDocumentRequest = ingestTextDocumentRequest)

        return request<IngestTextDocumentRequest, IngestDocumentResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation semanticSearchTextIngestion
     *
     * @param ingestTextDocumentRequest 
     * @return RequestConfig
     */
    fun semanticSearchTextIngestionRequestConfig(ingestTextDocumentRequest: IngestTextDocumentRequest) : RequestConfig<IngestTextDocumentRequest> {
        val localVariableBody = ingestTextDocumentRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json, application/problem+json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/ingest/text",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * 
     * Import web page text into semantic search
     * @param ingestWebPageDocumentRequest 
     * @return IngestDocumentResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun semanticSearchWebpageIngestion(ingestWebPageDocumentRequest: IngestWebPageDocumentRequest) : IngestDocumentResponse {
        val localVarResponse = semanticSearchWebpageIngestionWithHttpInfo(ingestWebPageDocumentRequest = ingestWebPageDocumentRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as IngestDocumentResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Import web page text into semantic search
     * @param ingestWebPageDocumentRequest 
     * @return ApiResponse<IngestDocumentResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun semanticSearchWebpageIngestionWithHttpInfo(ingestWebPageDocumentRequest: IngestWebPageDocumentRequest) : ApiResponse<IngestDocumentResponse?> {
        val localVariableConfig = semanticSearchWebpageIngestionRequestConfig(ingestWebPageDocumentRequest = ingestWebPageDocumentRequest)

        return request<IngestWebPageDocumentRequest, IngestDocumentResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation semanticSearchWebpageIngestion
     *
     * @param ingestWebPageDocumentRequest 
     * @return RequestConfig
     */
    fun semanticSearchWebpageIngestionRequestConfig(ingestWebPageDocumentRequest: IngestWebPageDocumentRequest) : RequestConfig<IngestWebPageDocumentRequest> {
        val localVariableBody = ingestWebPageDocumentRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json, application/problem+json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/ingest/webpage",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
