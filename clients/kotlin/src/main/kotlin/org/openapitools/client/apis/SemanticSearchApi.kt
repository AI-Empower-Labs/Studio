/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package org.openapitools.client.apis

import java.io.IOException
import okhttp3.Call
import okhttp3.HttpUrl

import org.openapitools.client.models.DataPipelineStatus
import org.openapitools.client.models.HttpValidationProblemDetails
import org.openapitools.client.models.IngestDocumentResponse
import org.openapitools.client.models.IngestTextDocumentRequest
import org.openapitools.client.models.IngestWebPageDocumentRequest
import org.openapitools.client.models.KMeansCluster
import org.openapitools.client.models.ListDocumentParameters
import org.openapitools.client.models.ListDocumentResponse
import org.openapitools.client.models.ProblemDetails
import org.openapitools.client.models.QueryDocumentRequest
import org.openapitools.client.models.QueryDocumentResponse
import org.openapitools.client.models.ReRankDocumentsRequest
import org.openapitools.client.models.ReRankDocumentsResponse
import org.openapitools.client.models.SemanticSearchQueryResultsClusteringRequest

import com.squareup.moshi.Json

import org.openapitools.client.infrastructure.ApiClient
import org.openapitools.client.infrastructure.ApiResponse
import org.openapitools.client.infrastructure.ClientException
import org.openapitools.client.infrastructure.ClientError
import org.openapitools.client.infrastructure.ServerException
import org.openapitools.client.infrastructure.ServerError
import org.openapitools.client.infrastructure.MultiValueMap
import org.openapitools.client.infrastructure.PartConfig
import org.openapitools.client.infrastructure.RequestConfig
import org.openapitools.client.infrastructure.RequestMethod
import org.openapitools.client.infrastructure.ResponseType
import org.openapitools.client.infrastructure.Success
import org.openapitools.client.infrastructure.toMultiValue

class SemanticSearchApi(basePath: kotlin.String = defaultBasePath, client: Call.Factory = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://studio.aiempowerlabs.com")
        }
    }

    /**
     * DELETE /api/semantic/{documentId}
     * 
     * Delete specific document by id
     * @param documentId 
     * @param index 
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun semanticSearchDeleteDocument(documentId: kotlin.String, index: kotlin.String) : Unit {
        val localVarResponse = semanticSearchDeleteDocumentWithHttpInfo(documentId = documentId, index = index)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * DELETE /api/semantic/{documentId}
     * 
     * Delete specific document by id
     * @param documentId 
     * @param index 
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun semanticSearchDeleteDocumentWithHttpInfo(documentId: kotlin.String, index: kotlin.String) : ApiResponse<Unit?> {
        val localVariableConfig = semanticSearchDeleteDocumentRequestConfig(documentId = documentId, index = index)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation semanticSearchDeleteDocument
     *
     * @param documentId 
     * @param index 
     * @return RequestConfig
     */
    fun semanticSearchDeleteDocumentRequestConfig(documentId: kotlin.String, index: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("index", listOf(index.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/problem+json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/api/semantic/{documentId}".replace("{"+"documentId"+"}", encodeURIComponent(documentId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * DELETE /api/semantic/index/{name}
     * 
     * Delete specific index by name
     * @param name 
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun semanticSearchDeleteIndex(name: kotlin.String) : Unit {
        val localVarResponse = semanticSearchDeleteIndexWithHttpInfo(name = name)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * DELETE /api/semantic/index/{name}
     * 
     * Delete specific index by name
     * @param name 
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun semanticSearchDeleteIndexWithHttpInfo(name: kotlin.String) : ApiResponse<Unit?> {
        val localVariableConfig = semanticSearchDeleteIndexRequestConfig(name = name)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation semanticSearchDeleteIndex
     *
     * @param name 
     * @return RequestConfig
     */
    fun semanticSearchDeleteIndexRequestConfig(name: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/problem+json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/api/semantic/index/{name}".replace("{"+"name"+"}", encodeURIComponent(name.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter language
     */
     enum class LanguageSemanticSearchFileIngestion(val value: kotlin.String) {
         @Json(name = "arabic") arabic("arabic"),
         @Json(name = "armenian") armenian("armenian"),
         @Json(name = "basque") basque("basque"),
         @Json(name = "catalan") catalan("catalan"),
         @Json(name = "danish") danish("danish"),
         @Json(name = "dutch") dutch("dutch"),
         @Json(name = "english") english("english"),
         @Json(name = "finnish") finnish("finnish"),
         @Json(name = "french") french("french"),
         @Json(name = "german") german("german"),
         @Json(name = "greek") greek("greek"),
         @Json(name = "hindi") hindi("hindi"),
         @Json(name = "hungarian") hungarian("hungarian"),
         @Json(name = "indonesian") indonesian("indonesian"),
         @Json(name = "irish") irish("irish"),
         @Json(name = "italian") italian("italian"),
         @Json(name = "lithuanian") lithuanian("lithuanian"),
         @Json(name = "nepali") nepali("nepali"),
         @Json(name = "norwegian") norwegian("norwegian"),
         @Json(name = "portuguese") portuguese("portuguese"),
         @Json(name = "romanian") romanian("romanian"),
         @Json(name = "russian") russian("russian"),
         @Json(name = "serbian") serbian("serbian"),
         @Json(name = "spanish") spanish("spanish"),
         @Json(name = "swedish") swedish("swedish"),
         @Json(name = "tamil") tamil("tamil"),
         @Json(name = "turkish") turkish("turkish"),
         @Json(name = "yiddish") yiddish("yiddish"),
         @Json(name = "simple") simple("simple");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * POST /api/ingest/file
     * Ingest a File into Semantic Search
     * Uploads and ingests a file document into the semantic search index. Supports optional configuration of index, ingestion pipeline, embedding model, and webhook for processing status.
     * @param documentId2 Unique identifier for the document to ingest.
     * @param files A collection of files to be ingested. Must contain at least one file.
     * @param documentId A unique identifier for the document within the index. Documents with the same ID will be overwritten. (optional)
     * @param index The name of the index where the document will be ingested. Defaults to &#39;default&#39; if not specified. (optional)
     * @param pipeline An array of ingestion pipeline step names. If not provided, server default steps will be used. (optional)
     * @param webHookUrl A URL to receive a callback via webhook when the ingestion process is completed or fails. (optional)
     * @param embeddingModel The embedding model to use during ingestion. If not specified, the server&#39;s default model will be applied. (optional)
     * @param index2 Optional index name where the document will be stored. (optional)
     * @param webHookUrl2 Optional webhook URL to notify upon completion. (optional)
     * @param embeddingModelName Optional name of the embedding model to use during ingestion. (optional)
     * @param context Optional key-value pairs for additional context or metadata. (optional)
     * @param tags A collection of tags associated with the document. Tags can be language-specific. (optional)
     * @param ingestionPipeline Optional list of ingestion pipeline steps. Allows custom processing. (optional)
     * @param languageAutoDetection Enable automatic language detection for document content. (optional, default to false)
     * @param language Force a specific language for full-text search. Use &#39;simple&#39; for no language or leave empty. (optional)
     * @return IngestDocumentResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun semanticSearchFileIngestion(documentId2: kotlin.String, files: kotlin.collections.List<java.io.File>, documentId: kotlin.String? = null, index: kotlin.String? = null, pipeline: kotlin.collections.List<kotlin.String>? = null, webHookUrl: java.net.URI? = null, embeddingModel: kotlin.String? = null, index2: kotlin.String? = null, webHookUrl2: java.net.URI? = null, embeddingModelName: kotlin.String? = null, context: kotlin.collections.Map<kotlin.String, kotlin.String>? = null, tags: kotlin.collections.Map<kotlin.String, kotlin.collections.List<kotlin.String>>? = null, ingestionPipeline: kotlin.collections.List<kotlin.String>? = null, languageAutoDetection: kotlin.Boolean? = false, language: LanguageSemanticSearchFileIngestion? = null) : IngestDocumentResponse {
        val localVarResponse = semanticSearchFileIngestionWithHttpInfo(documentId2 = documentId2, files = files, documentId = documentId, index = index, pipeline = pipeline, webHookUrl = webHookUrl, embeddingModel = embeddingModel, index2 = index2, webHookUrl2 = webHookUrl2, embeddingModelName = embeddingModelName, context = context, tags = tags, ingestionPipeline = ingestionPipeline, languageAutoDetection = languageAutoDetection, language = language)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as IngestDocumentResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/ingest/file
     * Ingest a File into Semantic Search
     * Uploads and ingests a file document into the semantic search index. Supports optional configuration of index, ingestion pipeline, embedding model, and webhook for processing status.
     * @param documentId2 Unique identifier for the document to ingest.
     * @param files A collection of files to be ingested. Must contain at least one file.
     * @param documentId A unique identifier for the document within the index. Documents with the same ID will be overwritten. (optional)
     * @param index The name of the index where the document will be ingested. Defaults to &#39;default&#39; if not specified. (optional)
     * @param pipeline An array of ingestion pipeline step names. If not provided, server default steps will be used. (optional)
     * @param webHookUrl A URL to receive a callback via webhook when the ingestion process is completed or fails. (optional)
     * @param embeddingModel The embedding model to use during ingestion. If not specified, the server&#39;s default model will be applied. (optional)
     * @param index2 Optional index name where the document will be stored. (optional)
     * @param webHookUrl2 Optional webhook URL to notify upon completion. (optional)
     * @param embeddingModelName Optional name of the embedding model to use during ingestion. (optional)
     * @param context Optional key-value pairs for additional context or metadata. (optional)
     * @param tags A collection of tags associated with the document. Tags can be language-specific. (optional)
     * @param ingestionPipeline Optional list of ingestion pipeline steps. Allows custom processing. (optional)
     * @param languageAutoDetection Enable automatic language detection for document content. (optional, default to false)
     * @param language Force a specific language for full-text search. Use &#39;simple&#39; for no language or leave empty. (optional)
     * @return ApiResponse<IngestDocumentResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun semanticSearchFileIngestionWithHttpInfo(documentId2: kotlin.String, files: kotlin.collections.List<java.io.File>, documentId: kotlin.String?, index: kotlin.String?, pipeline: kotlin.collections.List<kotlin.String>?, webHookUrl: java.net.URI?, embeddingModel: kotlin.String?, index2: kotlin.String?, webHookUrl2: java.net.URI?, embeddingModelName: kotlin.String?, context: kotlin.collections.Map<kotlin.String, kotlin.String>?, tags: kotlin.collections.Map<kotlin.String, kotlin.collections.List<kotlin.String>>?, ingestionPipeline: kotlin.collections.List<kotlin.String>?, languageAutoDetection: kotlin.Boolean?, language: LanguageSemanticSearchFileIngestion?) : ApiResponse<IngestDocumentResponse?> {
        val localVariableConfig = semanticSearchFileIngestionRequestConfig(documentId2 = documentId2, files = files, documentId = documentId, index = index, pipeline = pipeline, webHookUrl = webHookUrl, embeddingModel = embeddingModel, index2 = index2, webHookUrl2 = webHookUrl2, embeddingModelName = embeddingModelName, context = context, tags = tags, ingestionPipeline = ingestionPipeline, languageAutoDetection = languageAutoDetection, language = language)

        return request<Map<String, PartConfig<*>>, IngestDocumentResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation semanticSearchFileIngestion
     *
     * @param documentId2 Unique identifier for the document to ingest.
     * @param files A collection of files to be ingested. Must contain at least one file.
     * @param documentId A unique identifier for the document within the index. Documents with the same ID will be overwritten. (optional)
     * @param index The name of the index where the document will be ingested. Defaults to &#39;default&#39; if not specified. (optional)
     * @param pipeline An array of ingestion pipeline step names. If not provided, server default steps will be used. (optional)
     * @param webHookUrl A URL to receive a callback via webhook when the ingestion process is completed or fails. (optional)
     * @param embeddingModel The embedding model to use during ingestion. If not specified, the server&#39;s default model will be applied. (optional)
     * @param index2 Optional index name where the document will be stored. (optional)
     * @param webHookUrl2 Optional webhook URL to notify upon completion. (optional)
     * @param embeddingModelName Optional name of the embedding model to use during ingestion. (optional)
     * @param context Optional key-value pairs for additional context or metadata. (optional)
     * @param tags A collection of tags associated with the document. Tags can be language-specific. (optional)
     * @param ingestionPipeline Optional list of ingestion pipeline steps. Allows custom processing. (optional)
     * @param languageAutoDetection Enable automatic language detection for document content. (optional, default to false)
     * @param language Force a specific language for full-text search. Use &#39;simple&#39; for no language or leave empty. (optional)
     * @return RequestConfig
     */
    fun semanticSearchFileIngestionRequestConfig(documentId2: kotlin.String, files: kotlin.collections.List<java.io.File>, documentId: kotlin.String?, index: kotlin.String?, pipeline: kotlin.collections.List<kotlin.String>?, webHookUrl: java.net.URI?, embeddingModel: kotlin.String?, index2: kotlin.String?, webHookUrl2: java.net.URI?, embeddingModelName: kotlin.String?, context: kotlin.collections.Map<kotlin.String, kotlin.String>?, tags: kotlin.collections.Map<kotlin.String, kotlin.collections.List<kotlin.String>>?, ingestionPipeline: kotlin.collections.List<kotlin.String>?, languageAutoDetection: kotlin.Boolean?, language: LanguageSemanticSearchFileIngestion?) : RequestConfig<Map<String, PartConfig<*>>> {
        val localVariableBody = mapOf(
            "documentId" to PartConfig(body = documentId2, headers = mutableMapOf()),
            "index" to PartConfig(body = index2, headers = mutableMapOf()),
            "webHookUrl" to PartConfig(body = webHookUrl2, headers = mutableMapOf()),
            "embeddingModelName" to PartConfig(body = embeddingModelName, headers = mutableMapOf()),
            "files" to PartConfig(body = files, headers = mutableMapOf()),
            "context" to PartConfig(body = context, headers = mutableMapOf()),
            "tags" to PartConfig(body = tags, headers = mutableMapOf()),
            "ingestionPipeline" to PartConfig(body = ingestionPipeline, headers = mutableMapOf()),
            "languageAutoDetection" to PartConfig(body = languageAutoDetection, headers = mutableMapOf()),
            "language" to PartConfig(body = language?.value, headers = mutableMapOf()),)
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (documentId != null) {
                    put("documentId", listOf(documentId.toString()))
                }
                if (index != null) {
                    put("index", listOf(index.toString()))
                }
                if (pipeline != null) {
                    put("pipeline", toMultiValue(pipeline.toList(), "multi"))
                }
                if (webHookUrl != null) {
                    put("webHookUrl", listOf(webHookUrl.toString()))
                }
                if (embeddingModel != null) {
                    put("embeddingModel", listOf(embeddingModel.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "multipart/form-data")
        localVariableHeaders["Accept"] = "application/json, application/problem+json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/ingest/file",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /api/ingest/status
     * 
     * Get queue status for ingestion job
     * @param id 
     * @return DataPipelineStatus
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun semanticSearchIngestionStatus(id: java.util.UUID) : DataPipelineStatus {
        val localVarResponse = semanticSearchIngestionStatusWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DataPipelineStatus
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /api/ingest/status
     * 
     * Get queue status for ingestion job
     * @param id 
     * @return ApiResponse<DataPipelineStatus?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun semanticSearchIngestionStatusWithHttpInfo(id: java.util.UUID) : ApiResponse<DataPipelineStatus?> {
        val localVariableConfig = semanticSearchIngestionStatusRequestConfig(id = id)

        return request<Unit, DataPipelineStatus>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation semanticSearchIngestionStatus
     *
     * @param id 
     * @return RequestConfig
     */
    fun semanticSearchIngestionStatusRequestConfig(id: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("id", listOf(id.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json, application/problem+json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/ingest/status",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /api/semantic/list
     * 
     * List - and filter - for ingested documents
     * @param listDocumentParameters 
     * @return ListDocumentResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun semanticSearchList(listDocumentParameters: ListDocumentParameters) : ListDocumentResponse {
        val localVarResponse = semanticSearchListWithHttpInfo(listDocumentParameters = listDocumentParameters)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ListDocumentResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/semantic/list
     * 
     * List - and filter - for ingested documents
     * @param listDocumentParameters 
     * @return ApiResponse<ListDocumentResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun semanticSearchListWithHttpInfo(listDocumentParameters: ListDocumentParameters) : ApiResponse<ListDocumentResponse?> {
        val localVariableConfig = semanticSearchListRequestConfig(listDocumentParameters = listDocumentParameters)

        return request<ListDocumentParameters, ListDocumentResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation semanticSearchList
     *
     * @param listDocumentParameters 
     * @return RequestConfig
     */
    fun semanticSearchListRequestConfig(listDocumentParameters: ListDocumentParameters) : RequestConfig<ListDocumentParameters> {
        val localVariableBody = listDocumentParameters
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json, application/problem+json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/semantic/list",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /api/semantic/query
     * 
     * Performs semantic or hybrid search over previously ingested data.
     * @param queryDocumentRequest 
     * @return QueryDocumentResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun semanticSearchQuery(queryDocumentRequest: QueryDocumentRequest) : QueryDocumentResponse {
        val localVarResponse = semanticSearchQueryWithHttpInfo(queryDocumentRequest = queryDocumentRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as QueryDocumentResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/semantic/query
     * 
     * Performs semantic or hybrid search over previously ingested data.
     * @param queryDocumentRequest 
     * @return ApiResponse<QueryDocumentResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun semanticSearchQueryWithHttpInfo(queryDocumentRequest: QueryDocumentRequest) : ApiResponse<QueryDocumentResponse?> {
        val localVariableConfig = semanticSearchQueryRequestConfig(queryDocumentRequest = queryDocumentRequest)

        return request<QueryDocumentRequest, QueryDocumentResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation semanticSearchQuery
     *
     * @param queryDocumentRequest 
     * @return RequestConfig
     */
    fun semanticSearchQueryRequestConfig(queryDocumentRequest: QueryDocumentRequest) : RequestConfig<QueryDocumentRequest> {
        val localVariableBody = queryDocumentRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json, application/problem+json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/semantic/query",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /api/semantic/query-results-clustering
     * 
     * Perform k-means clustering over semantic search log entries
     * @param semanticSearchQueryResultsClusteringRequest 
     * @return KMeansCluster
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun semanticSearchQueryResultsClustering(semanticSearchQueryResultsClusteringRequest: SemanticSearchQueryResultsClusteringRequest) : KMeansCluster {
        val localVarResponse = semanticSearchQueryResultsClusteringWithHttpInfo(semanticSearchQueryResultsClusteringRequest = semanticSearchQueryResultsClusteringRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as KMeansCluster
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/semantic/query-results-clustering
     * 
     * Perform k-means clustering over semantic search log entries
     * @param semanticSearchQueryResultsClusteringRequest 
     * @return ApiResponse<KMeansCluster?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun semanticSearchQueryResultsClusteringWithHttpInfo(semanticSearchQueryResultsClusteringRequest: SemanticSearchQueryResultsClusteringRequest) : ApiResponse<KMeansCluster?> {
        val localVariableConfig = semanticSearchQueryResultsClusteringRequestConfig(semanticSearchQueryResultsClusteringRequest = semanticSearchQueryResultsClusteringRequest)

        return request<SemanticSearchQueryResultsClusteringRequest, KMeansCluster>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation semanticSearchQueryResultsClustering
     *
     * @param semanticSearchQueryResultsClusteringRequest 
     * @return RequestConfig
     */
    fun semanticSearchQueryResultsClusteringRequestConfig(semanticSearchQueryResultsClusteringRequest: SemanticSearchQueryResultsClusteringRequest) : RequestConfig<SemanticSearchQueryResultsClusteringRequest> {
        val localVariableBody = semanticSearchQueryResultsClusteringRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json, application/problem+json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/semantic/query-results-clustering",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /api/semantic/rerank
     * 
     * Rerank documents
     * @param reRankDocumentsRequest 
     * @return ReRankDocumentsResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun semanticSearchRerank(reRankDocumentsRequest: ReRankDocumentsRequest) : ReRankDocumentsResponse {
        val localVarResponse = semanticSearchRerankWithHttpInfo(reRankDocumentsRequest = reRankDocumentsRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ReRankDocumentsResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/semantic/rerank
     * 
     * Rerank documents
     * @param reRankDocumentsRequest 
     * @return ApiResponse<ReRankDocumentsResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun semanticSearchRerankWithHttpInfo(reRankDocumentsRequest: ReRankDocumentsRequest) : ApiResponse<ReRankDocumentsResponse?> {
        val localVariableConfig = semanticSearchRerankRequestConfig(reRankDocumentsRequest = reRankDocumentsRequest)

        return request<ReRankDocumentsRequest, ReRankDocumentsResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation semanticSearchRerank
     *
     * @param reRankDocumentsRequest 
     * @return RequestConfig
     */
    fun semanticSearchRerankRequestConfig(reRankDocumentsRequest: ReRankDocumentsRequest) : RequestConfig<ReRankDocumentsRequest> {
        val localVariableBody = reRankDocumentsRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json, application/problem+json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/semantic/rerank",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /api/ingest/text
     * Ingest Plain Text for Semantic Search
     * Ingests a plain text document into the semantic search index. This endpoint allows associating tags and specifying the target index for enhanced search capabilities.
     * @param ingestTextDocumentRequest 
     * @return IngestDocumentResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun semanticSearchTextIngestion(ingestTextDocumentRequest: IngestTextDocumentRequest) : IngestDocumentResponse {
        val localVarResponse = semanticSearchTextIngestionWithHttpInfo(ingestTextDocumentRequest = ingestTextDocumentRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as IngestDocumentResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/ingest/text
     * Ingest Plain Text for Semantic Search
     * Ingests a plain text document into the semantic search index. This endpoint allows associating tags and specifying the target index for enhanced search capabilities.
     * @param ingestTextDocumentRequest 
     * @return ApiResponse<IngestDocumentResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun semanticSearchTextIngestionWithHttpInfo(ingestTextDocumentRequest: IngestTextDocumentRequest) : ApiResponse<IngestDocumentResponse?> {
        val localVariableConfig = semanticSearchTextIngestionRequestConfig(ingestTextDocumentRequest = ingestTextDocumentRequest)

        return request<IngestTextDocumentRequest, IngestDocumentResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation semanticSearchTextIngestion
     *
     * @param ingestTextDocumentRequest 
     * @return RequestConfig
     */
    fun semanticSearchTextIngestionRequestConfig(ingestTextDocumentRequest: IngestTextDocumentRequest) : RequestConfig<IngestTextDocumentRequest> {
        val localVariableBody = ingestTextDocumentRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json, application/problem+json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/ingest/text",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /api/ingest/webpage
     * 
     * Import web page text into semantic search
     * @param ingestWebPageDocumentRequest 
     * @return IngestDocumentResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun semanticSearchWebpageIngestion(ingestWebPageDocumentRequest: IngestWebPageDocumentRequest) : IngestDocumentResponse {
        val localVarResponse = semanticSearchWebpageIngestionWithHttpInfo(ingestWebPageDocumentRequest = ingestWebPageDocumentRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as IngestDocumentResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/ingest/webpage
     * 
     * Import web page text into semantic search
     * @param ingestWebPageDocumentRequest 
     * @return ApiResponse<IngestDocumentResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun semanticSearchWebpageIngestionWithHttpInfo(ingestWebPageDocumentRequest: IngestWebPageDocumentRequest) : ApiResponse<IngestDocumentResponse?> {
        val localVariableConfig = semanticSearchWebpageIngestionRequestConfig(ingestWebPageDocumentRequest = ingestWebPageDocumentRequest)

        return request<IngestWebPageDocumentRequest, IngestDocumentResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation semanticSearchWebpageIngestion
     *
     * @param ingestWebPageDocumentRequest 
     * @return RequestConfig
     */
    fun semanticSearchWebpageIngestionRequestConfig(ingestWebPageDocumentRequest: IngestWebPageDocumentRequest) : RequestConfig<IngestWebPageDocumentRequest> {
        val localVariableBody = ingestWebPageDocumentRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json, application/problem+json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/ingest/webpage",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
