// <auto-generated>
/*
 * Studio - AI Empower Labs
 *
 * # Studio API Documentation  ## Introduction Welcome to Studio by AI Empower Labs API documentation! We are thrilled to offer developers around the world access to our cutting-edge artificial intelligence technology and semantic search. Our API is designed to empower your applications with state-of-the-art AI capabilities, including but not limited to natural language processing, audio transcription, embedding, and predictive analytics.  Our mission is to make AI technology accessible and easy to integrate, enabling you to enhance your applications, improve user experiences, and innovate in your field. Whether you're building complex systems, developing mobile apps, or creating web services, our API provides you with the tools you need to incorporate AI functionalities seamlessly.  Support and Feedback We are committed to providing exceptional support to our developer community. If you have any questions, encounter any issues, or have feedback on how we can improve our API, please don't hesitate to contact our support team @ support@AIEmpowerLabs.com.  Terms of Use Please review our terms of use and privacy policy before integrating our API into your application. By using our API, you agree to comply with these terms.
 *
 * The version of the OpenAPI document: v1
 * Contact: support@aiempowerlabs.com
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

#nullable enable

using System;
using System.Collections.Generic;
using System.Net;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text.Json;
using Org.OpenAPITools.Client;
using Org.OpenAPITools.Model;
using System.Diagnostics.CodeAnalysis;

namespace Org.OpenAPITools.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// This class is registered as transient.
    /// </summary>
    public interface IDataExtractionApi : IApi
    {
        /// <summary>
        /// The class containing the events
        /// </summary>
        DataExtractionApiEvents Events { get; }

        /// <summary>
        /// Generate thematic similarity clusters using the K-Means algorithm
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="apiExtractThematicSimilarityClusterPostRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IApiExtractThematicSimilarityClusterPostApiResponse"/>&gt;</returns>
        Task<IApiExtractThematicSimilarityClusterPostApiResponse> ApiExtractThematicSimilarityClusterPostAsync(ApiExtractThematicSimilarityClusterPostRequest apiExtractThematicSimilarityClusterPostRequest, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Generate thematic similarity clusters using the K-Means algorithm
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="apiExtractThematicSimilarityClusterPostRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IApiExtractThematicSimilarityClusterPostApiResponse"/>?&gt;</returns>
        Task<IApiExtractThematicSimilarityClusterPostApiResponse?> ApiExtractThematicSimilarityClusterPostOrDefaultAsync(ApiExtractThematicSimilarityClusterPostRequest apiExtractThematicSimilarityClusterPostRequest, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Converts data to a numerical vector array
        /// </summary>
        /// <remarks>
        /// The embedding endpoint is a sophisticated API designed for transforming textual data into high-dimensional vectors, facilitating a wide array of natural language processing (NLP) tasks. This transformation process encodes the semantic properties and contextual meanings of the input text into a vector space, enabling machines to understand and process language in a manner analogous to human comprehension.  ## Core Features:  * Semantic Encoding: Leverages advanced machine learning models, particularly those based on transformer architectures, to capture the deep semantic and syntactic nuances of the input text. This ensures that similar words and phrases are positioned closely in the vector space, reflecting their semantic proximity. * High-Dimensional Representation: Transforms texts into vectors in a high-dimensional space, typically ranging from hundreds to thousands of dimensions. This rich representation captures a comprehensive spectrum of linguistic features and relationships. * Scalability: Engineered to handle a wide range of text sizes, from short tweets to extensive documents, without compromising on the accuracy of the vector representations.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="embeddingRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IEmbeddingApiResponse"/>&gt;</returns>
        Task<IEmbeddingApiResponse> EmbeddingAsync(EmbeddingRequest embeddingRequest, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Converts data to a numerical vector array
        /// </summary>
        /// <remarks>
        /// The embedding endpoint is a sophisticated API designed for transforming textual data into high-dimensional vectors, facilitating a wide array of natural language processing (NLP) tasks. This transformation process encodes the semantic properties and contextual meanings of the input text into a vector space, enabling machines to understand and process language in a manner analogous to human comprehension.  ## Core Features:  * Semantic Encoding: Leverages advanced machine learning models, particularly those based on transformer architectures, to capture the deep semantic and syntactic nuances of the input text. This ensures that similar words and phrases are positioned closely in the vector space, reflecting their semantic proximity. * High-Dimensional Representation: Transforms texts into vectors in a high-dimensional space, typically ranging from hundreds to thousands of dimensions. This rich representation captures a comprehensive spectrum of linguistic features and relationships. * Scalability: Engineered to handle a wide range of text sizes, from short tweets to extensive documents, without compromising on the accuracy of the vector representations.
        /// </remarks>
        /// <param name="embeddingRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IEmbeddingApiResponse"/>?&gt;</returns>
        Task<IEmbeddingApiResponse?> EmbeddingOrDefaultAsync(EmbeddingRequest embeddingRequest, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Performs keyword extraction on source text
        /// </summary>
        /// <remarks>
        /// This endpoint accepts a string of text and returns a list of key words or phrases that best describe the content of the text. This can be used for tagging, summarizing, indexing, or categorizing content.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="keywordExtractionRequestBody"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IKeywordExtractionApiResponse"/>&gt;</returns>
        Task<IKeywordExtractionApiResponse> KeywordExtractionAsync(KeywordExtractionRequestBody keywordExtractionRequestBody, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Performs keyword extraction on source text
        /// </summary>
        /// <remarks>
        /// This endpoint accepts a string of text and returns a list of key words or phrases that best describe the content of the text. This can be used for tagging, summarizing, indexing, or categorizing content.
        /// </remarks>
        /// <param name="keywordExtractionRequestBody"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IKeywordExtractionApiResponse"/>?&gt;</returns>
        Task<IKeywordExtractionApiResponse?> KeywordExtractionOrDefaultAsync(KeywordExtractionRequestBody keywordExtractionRequestBody, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Extracts named entities from provided text
        /// </summary>
        /// <remarks>
        /// This endpoint accepts a string of text and returns a list of identified entities classified into categories such as email, location, organisation, etc.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="namedEntityRecognitionRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="INamedEntityRecognitionApiResponse"/>&gt;</returns>
        Task<INamedEntityRecognitionApiResponse> NamedEntityRecognitionAsync(NamedEntityRecognitionRequest namedEntityRecognitionRequest, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Extracts named entities from provided text
        /// </summary>
        /// <remarks>
        /// This endpoint accepts a string of text and returns a list of identified entities classified into categories such as email, location, organisation, etc.
        /// </remarks>
        /// <param name="namedEntityRecognitionRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="INamedEntityRecognitionApiResponse"/>?&gt;</returns>
        Task<INamedEntityRecognitionApiResponse?> NamedEntityRecognitionOrDefaultAsync(NamedEntityRecognitionRequest namedEntityRecognitionRequest, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Generate semantic similarity queries from text
        /// </summary>
        /// <remarks>
        /// Upon receiving a user-defined query and a set of texts, the endpoint processes this information through its semantic analysis engine. This engine leverages state-of-the-art machine learning models, such as transformer-based architectures, to encode the texts and the query into high-dimensional vectors. By operating in this semantic space, it can accurately measure the distances between the query vector and each of the text vectors, reflecting how closely the meanings align.  Use Cases:  * Content Discovery: Helps users find articles, posts, or documents that are most relevant to their query.  * Customer Support: Automatically matches customer queries to the most relevant FAQs or support documents.  * Research and Study: Assists researchers in quickly finding academic papers or resources that are closely related to their field of inquiry.  By utilizing the semantic similarity endpoint, organizations and individuals can greatly enhance the efficiency and effectiveness of their information retrieval processes, ensuring that users are connected with the content most pertinent to their needs.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="semanticSimilarityRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISemanticSimilarityApiResponse"/>&gt;</returns>
        Task<ISemanticSimilarityApiResponse> SemanticSimilarityAsync(SemanticSimilarityRequest semanticSimilarityRequest, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Generate semantic similarity queries from text
        /// </summary>
        /// <remarks>
        /// Upon receiving a user-defined query and a set of texts, the endpoint processes this information through its semantic analysis engine. This engine leverages state-of-the-art machine learning models, such as transformer-based architectures, to encode the texts and the query into high-dimensional vectors. By operating in this semantic space, it can accurately measure the distances between the query vector and each of the text vectors, reflecting how closely the meanings align.  Use Cases:  * Content Discovery: Helps users find articles, posts, or documents that are most relevant to their query.  * Customer Support: Automatically matches customer queries to the most relevant FAQs or support documents.  * Research and Study: Assists researchers in quickly finding academic papers or resources that are closely related to their field of inquiry.  By utilizing the semantic similarity endpoint, organizations and individuals can greatly enhance the efficiency and effectiveness of their information retrieval processes, ensuring that users are connected with the content most pertinent to their needs.
        /// </remarks>
        /// <param name="semanticSimilarityRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISemanticSimilarityApiResponse"/>?&gt;</returns>
        Task<ISemanticSimilarityApiResponse?> SemanticSimilarityOrDefaultAsync(SemanticSimilarityRequest semanticSimilarityRequest, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Count tokens in a text
        /// </summary>
        /// <remarks>
        /// The tokenCount endpoint designed for counting tokens in text data.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenCountRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ITokenCountApiResponse"/>&gt;</returns>
        Task<ITokenCountApiResponse> TokenCountAsync(TokenCountRequest tokenCountRequest, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Count tokens in a text
        /// </summary>
        /// <remarks>
        /// The tokenCount endpoint designed for counting tokens in text data.
        /// </remarks>
        /// <param name="tokenCountRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ITokenCountApiResponse"/>?&gt;</returns>
        Task<ITokenCountApiResponse?> TokenCountOrDefaultAsync(TokenCountRequest tokenCountRequest, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Converts data to a integer token array
        /// </summary>
        /// <remarks>
        /// The tokenizer endpoint designed for transforming textual data into integer tokens.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenizerRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ITokenizeApiResponse"/>&gt;</returns>
        Task<ITokenizeApiResponse> TokenizeAsync(TokenizerRequest tokenizerRequest, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Converts data to a integer token array
        /// </summary>
        /// <remarks>
        /// The tokenizer endpoint designed for transforming textual data into integer tokens.
        /// </remarks>
        /// <param name="tokenizerRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ITokenizeApiResponse"/>?&gt;</returns>
        Task<ITokenizeApiResponse?> TokenizeOrDefaultAsync(TokenizerRequest tokenizerRequest, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Synchronous transcribe audio
        /// </summary>
        /// <remarks>
        /// The audio transcription endpoint is a specialized web service designed to convert spoken words from audio or video files into written text. This technology relies on advanced speech recognition algorithms to accurately transcribe the content of audio or video recordings. The endpoint typically accepts files in various formats, such as MP3, WAV for audio, and MP4, AVI for video, among others. Users can upload their files directly to the service, which then processes the audio track to extract the spoken words.  The transcription process involves several steps, including noise reduction to improve audio clarity, speaker diarization to identify and differentiate between different speakers, and the actual speech-to-text conversion. The result is a detailed transcript that captures the spoken content, often including timestamps and speaker labels for easy reference.  This service is particularly useful for journalists, researchers, podcasters, and professionals who need to convert meetings, interviews, lectures, or presentations into written form for analysis, sharing, or archival purposes. The endpoint may offer additional features like language detection, support for multiple languages, and customization options to improve transcription accuracy based on specific vocabulary or industry terms.  To use the audio transcription endpoint, developers typically integrate it into applications via API calls. These calls specify the file to be transcribed and any additional parameters required by the service, such as language preference.   Upon completion, the service returns the transcription in a JSON text format, which can then be displayed, stored, or further processed according to the user&#39;s needs.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="files">The file object to ingest.</param>
        /// <param name="model">Model to use for transcription (Optional, default &#x3D; Base) (optional)</param>
        /// <param name="language">The language of the input audio. Supplying the input language in [ISO-639-1](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) format will improve accuracy and latency.  (optional) (optional)</param>
        /// <param name="prompt">An optional text to guide the model&#39;s style or continue a previous audio segment. The prompt should match the audio language.  (optional) (optional)</param>
        /// <param name="temperature">The sampling temperature, between 0 and 1. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. If set to 0, the model will use [log probability](https://en.wikipedia.org/wiki/Log_probability) to automatically increase the temperature until certain thresholds are hit.  (optional, default to 0M) (optional, default to 0D)</param>
        /// <param name="splitOnWord">Split into word segments. (optional, default is false) (optional, default to false)</param>
        /// <param name="languageDetection">Enable transcription language detection (Optional. default is false) (optional, default to false)</param>
        /// <param name="enableNoiseReduction">Enable noise reduction from audio stream before transcription (Optional. default is false) (optional, default to false)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ITranscriptionSynchronousApiResponse"/>&gt;</returns>
        Task<ITranscriptionSynchronousApiResponse> TranscriptionSynchronousAsync(List<System.IO.Stream> files, Option<string> model = default, Option<string> language = default, Option<string> prompt = default, Option<double> temperature = default, Option<bool> splitOnWord = default, Option<bool> languageDetection = default, Option<bool> enableNoiseReduction = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Synchronous transcribe audio
        /// </summary>
        /// <remarks>
        /// The audio transcription endpoint is a specialized web service designed to convert spoken words from audio or video files into written text. This technology relies on advanced speech recognition algorithms to accurately transcribe the content of audio or video recordings. The endpoint typically accepts files in various formats, such as MP3, WAV for audio, and MP4, AVI for video, among others. Users can upload their files directly to the service, which then processes the audio track to extract the spoken words.  The transcription process involves several steps, including noise reduction to improve audio clarity, speaker diarization to identify and differentiate between different speakers, and the actual speech-to-text conversion. The result is a detailed transcript that captures the spoken content, often including timestamps and speaker labels for easy reference.  This service is particularly useful for journalists, researchers, podcasters, and professionals who need to convert meetings, interviews, lectures, or presentations into written form for analysis, sharing, or archival purposes. The endpoint may offer additional features like language detection, support for multiple languages, and customization options to improve transcription accuracy based on specific vocabulary or industry terms.  To use the audio transcription endpoint, developers typically integrate it into applications via API calls. These calls specify the file to be transcribed and any additional parameters required by the service, such as language preference.   Upon completion, the service returns the transcription in a JSON text format, which can then be displayed, stored, or further processed according to the user&#39;s needs.
        /// </remarks>
        /// <param name="files">The file object to ingest.</param>
        /// <param name="model">Model to use for transcription (Optional, default &#x3D; Base) (optional)</param>
        /// <param name="language">The language of the input audio. Supplying the input language in [ISO-639-1](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) format will improve accuracy and latency.  (optional) (optional)</param>
        /// <param name="prompt">An optional text to guide the model&#39;s style or continue a previous audio segment. The prompt should match the audio language.  (optional) (optional)</param>
        /// <param name="temperature">The sampling temperature, between 0 and 1. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. If set to 0, the model will use [log probability](https://en.wikipedia.org/wiki/Log_probability) to automatically increase the temperature until certain thresholds are hit.  (optional, default to 0M) (optional, default to 0D)</param>
        /// <param name="splitOnWord">Split into word segments. (optional, default is false) (optional, default to false)</param>
        /// <param name="languageDetection">Enable transcription language detection (Optional. default is false) (optional, default to false)</param>
        /// <param name="enableNoiseReduction">Enable noise reduction from audio stream before transcription (Optional. default is false) (optional, default to false)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ITranscriptionSynchronousApiResponse"/>?&gt;</returns>
        Task<ITranscriptionSynchronousApiResponse?> TranscriptionSynchronousOrDefaultAsync(List<System.IO.Stream> files, Option<string> model = default, Option<string> language = default, Option<string> prompt = default, Option<double> temperature = default, Option<bool> splitOnWord = default, Option<bool> languageDetection = default, Option<bool> enableNoiseReduction = default, System.Threading.CancellationToken cancellationToken = default);
    }

    /// <summary>
    /// The <see cref="IApiExtractThematicSimilarityClusterPostApiResponse"/>
    /// </summary>
    public interface IApiExtractThematicSimilarityClusterPostApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.KMeansCluster?>, IBadRequest<Org.OpenAPITools.Model.HttpValidationProblemDetails?>, ITooManyRequests<Org.OpenAPITools.Model.ProblemDetails?>, IInternalServerError<Org.OpenAPITools.Model.ProblemDetails?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 429 TooManyRequests
        /// </summary>
        /// <returns></returns>
        bool IsTooManyRequests { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IEmbeddingApiResponse"/>
    /// </summary>
    public interface IEmbeddingApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.EmbeddingResponse?>, IBadRequest<Org.OpenAPITools.Model.HttpValidationProblemDetails?>, ITooManyRequests<Org.OpenAPITools.Model.ProblemDetails?>, IInternalServerError<Org.OpenAPITools.Model.ProblemDetails?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 429 TooManyRequests
        /// </summary>
        /// <returns></returns>
        bool IsTooManyRequests { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IKeywordExtractionApiResponse"/>
    /// </summary>
    public interface IKeywordExtractionApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.KeywordExtractionResponse?>, IBadRequest<Org.OpenAPITools.Model.HttpValidationProblemDetails?>, ITooManyRequests<Org.OpenAPITools.Model.ProblemDetails?>, IInternalServerError<Org.OpenAPITools.Model.ProblemDetails?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 429 TooManyRequests
        /// </summary>
        /// <returns></returns>
        bool IsTooManyRequests { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="INamedEntityRecognitionApiResponse"/>
    /// </summary>
    public interface INamedEntityRecognitionApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.NamedEntityRecognitionResponse?>, IBadRequest<Org.OpenAPITools.Model.HttpValidationProblemDetails?>, ITooManyRequests<Org.OpenAPITools.Model.ProblemDetails?>, IInternalServerError<Org.OpenAPITools.Model.ProblemDetails?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 429 TooManyRequests
        /// </summary>
        /// <returns></returns>
        bool IsTooManyRequests { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="ISemanticSimilarityApiResponse"/>
    /// </summary>
    public interface ISemanticSimilarityApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.SemanticSimilarityResponse?>, IBadRequest<Org.OpenAPITools.Model.HttpValidationProblemDetails?>, ITooManyRequests<Org.OpenAPITools.Model.ProblemDetails?>, IInternalServerError<Org.OpenAPITools.Model.ProblemDetails?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 429 TooManyRequests
        /// </summary>
        /// <returns></returns>
        bool IsTooManyRequests { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="ITokenCountApiResponse"/>
    /// </summary>
    public interface ITokenCountApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.TokenCountResponse?>, IBadRequest<Org.OpenAPITools.Model.HttpValidationProblemDetails?>, ITooManyRequests<Org.OpenAPITools.Model.ProblemDetails?>, IInternalServerError<Org.OpenAPITools.Model.ProblemDetails?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 429 TooManyRequests
        /// </summary>
        /// <returns></returns>
        bool IsTooManyRequests { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="ITokenizeApiResponse"/>
    /// </summary>
    public interface ITokenizeApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.TokenizerResponse?>, IBadRequest<Org.OpenAPITools.Model.HttpValidationProblemDetails?>, ITooManyRequests<Org.OpenAPITools.Model.ProblemDetails?>, IInternalServerError<Org.OpenAPITools.Model.ProblemDetails?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 429 TooManyRequests
        /// </summary>
        /// <returns></returns>
        bool IsTooManyRequests { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="ITranscriptionSynchronousApiResponse"/>
    /// </summary>
    public interface ITranscriptionSynchronousApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.TranscriptionResponse?>, IBadRequest<Org.OpenAPITools.Model.HttpValidationProblemDetails?>, ITooManyRequests<Org.OpenAPITools.Model.ProblemDetails?>, IInternalServerError<Org.OpenAPITools.Model.ProblemDetails?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 429 TooManyRequests
        /// </summary>
        /// <returns></returns>
        bool IsTooManyRequests { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public class DataExtractionApiEvents
    {
        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnApiExtractThematicSimilarityClusterPost;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorApiExtractThematicSimilarityClusterPost;

        internal void ExecuteOnApiExtractThematicSimilarityClusterPost(DataExtractionApi.ApiExtractThematicSimilarityClusterPostApiResponse apiResponse)
        {
            OnApiExtractThematicSimilarityClusterPost?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorApiExtractThematicSimilarityClusterPost(Exception exception)
        {
            OnErrorApiExtractThematicSimilarityClusterPost?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnEmbedding;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorEmbedding;

        internal void ExecuteOnEmbedding(DataExtractionApi.EmbeddingApiResponse apiResponse)
        {
            OnEmbedding?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorEmbedding(Exception exception)
        {
            OnErrorEmbedding?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnKeywordExtraction;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorKeywordExtraction;

        internal void ExecuteOnKeywordExtraction(DataExtractionApi.KeywordExtractionApiResponse apiResponse)
        {
            OnKeywordExtraction?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorKeywordExtraction(Exception exception)
        {
            OnErrorKeywordExtraction?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnNamedEntityRecognition;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorNamedEntityRecognition;

        internal void ExecuteOnNamedEntityRecognition(DataExtractionApi.NamedEntityRecognitionApiResponse apiResponse)
        {
            OnNamedEntityRecognition?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorNamedEntityRecognition(Exception exception)
        {
            OnErrorNamedEntityRecognition?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnSemanticSimilarity;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorSemanticSimilarity;

        internal void ExecuteOnSemanticSimilarity(DataExtractionApi.SemanticSimilarityApiResponse apiResponse)
        {
            OnSemanticSimilarity?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorSemanticSimilarity(Exception exception)
        {
            OnErrorSemanticSimilarity?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnTokenCount;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorTokenCount;

        internal void ExecuteOnTokenCount(DataExtractionApi.TokenCountApiResponse apiResponse)
        {
            OnTokenCount?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorTokenCount(Exception exception)
        {
            OnErrorTokenCount?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnTokenize;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorTokenize;

        internal void ExecuteOnTokenize(DataExtractionApi.TokenizeApiResponse apiResponse)
        {
            OnTokenize?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorTokenize(Exception exception)
        {
            OnErrorTokenize?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnTranscriptionSynchronous;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorTranscriptionSynchronous;

        internal void ExecuteOnTranscriptionSynchronous(DataExtractionApi.TranscriptionSynchronousApiResponse apiResponse)
        {
            OnTranscriptionSynchronous?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorTranscriptionSynchronous(Exception exception)
        {
            OnErrorTranscriptionSynchronous?.Invoke(this, new ExceptionEventArgs(exception));
        }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public sealed partial class DataExtractionApi : IDataExtractionApi
    {
        private JsonSerializerOptions _jsonSerializerOptions;

        /// <summary>
        /// The logger factory
        /// </summary>
        public ILoggerFactory LoggerFactory { get; }

        /// <summary>
        /// The logger
        /// </summary>
        public ILogger<DataExtractionApi> Logger { get; }

        /// <summary>
        /// The HttpClient
        /// </summary>
        public HttpClient HttpClient { get; }

        /// <summary>
        /// The class containing the events
        /// </summary>
        public DataExtractionApiEvents Events { get; }

        /// <summary>
        /// Initializes a new instance of the <see cref="DataExtractionApi"/> class.
        /// </summary>
        /// <returns></returns>
        public DataExtractionApi(ILogger<DataExtractionApi> logger, ILoggerFactory loggerFactory, HttpClient httpClient, JsonSerializerOptionsProvider jsonSerializerOptionsProvider, DataExtractionApiEvents dataExtractionApiEvents)
        {
            _jsonSerializerOptions = jsonSerializerOptionsProvider.Options;
            LoggerFactory = loggerFactory;
            Logger = LoggerFactory.CreateLogger<DataExtractionApi>();
            HttpClient = httpClient;
            Events = dataExtractionApiEvents;
        }

        partial void FormatApiExtractThematicSimilarityClusterPost(ApiExtractThematicSimilarityClusterPostRequest apiExtractThematicSimilarityClusterPostRequest);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="apiExtractThematicSimilarityClusterPostRequest"></param>
        /// <returns></returns>
        private void ValidateApiExtractThematicSimilarityClusterPost(ApiExtractThematicSimilarityClusterPostRequest apiExtractThematicSimilarityClusterPostRequest)
        {
            if (apiExtractThematicSimilarityClusterPostRequest == null)
                throw new ArgumentNullException(nameof(apiExtractThematicSimilarityClusterPostRequest));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="apiExtractThematicSimilarityClusterPostRequest"></param>
        private void AfterApiExtractThematicSimilarityClusterPostDefaultImplementation(IApiExtractThematicSimilarityClusterPostApiResponse apiResponseLocalVar, ApiExtractThematicSimilarityClusterPostRequest apiExtractThematicSimilarityClusterPostRequest)
        {
            bool suppressDefaultLog = false;
            AfterApiExtractThematicSimilarityClusterPost(ref suppressDefaultLog, apiResponseLocalVar, apiExtractThematicSimilarityClusterPostRequest);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="apiExtractThematicSimilarityClusterPostRequest"></param>
        partial void AfterApiExtractThematicSimilarityClusterPost(ref bool suppressDefaultLog, IApiExtractThematicSimilarityClusterPostApiResponse apiResponseLocalVar, ApiExtractThematicSimilarityClusterPostRequest apiExtractThematicSimilarityClusterPostRequest);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="apiExtractThematicSimilarityClusterPostRequest"></param>
        private void OnErrorApiExtractThematicSimilarityClusterPostDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, ApiExtractThematicSimilarityClusterPostRequest apiExtractThematicSimilarityClusterPostRequest)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorApiExtractThematicSimilarityClusterPost(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, apiExtractThematicSimilarityClusterPostRequest);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="apiExtractThematicSimilarityClusterPostRequest"></param>
        partial void OnErrorApiExtractThematicSimilarityClusterPost(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, ApiExtractThematicSimilarityClusterPostRequest apiExtractThematicSimilarityClusterPostRequest);

        /// <summary>
        /// Generate thematic similarity clusters using the K-Means algorithm 
        /// </summary>
        /// <param name="apiExtractThematicSimilarityClusterPostRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IApiExtractThematicSimilarityClusterPostApiResponse"/>&gt;</returns>
        public async Task<IApiExtractThematicSimilarityClusterPostApiResponse?> ApiExtractThematicSimilarityClusterPostOrDefaultAsync(ApiExtractThematicSimilarityClusterPostRequest apiExtractThematicSimilarityClusterPostRequest, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await ApiExtractThematicSimilarityClusterPostAsync(apiExtractThematicSimilarityClusterPostRequest, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Generate thematic similarity clusters using the K-Means algorithm 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="apiExtractThematicSimilarityClusterPostRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IApiExtractThematicSimilarityClusterPostApiResponse"/>&gt;</returns>
        public async Task<IApiExtractThematicSimilarityClusterPostApiResponse> ApiExtractThematicSimilarityClusterPostAsync(ApiExtractThematicSimilarityClusterPostRequest apiExtractThematicSimilarityClusterPostRequest, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateApiExtractThematicSimilarityClusterPost(apiExtractThematicSimilarityClusterPostRequest);

                FormatApiExtractThematicSimilarityClusterPost(apiExtractThematicSimilarityClusterPostRequest);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/api/extract/thematic-similarity-cluster";

                    httpRequestMessageLocalVar.Content = (apiExtractThematicSimilarityClusterPostRequest as object) is System.IO.Stream stream
                        ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                        : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(apiExtractThematicSimilarityClusterPostRequest, _jsonSerializerOptions));

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json",
                        "text/csv",
                        "application/problem+json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<ApiExtractThematicSimilarityClusterPostApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<ApiExtractThematicSimilarityClusterPostApiResponse>();

                        ApiExtractThematicSimilarityClusterPostApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/extract/thematic-similarity-cluster", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterApiExtractThematicSimilarityClusterPostDefaultImplementation(apiResponseLocalVar, apiExtractThematicSimilarityClusterPostRequest);

                        Events.ExecuteOnApiExtractThematicSimilarityClusterPost(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorApiExtractThematicSimilarityClusterPostDefaultImplementation(e, "/api/extract/thematic-similarity-cluster", uriBuilderLocalVar.Path, apiExtractThematicSimilarityClusterPostRequest);
                Events.ExecuteOnErrorApiExtractThematicSimilarityClusterPost(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="ApiExtractThematicSimilarityClusterPostApiResponse"/>
        /// </summary>
        public partial class ApiExtractThematicSimilarityClusterPostApiResponse : Org.OpenAPITools.Client.ApiResponse, IApiExtractThematicSimilarityClusterPostApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<ApiExtractThematicSimilarityClusterPostApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="ApiExtractThematicSimilarityClusterPostApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ApiExtractThematicSimilarityClusterPostApiResponse(ILogger<ApiExtractThematicSimilarityClusterPostApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.KMeansCluster? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.KMeansCluster>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.KMeansCluster? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.HttpValidationProblemDetails? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.HttpValidationProblemDetails>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out Org.OpenAPITools.Model.HttpValidationProblemDetails? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 429 TooManyRequests
            /// </summary>
            /// <returns></returns>
            public bool IsTooManyRequests => 429 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 429 TooManyRequests
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.ProblemDetails? TooManyRequests()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsTooManyRequests
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.ProblemDetails>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 429 TooManyRequests and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryTooManyRequests([NotNullWhen(true)]out Org.OpenAPITools.Model.ProblemDetails? result)
            {
                result = null;

                try
                {
                    result = TooManyRequests();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)429);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.ProblemDetails? InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.ProblemDetails>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out Org.OpenAPITools.Model.ProblemDetails? result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatEmbedding(EmbeddingRequest embeddingRequest);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="embeddingRequest"></param>
        /// <returns></returns>
        private void ValidateEmbedding(EmbeddingRequest embeddingRequest)
        {
            if (embeddingRequest == null)
                throw new ArgumentNullException(nameof(embeddingRequest));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="embeddingRequest"></param>
        private void AfterEmbeddingDefaultImplementation(IEmbeddingApiResponse apiResponseLocalVar, EmbeddingRequest embeddingRequest)
        {
            bool suppressDefaultLog = false;
            AfterEmbedding(ref suppressDefaultLog, apiResponseLocalVar, embeddingRequest);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="embeddingRequest"></param>
        partial void AfterEmbedding(ref bool suppressDefaultLog, IEmbeddingApiResponse apiResponseLocalVar, EmbeddingRequest embeddingRequest);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="embeddingRequest"></param>
        private void OnErrorEmbeddingDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, EmbeddingRequest embeddingRequest)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorEmbedding(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, embeddingRequest);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="embeddingRequest"></param>
        partial void OnErrorEmbedding(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, EmbeddingRequest embeddingRequest);

        /// <summary>
        /// Converts data to a numerical vector array The embedding endpoint is a sophisticated API designed for transforming textual data into high-dimensional vectors, facilitating a wide array of natural language processing (NLP) tasks. This transformation process encodes the semantic properties and contextual meanings of the input text into a vector space, enabling machines to understand and process language in a manner analogous to human comprehension.  ## Core Features:  * Semantic Encoding: Leverages advanced machine learning models, particularly those based on transformer architectures, to capture the deep semantic and syntactic nuances of the input text. This ensures that similar words and phrases are positioned closely in the vector space, reflecting their semantic proximity. * High-Dimensional Representation: Transforms texts into vectors in a high-dimensional space, typically ranging from hundreds to thousands of dimensions. This rich representation captures a comprehensive spectrum of linguistic features and relationships. * Scalability: Engineered to handle a wide range of text sizes, from short tweets to extensive documents, without compromising on the accuracy of the vector representations.
        /// </summary>
        /// <param name="embeddingRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IEmbeddingApiResponse"/>&gt;</returns>
        public async Task<IEmbeddingApiResponse?> EmbeddingOrDefaultAsync(EmbeddingRequest embeddingRequest, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await EmbeddingAsync(embeddingRequest, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Converts data to a numerical vector array The embedding endpoint is a sophisticated API designed for transforming textual data into high-dimensional vectors, facilitating a wide array of natural language processing (NLP) tasks. This transformation process encodes the semantic properties and contextual meanings of the input text into a vector space, enabling machines to understand and process language in a manner analogous to human comprehension.  ## Core Features:  * Semantic Encoding: Leverages advanced machine learning models, particularly those based on transformer architectures, to capture the deep semantic and syntactic nuances of the input text. This ensures that similar words and phrases are positioned closely in the vector space, reflecting their semantic proximity. * High-Dimensional Representation: Transforms texts into vectors in a high-dimensional space, typically ranging from hundreds to thousands of dimensions. This rich representation captures a comprehensive spectrum of linguistic features and relationships. * Scalability: Engineered to handle a wide range of text sizes, from short tweets to extensive documents, without compromising on the accuracy of the vector representations.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="embeddingRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IEmbeddingApiResponse"/>&gt;</returns>
        public async Task<IEmbeddingApiResponse> EmbeddingAsync(EmbeddingRequest embeddingRequest, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateEmbedding(embeddingRequest);

                FormatEmbedding(embeddingRequest);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/api/extract/embed";

                    httpRequestMessageLocalVar.Content = (embeddingRequest as object) is System.IO.Stream stream
                        ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                        : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(embeddingRequest, _jsonSerializerOptions));

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json",
                        "application/problem+json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<EmbeddingApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<EmbeddingApiResponse>();

                        EmbeddingApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/extract/embed", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterEmbeddingDefaultImplementation(apiResponseLocalVar, embeddingRequest);

                        Events.ExecuteOnEmbedding(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorEmbeddingDefaultImplementation(e, "/api/extract/embed", uriBuilderLocalVar.Path, embeddingRequest);
                Events.ExecuteOnErrorEmbedding(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="EmbeddingApiResponse"/>
        /// </summary>
        public partial class EmbeddingApiResponse : Org.OpenAPITools.Client.ApiResponse, IEmbeddingApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<EmbeddingApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="EmbeddingApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public EmbeddingApiResponse(ILogger<EmbeddingApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.EmbeddingResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.EmbeddingResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.EmbeddingResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.HttpValidationProblemDetails? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.HttpValidationProblemDetails>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out Org.OpenAPITools.Model.HttpValidationProblemDetails? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 429 TooManyRequests
            /// </summary>
            /// <returns></returns>
            public bool IsTooManyRequests => 429 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 429 TooManyRequests
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.ProblemDetails? TooManyRequests()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsTooManyRequests
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.ProblemDetails>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 429 TooManyRequests and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryTooManyRequests([NotNullWhen(true)]out Org.OpenAPITools.Model.ProblemDetails? result)
            {
                result = null;

                try
                {
                    result = TooManyRequests();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)429);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.ProblemDetails? InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.ProblemDetails>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out Org.OpenAPITools.Model.ProblemDetails? result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatKeywordExtraction(KeywordExtractionRequestBody keywordExtractionRequestBody);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="keywordExtractionRequestBody"></param>
        /// <returns></returns>
        private void ValidateKeywordExtraction(KeywordExtractionRequestBody keywordExtractionRequestBody)
        {
            if (keywordExtractionRequestBody == null)
                throw new ArgumentNullException(nameof(keywordExtractionRequestBody));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="keywordExtractionRequestBody"></param>
        private void AfterKeywordExtractionDefaultImplementation(IKeywordExtractionApiResponse apiResponseLocalVar, KeywordExtractionRequestBody keywordExtractionRequestBody)
        {
            bool suppressDefaultLog = false;
            AfterKeywordExtraction(ref suppressDefaultLog, apiResponseLocalVar, keywordExtractionRequestBody);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="keywordExtractionRequestBody"></param>
        partial void AfterKeywordExtraction(ref bool suppressDefaultLog, IKeywordExtractionApiResponse apiResponseLocalVar, KeywordExtractionRequestBody keywordExtractionRequestBody);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="keywordExtractionRequestBody"></param>
        private void OnErrorKeywordExtractionDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, KeywordExtractionRequestBody keywordExtractionRequestBody)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorKeywordExtraction(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, keywordExtractionRequestBody);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="keywordExtractionRequestBody"></param>
        partial void OnErrorKeywordExtraction(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, KeywordExtractionRequestBody keywordExtractionRequestBody);

        /// <summary>
        /// Performs keyword extraction on source text This endpoint accepts a string of text and returns a list of key words or phrases that best describe the content of the text. This can be used for tagging, summarizing, indexing, or categorizing content.
        /// </summary>
        /// <param name="keywordExtractionRequestBody"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IKeywordExtractionApiResponse"/>&gt;</returns>
        public async Task<IKeywordExtractionApiResponse?> KeywordExtractionOrDefaultAsync(KeywordExtractionRequestBody keywordExtractionRequestBody, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await KeywordExtractionAsync(keywordExtractionRequestBody, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Performs keyword extraction on source text This endpoint accepts a string of text and returns a list of key words or phrases that best describe the content of the text. This can be used for tagging, summarizing, indexing, or categorizing content.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="keywordExtractionRequestBody"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IKeywordExtractionApiResponse"/>&gt;</returns>
        public async Task<IKeywordExtractionApiResponse> KeywordExtractionAsync(KeywordExtractionRequestBody keywordExtractionRequestBody, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateKeywordExtraction(keywordExtractionRequestBody);

                FormatKeywordExtraction(keywordExtractionRequestBody);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/api/extract/keywords";

                    httpRequestMessageLocalVar.Content = (keywordExtractionRequestBody as object) is System.IO.Stream stream
                        ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                        : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(keywordExtractionRequestBody, _jsonSerializerOptions));

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json",
                        "application/problem+json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<KeywordExtractionApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<KeywordExtractionApiResponse>();

                        KeywordExtractionApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/extract/keywords", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterKeywordExtractionDefaultImplementation(apiResponseLocalVar, keywordExtractionRequestBody);

                        Events.ExecuteOnKeywordExtraction(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorKeywordExtractionDefaultImplementation(e, "/api/extract/keywords", uriBuilderLocalVar.Path, keywordExtractionRequestBody);
                Events.ExecuteOnErrorKeywordExtraction(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="KeywordExtractionApiResponse"/>
        /// </summary>
        public partial class KeywordExtractionApiResponse : Org.OpenAPITools.Client.ApiResponse, IKeywordExtractionApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<KeywordExtractionApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="KeywordExtractionApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public KeywordExtractionApiResponse(ILogger<KeywordExtractionApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.KeywordExtractionResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.KeywordExtractionResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.KeywordExtractionResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.HttpValidationProblemDetails? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.HttpValidationProblemDetails>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out Org.OpenAPITools.Model.HttpValidationProblemDetails? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 429 TooManyRequests
            /// </summary>
            /// <returns></returns>
            public bool IsTooManyRequests => 429 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 429 TooManyRequests
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.ProblemDetails? TooManyRequests()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsTooManyRequests
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.ProblemDetails>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 429 TooManyRequests and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryTooManyRequests([NotNullWhen(true)]out Org.OpenAPITools.Model.ProblemDetails? result)
            {
                result = null;

                try
                {
                    result = TooManyRequests();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)429);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.ProblemDetails? InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.ProblemDetails>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out Org.OpenAPITools.Model.ProblemDetails? result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatNamedEntityRecognition(NamedEntityRecognitionRequest namedEntityRecognitionRequest);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="namedEntityRecognitionRequest"></param>
        /// <returns></returns>
        private void ValidateNamedEntityRecognition(NamedEntityRecognitionRequest namedEntityRecognitionRequest)
        {
            if (namedEntityRecognitionRequest == null)
                throw new ArgumentNullException(nameof(namedEntityRecognitionRequest));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="namedEntityRecognitionRequest"></param>
        private void AfterNamedEntityRecognitionDefaultImplementation(INamedEntityRecognitionApiResponse apiResponseLocalVar, NamedEntityRecognitionRequest namedEntityRecognitionRequest)
        {
            bool suppressDefaultLog = false;
            AfterNamedEntityRecognition(ref suppressDefaultLog, apiResponseLocalVar, namedEntityRecognitionRequest);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="namedEntityRecognitionRequest"></param>
        partial void AfterNamedEntityRecognition(ref bool suppressDefaultLog, INamedEntityRecognitionApiResponse apiResponseLocalVar, NamedEntityRecognitionRequest namedEntityRecognitionRequest);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="namedEntityRecognitionRequest"></param>
        private void OnErrorNamedEntityRecognitionDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, NamedEntityRecognitionRequest namedEntityRecognitionRequest)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorNamedEntityRecognition(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, namedEntityRecognitionRequest);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="namedEntityRecognitionRequest"></param>
        partial void OnErrorNamedEntityRecognition(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, NamedEntityRecognitionRequest namedEntityRecognitionRequest);

        /// <summary>
        /// Extracts named entities from provided text This endpoint accepts a string of text and returns a list of identified entities classified into categories such as email, location, organisation, etc.
        /// </summary>
        /// <param name="namedEntityRecognitionRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="INamedEntityRecognitionApiResponse"/>&gt;</returns>
        public async Task<INamedEntityRecognitionApiResponse?> NamedEntityRecognitionOrDefaultAsync(NamedEntityRecognitionRequest namedEntityRecognitionRequest, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await NamedEntityRecognitionAsync(namedEntityRecognitionRequest, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Extracts named entities from provided text This endpoint accepts a string of text and returns a list of identified entities classified into categories such as email, location, organisation, etc.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="namedEntityRecognitionRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="INamedEntityRecognitionApiResponse"/>&gt;</returns>
        public async Task<INamedEntityRecognitionApiResponse> NamedEntityRecognitionAsync(NamedEntityRecognitionRequest namedEntityRecognitionRequest, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateNamedEntityRecognition(namedEntityRecognitionRequest);

                FormatNamedEntityRecognition(namedEntityRecognitionRequest);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/api/extract/entities";

                    httpRequestMessageLocalVar.Content = (namedEntityRecognitionRequest as object) is System.IO.Stream stream
                        ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                        : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(namedEntityRecognitionRequest, _jsonSerializerOptions));

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json",
                        "application/problem+json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<NamedEntityRecognitionApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<NamedEntityRecognitionApiResponse>();

                        NamedEntityRecognitionApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/extract/entities", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterNamedEntityRecognitionDefaultImplementation(apiResponseLocalVar, namedEntityRecognitionRequest);

                        Events.ExecuteOnNamedEntityRecognition(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorNamedEntityRecognitionDefaultImplementation(e, "/api/extract/entities", uriBuilderLocalVar.Path, namedEntityRecognitionRequest);
                Events.ExecuteOnErrorNamedEntityRecognition(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="NamedEntityRecognitionApiResponse"/>
        /// </summary>
        public partial class NamedEntityRecognitionApiResponse : Org.OpenAPITools.Client.ApiResponse, INamedEntityRecognitionApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<NamedEntityRecognitionApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="NamedEntityRecognitionApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public NamedEntityRecognitionApiResponse(ILogger<NamedEntityRecognitionApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.NamedEntityRecognitionResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.NamedEntityRecognitionResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.NamedEntityRecognitionResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.HttpValidationProblemDetails? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.HttpValidationProblemDetails>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out Org.OpenAPITools.Model.HttpValidationProblemDetails? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 429 TooManyRequests
            /// </summary>
            /// <returns></returns>
            public bool IsTooManyRequests => 429 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 429 TooManyRequests
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.ProblemDetails? TooManyRequests()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsTooManyRequests
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.ProblemDetails>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 429 TooManyRequests and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryTooManyRequests([NotNullWhen(true)]out Org.OpenAPITools.Model.ProblemDetails? result)
            {
                result = null;

                try
                {
                    result = TooManyRequests();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)429);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.ProblemDetails? InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.ProblemDetails>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out Org.OpenAPITools.Model.ProblemDetails? result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatSemanticSimilarity(SemanticSimilarityRequest semanticSimilarityRequest);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="semanticSimilarityRequest"></param>
        /// <returns></returns>
        private void ValidateSemanticSimilarity(SemanticSimilarityRequest semanticSimilarityRequest)
        {
            if (semanticSimilarityRequest == null)
                throw new ArgumentNullException(nameof(semanticSimilarityRequest));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="semanticSimilarityRequest"></param>
        private void AfterSemanticSimilarityDefaultImplementation(ISemanticSimilarityApiResponse apiResponseLocalVar, SemanticSimilarityRequest semanticSimilarityRequest)
        {
            bool suppressDefaultLog = false;
            AfterSemanticSimilarity(ref suppressDefaultLog, apiResponseLocalVar, semanticSimilarityRequest);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="semanticSimilarityRequest"></param>
        partial void AfterSemanticSimilarity(ref bool suppressDefaultLog, ISemanticSimilarityApiResponse apiResponseLocalVar, SemanticSimilarityRequest semanticSimilarityRequest);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="semanticSimilarityRequest"></param>
        private void OnErrorSemanticSimilarityDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, SemanticSimilarityRequest semanticSimilarityRequest)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorSemanticSimilarity(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, semanticSimilarityRequest);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="semanticSimilarityRequest"></param>
        partial void OnErrorSemanticSimilarity(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, SemanticSimilarityRequest semanticSimilarityRequest);

        /// <summary>
        /// Generate semantic similarity queries from text Upon receiving a user-defined query and a set of texts, the endpoint processes this information through its semantic analysis engine. This engine leverages state-of-the-art machine learning models, such as transformer-based architectures, to encode the texts and the query into high-dimensional vectors. By operating in this semantic space, it can accurately measure the distances between the query vector and each of the text vectors, reflecting how closely the meanings align.  Use Cases:  * Content Discovery: Helps users find articles, posts, or documents that are most relevant to their query.  * Customer Support: Automatically matches customer queries to the most relevant FAQs or support documents.  * Research and Study: Assists researchers in quickly finding academic papers or resources that are closely related to their field of inquiry.  By utilizing the semantic similarity endpoint, organizations and individuals can greatly enhance the efficiency and effectiveness of their information retrieval processes, ensuring that users are connected with the content most pertinent to their needs.
        /// </summary>
        /// <param name="semanticSimilarityRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISemanticSimilarityApiResponse"/>&gt;</returns>
        public async Task<ISemanticSimilarityApiResponse?> SemanticSimilarityOrDefaultAsync(SemanticSimilarityRequest semanticSimilarityRequest, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await SemanticSimilarityAsync(semanticSimilarityRequest, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Generate semantic similarity queries from text Upon receiving a user-defined query and a set of texts, the endpoint processes this information through its semantic analysis engine. This engine leverages state-of-the-art machine learning models, such as transformer-based architectures, to encode the texts and the query into high-dimensional vectors. By operating in this semantic space, it can accurately measure the distances between the query vector and each of the text vectors, reflecting how closely the meanings align.  Use Cases:  * Content Discovery: Helps users find articles, posts, or documents that are most relevant to their query.  * Customer Support: Automatically matches customer queries to the most relevant FAQs or support documents.  * Research and Study: Assists researchers in quickly finding academic papers or resources that are closely related to their field of inquiry.  By utilizing the semantic similarity endpoint, organizations and individuals can greatly enhance the efficiency and effectiveness of their information retrieval processes, ensuring that users are connected with the content most pertinent to their needs.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="semanticSimilarityRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISemanticSimilarityApiResponse"/>&gt;</returns>
        public async Task<ISemanticSimilarityApiResponse> SemanticSimilarityAsync(SemanticSimilarityRequest semanticSimilarityRequest, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateSemanticSimilarity(semanticSimilarityRequest);

                FormatSemanticSimilarity(semanticSimilarityRequest);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/api/extract/similarity";

                    httpRequestMessageLocalVar.Content = (semanticSimilarityRequest as object) is System.IO.Stream stream
                        ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                        : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(semanticSimilarityRequest, _jsonSerializerOptions));

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json",
                        "application/problem+json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<SemanticSimilarityApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<SemanticSimilarityApiResponse>();

                        SemanticSimilarityApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/extract/similarity", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterSemanticSimilarityDefaultImplementation(apiResponseLocalVar, semanticSimilarityRequest);

                        Events.ExecuteOnSemanticSimilarity(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorSemanticSimilarityDefaultImplementation(e, "/api/extract/similarity", uriBuilderLocalVar.Path, semanticSimilarityRequest);
                Events.ExecuteOnErrorSemanticSimilarity(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="SemanticSimilarityApiResponse"/>
        /// </summary>
        public partial class SemanticSimilarityApiResponse : Org.OpenAPITools.Client.ApiResponse, ISemanticSimilarityApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<SemanticSimilarityApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="SemanticSimilarityApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public SemanticSimilarityApiResponse(ILogger<SemanticSimilarityApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.SemanticSimilarityResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.SemanticSimilarityResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.SemanticSimilarityResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.HttpValidationProblemDetails? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.HttpValidationProblemDetails>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out Org.OpenAPITools.Model.HttpValidationProblemDetails? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 429 TooManyRequests
            /// </summary>
            /// <returns></returns>
            public bool IsTooManyRequests => 429 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 429 TooManyRequests
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.ProblemDetails? TooManyRequests()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsTooManyRequests
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.ProblemDetails>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 429 TooManyRequests and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryTooManyRequests([NotNullWhen(true)]out Org.OpenAPITools.Model.ProblemDetails? result)
            {
                result = null;

                try
                {
                    result = TooManyRequests();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)429);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.ProblemDetails? InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.ProblemDetails>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out Org.OpenAPITools.Model.ProblemDetails? result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatTokenCount(TokenCountRequest tokenCountRequest);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="tokenCountRequest"></param>
        /// <returns></returns>
        private void ValidateTokenCount(TokenCountRequest tokenCountRequest)
        {
            if (tokenCountRequest == null)
                throw new ArgumentNullException(nameof(tokenCountRequest));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="tokenCountRequest"></param>
        private void AfterTokenCountDefaultImplementation(ITokenCountApiResponse apiResponseLocalVar, TokenCountRequest tokenCountRequest)
        {
            bool suppressDefaultLog = false;
            AfterTokenCount(ref suppressDefaultLog, apiResponseLocalVar, tokenCountRequest);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="tokenCountRequest"></param>
        partial void AfterTokenCount(ref bool suppressDefaultLog, ITokenCountApiResponse apiResponseLocalVar, TokenCountRequest tokenCountRequest);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="tokenCountRequest"></param>
        private void OnErrorTokenCountDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, TokenCountRequest tokenCountRequest)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorTokenCount(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, tokenCountRequest);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="tokenCountRequest"></param>
        partial void OnErrorTokenCount(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, TokenCountRequest tokenCountRequest);

        /// <summary>
        /// Count tokens in a text The tokenCount endpoint designed for counting tokens in text data.
        /// </summary>
        /// <param name="tokenCountRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ITokenCountApiResponse"/>&gt;</returns>
        public async Task<ITokenCountApiResponse?> TokenCountOrDefaultAsync(TokenCountRequest tokenCountRequest, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await TokenCountAsync(tokenCountRequest, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Count tokens in a text The tokenCount endpoint designed for counting tokens in text data.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenCountRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ITokenCountApiResponse"/>&gt;</returns>
        public async Task<ITokenCountApiResponse> TokenCountAsync(TokenCountRequest tokenCountRequest, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateTokenCount(tokenCountRequest);

                FormatTokenCount(tokenCountRequest);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/api/extract/tokenCount";

                    httpRequestMessageLocalVar.Content = (tokenCountRequest as object) is System.IO.Stream stream
                        ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                        : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(tokenCountRequest, _jsonSerializerOptions));

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json",
                        "application/problem+json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<TokenCountApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<TokenCountApiResponse>();

                        TokenCountApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/extract/tokenCount", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterTokenCountDefaultImplementation(apiResponseLocalVar, tokenCountRequest);

                        Events.ExecuteOnTokenCount(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorTokenCountDefaultImplementation(e, "/api/extract/tokenCount", uriBuilderLocalVar.Path, tokenCountRequest);
                Events.ExecuteOnErrorTokenCount(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="TokenCountApiResponse"/>
        /// </summary>
        public partial class TokenCountApiResponse : Org.OpenAPITools.Client.ApiResponse, ITokenCountApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<TokenCountApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="TokenCountApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public TokenCountApiResponse(ILogger<TokenCountApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.TokenCountResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.TokenCountResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.TokenCountResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.HttpValidationProblemDetails? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.HttpValidationProblemDetails>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out Org.OpenAPITools.Model.HttpValidationProblemDetails? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 429 TooManyRequests
            /// </summary>
            /// <returns></returns>
            public bool IsTooManyRequests => 429 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 429 TooManyRequests
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.ProblemDetails? TooManyRequests()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsTooManyRequests
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.ProblemDetails>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 429 TooManyRequests and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryTooManyRequests([NotNullWhen(true)]out Org.OpenAPITools.Model.ProblemDetails? result)
            {
                result = null;

                try
                {
                    result = TooManyRequests();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)429);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.ProblemDetails? InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.ProblemDetails>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out Org.OpenAPITools.Model.ProblemDetails? result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatTokenize(TokenizerRequest tokenizerRequest);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="tokenizerRequest"></param>
        /// <returns></returns>
        private void ValidateTokenize(TokenizerRequest tokenizerRequest)
        {
            if (tokenizerRequest == null)
                throw new ArgumentNullException(nameof(tokenizerRequest));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="tokenizerRequest"></param>
        private void AfterTokenizeDefaultImplementation(ITokenizeApiResponse apiResponseLocalVar, TokenizerRequest tokenizerRequest)
        {
            bool suppressDefaultLog = false;
            AfterTokenize(ref suppressDefaultLog, apiResponseLocalVar, tokenizerRequest);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="tokenizerRequest"></param>
        partial void AfterTokenize(ref bool suppressDefaultLog, ITokenizeApiResponse apiResponseLocalVar, TokenizerRequest tokenizerRequest);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="tokenizerRequest"></param>
        private void OnErrorTokenizeDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, TokenizerRequest tokenizerRequest)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorTokenize(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, tokenizerRequest);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="tokenizerRequest"></param>
        partial void OnErrorTokenize(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, TokenizerRequest tokenizerRequest);

        /// <summary>
        /// Converts data to a integer token array The tokenizer endpoint designed for transforming textual data into integer tokens.
        /// </summary>
        /// <param name="tokenizerRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ITokenizeApiResponse"/>&gt;</returns>
        public async Task<ITokenizeApiResponse?> TokenizeOrDefaultAsync(TokenizerRequest tokenizerRequest, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await TokenizeAsync(tokenizerRequest, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Converts data to a integer token array The tokenizer endpoint designed for transforming textual data into integer tokens.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenizerRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ITokenizeApiResponse"/>&gt;</returns>
        public async Task<ITokenizeApiResponse> TokenizeAsync(TokenizerRequest tokenizerRequest, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateTokenize(tokenizerRequest);

                FormatTokenize(tokenizerRequest);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/api/extract/tokenize";

                    httpRequestMessageLocalVar.Content = (tokenizerRequest as object) is System.IO.Stream stream
                        ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                        : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(tokenizerRequest, _jsonSerializerOptions));

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json",
                        "application/problem+json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<TokenizeApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<TokenizeApiResponse>();

                        TokenizeApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/extract/tokenize", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterTokenizeDefaultImplementation(apiResponseLocalVar, tokenizerRequest);

                        Events.ExecuteOnTokenize(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorTokenizeDefaultImplementation(e, "/api/extract/tokenize", uriBuilderLocalVar.Path, tokenizerRequest);
                Events.ExecuteOnErrorTokenize(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="TokenizeApiResponse"/>
        /// </summary>
        public partial class TokenizeApiResponse : Org.OpenAPITools.Client.ApiResponse, ITokenizeApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<TokenizeApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="TokenizeApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public TokenizeApiResponse(ILogger<TokenizeApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.TokenizerResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.TokenizerResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.TokenizerResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.HttpValidationProblemDetails? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.HttpValidationProblemDetails>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out Org.OpenAPITools.Model.HttpValidationProblemDetails? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 429 TooManyRequests
            /// </summary>
            /// <returns></returns>
            public bool IsTooManyRequests => 429 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 429 TooManyRequests
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.ProblemDetails? TooManyRequests()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsTooManyRequests
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.ProblemDetails>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 429 TooManyRequests and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryTooManyRequests([NotNullWhen(true)]out Org.OpenAPITools.Model.ProblemDetails? result)
            {
                result = null;

                try
                {
                    result = TooManyRequests();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)429);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.ProblemDetails? InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.ProblemDetails>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out Org.OpenAPITools.Model.ProblemDetails? result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatTranscriptionSynchronous(List<System.IO.Stream> files, ref Option<string> model, ref Option<string> language, ref Option<string> prompt, ref Option<double> temperature, ref Option<bool> splitOnWord, ref Option<bool> languageDetection, ref Option<bool> enableNoiseReduction);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="files"></param>
        /// <param name="model"></param>
        /// <param name="language"></param>
        /// <param name="prompt"></param>
        /// <returns></returns>
        private void ValidateTranscriptionSynchronous(List<System.IO.Stream> files, Option<string> model, Option<string> language, Option<string> prompt)
        {
            if (files == null)
                throw new ArgumentNullException(nameof(files));

            if (model.IsSet && model.Value == null)
                throw new ArgumentNullException(nameof(model));

            if (language.IsSet && language.Value == null)
                throw new ArgumentNullException(nameof(language));

            if (prompt.IsSet && prompt.Value == null)
                throw new ArgumentNullException(nameof(prompt));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="files"></param>
        /// <param name="model"></param>
        /// <param name="language"></param>
        /// <param name="prompt"></param>
        /// <param name="temperature"></param>
        /// <param name="splitOnWord"></param>
        /// <param name="languageDetection"></param>
        /// <param name="enableNoiseReduction"></param>
        private void AfterTranscriptionSynchronousDefaultImplementation(ITranscriptionSynchronousApiResponse apiResponseLocalVar, List<System.IO.Stream> files, Option<string> model, Option<string> language, Option<string> prompt, Option<double> temperature, Option<bool> splitOnWord, Option<bool> languageDetection, Option<bool> enableNoiseReduction)
        {
            bool suppressDefaultLog = false;
            AfterTranscriptionSynchronous(ref suppressDefaultLog, apiResponseLocalVar, files, model, language, prompt, temperature, splitOnWord, languageDetection, enableNoiseReduction);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="files"></param>
        /// <param name="model"></param>
        /// <param name="language"></param>
        /// <param name="prompt"></param>
        /// <param name="temperature"></param>
        /// <param name="splitOnWord"></param>
        /// <param name="languageDetection"></param>
        /// <param name="enableNoiseReduction"></param>
        partial void AfterTranscriptionSynchronous(ref bool suppressDefaultLog, ITranscriptionSynchronousApiResponse apiResponseLocalVar, List<System.IO.Stream> files, Option<string> model, Option<string> language, Option<string> prompt, Option<double> temperature, Option<bool> splitOnWord, Option<bool> languageDetection, Option<bool> enableNoiseReduction);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="files"></param>
        /// <param name="model"></param>
        /// <param name="language"></param>
        /// <param name="prompt"></param>
        /// <param name="temperature"></param>
        /// <param name="splitOnWord"></param>
        /// <param name="languageDetection"></param>
        /// <param name="enableNoiseReduction"></param>
        private void OnErrorTranscriptionSynchronousDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, List<System.IO.Stream> files, Option<string> model, Option<string> language, Option<string> prompt, Option<double> temperature, Option<bool> splitOnWord, Option<bool> languageDetection, Option<bool> enableNoiseReduction)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorTranscriptionSynchronous(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, files, model, language, prompt, temperature, splitOnWord, languageDetection, enableNoiseReduction);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="files"></param>
        /// <param name="model"></param>
        /// <param name="language"></param>
        /// <param name="prompt"></param>
        /// <param name="temperature"></param>
        /// <param name="splitOnWord"></param>
        /// <param name="languageDetection"></param>
        /// <param name="enableNoiseReduction"></param>
        partial void OnErrorTranscriptionSynchronous(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, List<System.IO.Stream> files, Option<string> model, Option<string> language, Option<string> prompt, Option<double> temperature, Option<bool> splitOnWord, Option<bool> languageDetection, Option<bool> enableNoiseReduction);

        /// <summary>
        /// Synchronous transcribe audio The audio transcription endpoint is a specialized web service designed to convert spoken words from audio or video files into written text. This technology relies on advanced speech recognition algorithms to accurately transcribe the content of audio or video recordings. The endpoint typically accepts files in various formats, such as MP3, WAV for audio, and MP4, AVI for video, among others. Users can upload their files directly to the service, which then processes the audio track to extract the spoken words.  The transcription process involves several steps, including noise reduction to improve audio clarity, speaker diarization to identify and differentiate between different speakers, and the actual speech-to-text conversion. The result is a detailed transcript that captures the spoken content, often including timestamps and speaker labels for easy reference.  This service is particularly useful for journalists, researchers, podcasters, and professionals who need to convert meetings, interviews, lectures, or presentations into written form for analysis, sharing, or archival purposes. The endpoint may offer additional features like language detection, support for multiple languages, and customization options to improve transcription accuracy based on specific vocabulary or industry terms.  To use the audio transcription endpoint, developers typically integrate it into applications via API calls. These calls specify the file to be transcribed and any additional parameters required by the service, such as language preference.   Upon completion, the service returns the transcription in a JSON text format, which can then be displayed, stored, or further processed according to the user&#39;s needs.
        /// </summary>
        /// <param name="files">The file object to ingest.</param>
        /// <param name="model">Model to use for transcription (Optional, default &#x3D; Base) (optional)</param>
        /// <param name="language">The language of the input audio. Supplying the input language in [ISO-639-1](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) format will improve accuracy and latency.  (optional) (optional)</param>
        /// <param name="prompt">An optional text to guide the model&#39;s style or continue a previous audio segment. The prompt should match the audio language.  (optional) (optional)</param>
        /// <param name="temperature">The sampling temperature, between 0 and 1. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. If set to 0, the model will use [log probability](https://en.wikipedia.org/wiki/Log_probability) to automatically increase the temperature until certain thresholds are hit.  (optional, default to 0M) (optional, default to 0D)</param>
        /// <param name="splitOnWord">Split into word segments. (optional, default is false) (optional, default to false)</param>
        /// <param name="languageDetection">Enable transcription language detection (Optional. default is false) (optional, default to false)</param>
        /// <param name="enableNoiseReduction">Enable noise reduction from audio stream before transcription (Optional. default is false) (optional, default to false)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ITranscriptionSynchronousApiResponse"/>&gt;</returns>
        public async Task<ITranscriptionSynchronousApiResponse?> TranscriptionSynchronousOrDefaultAsync(List<System.IO.Stream> files, Option<string> model = default, Option<string> language = default, Option<string> prompt = default, Option<double> temperature = default, Option<bool> splitOnWord = default, Option<bool> languageDetection = default, Option<bool> enableNoiseReduction = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await TranscriptionSynchronousAsync(files, model, language, prompt, temperature, splitOnWord, languageDetection, enableNoiseReduction, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Synchronous transcribe audio The audio transcription endpoint is a specialized web service designed to convert spoken words from audio or video files into written text. This technology relies on advanced speech recognition algorithms to accurately transcribe the content of audio or video recordings. The endpoint typically accepts files in various formats, such as MP3, WAV for audio, and MP4, AVI for video, among others. Users can upload their files directly to the service, which then processes the audio track to extract the spoken words.  The transcription process involves several steps, including noise reduction to improve audio clarity, speaker diarization to identify and differentiate between different speakers, and the actual speech-to-text conversion. The result is a detailed transcript that captures the spoken content, often including timestamps and speaker labels for easy reference.  This service is particularly useful for journalists, researchers, podcasters, and professionals who need to convert meetings, interviews, lectures, or presentations into written form for analysis, sharing, or archival purposes. The endpoint may offer additional features like language detection, support for multiple languages, and customization options to improve transcription accuracy based on specific vocabulary or industry terms.  To use the audio transcription endpoint, developers typically integrate it into applications via API calls. These calls specify the file to be transcribed and any additional parameters required by the service, such as language preference.   Upon completion, the service returns the transcription in a JSON text format, which can then be displayed, stored, or further processed according to the user&#39;s needs.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="files">The file object to ingest.</param>
        /// <param name="model">Model to use for transcription (Optional, default &#x3D; Base) (optional)</param>
        /// <param name="language">The language of the input audio. Supplying the input language in [ISO-639-1](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) format will improve accuracy and latency.  (optional) (optional)</param>
        /// <param name="prompt">An optional text to guide the model&#39;s style or continue a previous audio segment. The prompt should match the audio language.  (optional) (optional)</param>
        /// <param name="temperature">The sampling temperature, between 0 and 1. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. If set to 0, the model will use [log probability](https://en.wikipedia.org/wiki/Log_probability) to automatically increase the temperature until certain thresholds are hit.  (optional, default to 0M) (optional, default to 0D)</param>
        /// <param name="splitOnWord">Split into word segments. (optional, default is false) (optional, default to false)</param>
        /// <param name="languageDetection">Enable transcription language detection (Optional. default is false) (optional, default to false)</param>
        /// <param name="enableNoiseReduction">Enable noise reduction from audio stream before transcription (Optional. default is false) (optional, default to false)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ITranscriptionSynchronousApiResponse"/>&gt;</returns>
        public async Task<ITranscriptionSynchronousApiResponse> TranscriptionSynchronousAsync(List<System.IO.Stream> files, Option<string> model = default, Option<string> language = default, Option<string> prompt = default, Option<double> temperature = default, Option<bool> splitOnWord = default, Option<bool> languageDetection = default, Option<bool> enableNoiseReduction = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateTranscriptionSynchronous(files, model, language, prompt);

                FormatTranscriptionSynchronous(files, ref model, ref language, ref prompt, ref temperature, ref splitOnWord, ref languageDetection, ref enableNoiseReduction);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/api/extract/transcription";

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (model.IsSet)
                        parseQueryStringLocalVar["model"] = ClientUtils.ParameterToString(model.Value);

                    if (language.IsSet)
                        parseQueryStringLocalVar["language"] = ClientUtils.ParameterToString(language.Value);

                    if (prompt.IsSet)
                        parseQueryStringLocalVar["prompt"] = ClientUtils.ParameterToString(prompt.Value);

                    if (temperature.IsSet)
                        parseQueryStringLocalVar["temperature"] = ClientUtils.ParameterToString(temperature.Value);

                    if (splitOnWord.IsSet)
                        parseQueryStringLocalVar["splitOnWord"] = ClientUtils.ParameterToString(splitOnWord.Value);

                    if (languageDetection.IsSet)
                        parseQueryStringLocalVar["languageDetection"] = ClientUtils.ParameterToString(languageDetection.Value);

                    if (enableNoiseReduction.IsSet)
                        parseQueryStringLocalVar["enableNoiseReduction"] = ClientUtils.ParameterToString(enableNoiseReduction.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    MultipartContent multipartContentLocalVar = new MultipartContent();

                    httpRequestMessageLocalVar.Content = multipartContentLocalVar;

                    List<KeyValuePair<string?, string?>> formParameterLocalVars = new List<KeyValuePair<string?, string?>>();

                    multipartContentLocalVar.Add(new FormUrlEncodedContent(formParameterLocalVars));                    multipartContentLocalVar.Add(new StreamContent(files));

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] contentTypes = new string[] {
                        "multipart/form-data",
                        "application/x-www-form-urlencoded"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json",
                        "application/problem+json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<TranscriptionSynchronousApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<TranscriptionSynchronousApiResponse>();

                        TranscriptionSynchronousApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/extract/transcription", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterTranscriptionSynchronousDefaultImplementation(apiResponseLocalVar, files, model, language, prompt, temperature, splitOnWord, languageDetection, enableNoiseReduction);

                        Events.ExecuteOnTranscriptionSynchronous(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorTranscriptionSynchronousDefaultImplementation(e, "/api/extract/transcription", uriBuilderLocalVar.Path, files, model, language, prompt, temperature, splitOnWord, languageDetection, enableNoiseReduction);
                Events.ExecuteOnErrorTranscriptionSynchronous(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="TranscriptionSynchronousApiResponse"/>
        /// </summary>
        public partial class TranscriptionSynchronousApiResponse : Org.OpenAPITools.Client.ApiResponse, ITranscriptionSynchronousApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<TranscriptionSynchronousApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="TranscriptionSynchronousApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public TranscriptionSynchronousApiResponse(ILogger<TranscriptionSynchronousApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.TranscriptionResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.TranscriptionResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.TranscriptionResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.HttpValidationProblemDetails? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.HttpValidationProblemDetails>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out Org.OpenAPITools.Model.HttpValidationProblemDetails? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 429 TooManyRequests
            /// </summary>
            /// <returns></returns>
            public bool IsTooManyRequests => 429 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 429 TooManyRequests
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.ProblemDetails? TooManyRequests()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsTooManyRequests
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.ProblemDetails>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 429 TooManyRequests and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryTooManyRequests([NotNullWhen(true)]out Org.OpenAPITools.Model.ProblemDetails? result)
            {
                result = null;

                try
                {
                    result = TooManyRequests();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)429);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.ProblemDetails? InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.ProblemDetails>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out Org.OpenAPITools.Model.ProblemDetails? result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }
    }
}
