/*
 * Studio - AI Empower Labs
 *
 * # Studio API Documentation  ## Introduction Welcome to Studio by AI Empower Labs API documentation! We are thrilled to offer developers around the world access to our cutting-edge artificial intelligence technology and semantic search. Our API is designed to empower your applications with state-of-the-art AI capabilities, including but not limited to natural language processing, audio transcription, embedding, and predictive analytics.  Our mission is to make AI technology accessible and easy to integrate, enabling you to enhance your applications, improve user experiences, and innovate in your field. Whether you're building complex systems, developing mobile apps, or creating web services, our API provides you with the tools you need to incorporate AI functionalities seamlessly.  Support and Feedback We are committed to providing exceptional support to our developer community. If you have any questions, encounter any issues, or have feedback on how we can improve our API, please don't hesitate to contact our support team @ support@AIEmpowerLabs.com.  Terms of Use Please review our terms of use and privacy policy before integrating our API into your application. By using our API, you agree to comply with these terms.
 *
 * The version of the OpenAPI document: v1
 * Contact: support@aiempowerlabs.com
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Net;
using System.Net.Mime;
using Org.OpenAPITools.Client;
using Org.OpenAPITools.Model;

namespace Org.OpenAPITools.Api
{

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface ISemanticSearchApiSync : IApiAccessor
    {
        #region Synchronous Operations
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Ask questions over ingested documents
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="askDocumentRequest"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>AskDocumentResponse</returns>
        AskDocumentResponse SemanticSearchAsk(AskDocumentRequest askDocumentRequest, int operationIndex = 0);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Ask questions over ingested documents
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="askDocumentRequest"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of AskDocumentResponse</returns>
        ApiResponse<AskDocumentResponse> SemanticSearchAskWithHttpInfo(AskDocumentRequest askDocumentRequest, int operationIndex = 0);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Delete specific document by id
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="documentId"></param>
        /// <param name="index"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        void SemanticSearchDeleteDocument(string documentId, string index, int operationIndex = 0);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Delete specific document by id
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="documentId"></param>
        /// <param name="index"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> SemanticSearchDeleteDocumentWithHttpInfo(string documentId, string index, int operationIndex = 0);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Delete specific index by name
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        void SemanticSearchDeleteIndex(string name, int operationIndex = 0);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Delete specific index by name
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> SemanticSearchDeleteIndexWithHttpInfo(string name, int operationIndex = 0);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Import file document into semantic search
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="files">The file object to ingest.</param>
        /// <param name="documentId">Id that uniquely identifies content within an index. Previously ingested documents with the same id will be overwritten schema. (optional)</param>
        /// <param name="index">Optional value to specify with index the document should be ingested. Defaults to &#39;default&#39;. (optional)</param>
        /// <param name="pipeline">Optional value to specify ingestion pipeline steps. Defaults to server configured defaults. (optional)</param>
        /// <param name="webHookUrl">Url to use for webhook callback when operation finishes or fails. (optional)</param>
        /// <param name="embeddingModel">Embedding model to use in ingestion. Optional. Default to configured default. (optional)</param>
        /// <param name="args"> (optional)</param>
        /// <param name="tags">Tags to associate with ingestion (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>IngestDocumentResponse</returns>
        IngestDocumentResponse SemanticSearchFileIngestion(List<System.IO.Stream> files, string? documentId = default(string?), string? index = default(string?), List<string>? pipeline = default(List<string>?), string? webHookUrl = default(string?), string? embeddingModel = default(string?), Dictionary<string, Object>? args = default(Dictionary<string, Object>?), Dictionary<string, Object>? tags = default(Dictionary<string, Object>?), int operationIndex = 0);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Import file document into semantic search
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="files">The file object to ingest.</param>
        /// <param name="documentId">Id that uniquely identifies content within an index. Previously ingested documents with the same id will be overwritten schema. (optional)</param>
        /// <param name="index">Optional value to specify with index the document should be ingested. Defaults to &#39;default&#39;. (optional)</param>
        /// <param name="pipeline">Optional value to specify ingestion pipeline steps. Defaults to server configured defaults. (optional)</param>
        /// <param name="webHookUrl">Url to use for webhook callback when operation finishes or fails. (optional)</param>
        /// <param name="embeddingModel">Embedding model to use in ingestion. Optional. Default to configured default. (optional)</param>
        /// <param name="args"> (optional)</param>
        /// <param name="tags">Tags to associate with ingestion (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of IngestDocumentResponse</returns>
        ApiResponse<IngestDocumentResponse> SemanticSearchFileIngestionWithHttpInfo(List<System.IO.Stream> files, string? documentId = default(string?), string? index = default(string?), List<string>? pipeline = default(List<string>?), string? webHookUrl = default(string?), string? embeddingModel = default(string?), Dictionary<string, Object>? args = default(Dictionary<string, Object>?), Dictionary<string, Object>? tags = default(Dictionary<string, Object>?), int operationIndex = 0);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Get queue status for ingestion job
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>DataPipelineStatus</returns>
        DataPipelineStatus SemanticSearchIngestionStatus(Guid id, int operationIndex = 0);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Get queue status for ingestion job
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of DataPipelineStatus</returns>
        ApiResponse<DataPipelineStatus> SemanticSearchIngestionStatusWithHttpInfo(Guid id, int operationIndex = 0);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// List - and filter - for ingested documents
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="listDocumentParameters"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ListDocumentResponse</returns>
        ListDocumentResponse SemanticSearchList(ListDocumentParameters listDocumentParameters, int operationIndex = 0);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// List - and filter - for ingested documents
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="listDocumentParameters"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of ListDocumentResponse</returns>
        ApiResponse<ListDocumentResponse> SemanticSearchListWithHttpInfo(ListDocumentParameters listDocumentParameters, int operationIndex = 0);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Query ingested documents using semantic search
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="queryDocumentRequest"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>QueryDocumentResponse</returns>
        QueryDocumentResponse SemanticSearchQuery(QueryDocumentRequest queryDocumentRequest, int operationIndex = 0);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Query ingested documents using semantic search
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="queryDocumentRequest"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of QueryDocumentResponse</returns>
        ApiResponse<QueryDocumentResponse> SemanticSearchQueryWithHttpInfo(QueryDocumentRequest queryDocumentRequest, int operationIndex = 0);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Perform k-means clustering over semantic search log entries
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="semanticSearchQueryResultsClusteringRequest"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>KMeansCluster</returns>
        KMeansCluster SemanticSearchQueryResultsClustering(SemanticSearchQueryResultsClusteringRequest semanticSearchQueryResultsClusteringRequest, int operationIndex = 0);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Perform k-means clustering over semantic search log entries
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="semanticSearchQueryResultsClusteringRequest"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of KMeansCluster</returns>
        ApiResponse<KMeansCluster> SemanticSearchQueryResultsClusteringWithHttpInfo(SemanticSearchQueryResultsClusteringRequest semanticSearchQueryResultsClusteringRequest, int operationIndex = 0);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Rerank documents
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="reRankDocumentsRequest"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ReRankDocumentsResponse</returns>
        ReRankDocumentsResponse SemanticSearchRerank(ReRankDocumentsRequest reRankDocumentsRequest, int operationIndex = 0);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Rerank documents
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="reRankDocumentsRequest"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of ReRankDocumentsResponse</returns>
        ApiResponse<ReRankDocumentsResponse> SemanticSearchRerankWithHttpInfo(ReRankDocumentsRequest reRankDocumentsRequest, int operationIndex = 0);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Import plain text into semantic search
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="ingestTextDocumentRequest"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>IngestDocumentResponse</returns>
        IngestDocumentResponse SemanticSearchTextIngestion(IngestTextDocumentRequest ingestTextDocumentRequest, int operationIndex = 0);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Import plain text into semantic search
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="ingestTextDocumentRequest"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of IngestDocumentResponse</returns>
        ApiResponse<IngestDocumentResponse> SemanticSearchTextIngestionWithHttpInfo(IngestTextDocumentRequest ingestTextDocumentRequest, int operationIndex = 0);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Import web page text into semantic search
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="ingestWebPageDocumentRequest"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>IngestDocumentResponse</returns>
        IngestDocumentResponse SemanticSearchWebpageIngestion(IngestWebPageDocumentRequest ingestWebPageDocumentRequest, int operationIndex = 0);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Import web page text into semantic search
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="ingestWebPageDocumentRequest"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of IngestDocumentResponse</returns>
        ApiResponse<IngestDocumentResponse> SemanticSearchWebpageIngestionWithHttpInfo(IngestWebPageDocumentRequest ingestWebPageDocumentRequest, int operationIndex = 0);
        #endregion Synchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface ISemanticSearchApiAsync : IApiAccessor
    {
        #region Asynchronous Operations
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Ask questions over ingested documents
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="askDocumentRequest"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of AskDocumentResponse</returns>
        System.Threading.Tasks.Task<AskDocumentResponse> SemanticSearchAskAsync(AskDocumentRequest askDocumentRequest, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Ask questions over ingested documents
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="askDocumentRequest"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (AskDocumentResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<AskDocumentResponse>> SemanticSearchAskWithHttpInfoAsync(AskDocumentRequest askDocumentRequest, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Delete specific document by id
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="documentId"></param>
        /// <param name="index"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task SemanticSearchDeleteDocumentAsync(string documentId, string index, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Delete specific document by id
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="documentId"></param>
        /// <param name="index"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> SemanticSearchDeleteDocumentWithHttpInfoAsync(string documentId, string index, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Delete specific index by name
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task SemanticSearchDeleteIndexAsync(string name, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Delete specific index by name
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> SemanticSearchDeleteIndexWithHttpInfoAsync(string name, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Import file document into semantic search
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="files">The file object to ingest.</param>
        /// <param name="documentId">Id that uniquely identifies content within an index. Previously ingested documents with the same id will be overwritten schema. (optional)</param>
        /// <param name="index">Optional value to specify with index the document should be ingested. Defaults to &#39;default&#39;. (optional)</param>
        /// <param name="pipeline">Optional value to specify ingestion pipeline steps. Defaults to server configured defaults. (optional)</param>
        /// <param name="webHookUrl">Url to use for webhook callback when operation finishes or fails. (optional)</param>
        /// <param name="embeddingModel">Embedding model to use in ingestion. Optional. Default to configured default. (optional)</param>
        /// <param name="args"> (optional)</param>
        /// <param name="tags">Tags to associate with ingestion (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of IngestDocumentResponse</returns>
        System.Threading.Tasks.Task<IngestDocumentResponse> SemanticSearchFileIngestionAsync(List<System.IO.Stream> files, string? documentId = default(string?), string? index = default(string?), List<string>? pipeline = default(List<string>?), string? webHookUrl = default(string?), string? embeddingModel = default(string?), Dictionary<string, Object>? args = default(Dictionary<string, Object>?), Dictionary<string, Object>? tags = default(Dictionary<string, Object>?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Import file document into semantic search
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="files">The file object to ingest.</param>
        /// <param name="documentId">Id that uniquely identifies content within an index. Previously ingested documents with the same id will be overwritten schema. (optional)</param>
        /// <param name="index">Optional value to specify with index the document should be ingested. Defaults to &#39;default&#39;. (optional)</param>
        /// <param name="pipeline">Optional value to specify ingestion pipeline steps. Defaults to server configured defaults. (optional)</param>
        /// <param name="webHookUrl">Url to use for webhook callback when operation finishes or fails. (optional)</param>
        /// <param name="embeddingModel">Embedding model to use in ingestion. Optional. Default to configured default. (optional)</param>
        /// <param name="args"> (optional)</param>
        /// <param name="tags">Tags to associate with ingestion (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (IngestDocumentResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<IngestDocumentResponse>> SemanticSearchFileIngestionWithHttpInfoAsync(List<System.IO.Stream> files, string? documentId = default(string?), string? index = default(string?), List<string>? pipeline = default(List<string>?), string? webHookUrl = default(string?), string? embeddingModel = default(string?), Dictionary<string, Object>? args = default(Dictionary<string, Object>?), Dictionary<string, Object>? tags = default(Dictionary<string, Object>?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Get queue status for ingestion job
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of DataPipelineStatus</returns>
        System.Threading.Tasks.Task<DataPipelineStatus> SemanticSearchIngestionStatusAsync(Guid id, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Get queue status for ingestion job
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (DataPipelineStatus)</returns>
        System.Threading.Tasks.Task<ApiResponse<DataPipelineStatus>> SemanticSearchIngestionStatusWithHttpInfoAsync(Guid id, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// List - and filter - for ingested documents
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="listDocumentParameters"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ListDocumentResponse</returns>
        System.Threading.Tasks.Task<ListDocumentResponse> SemanticSearchListAsync(ListDocumentParameters listDocumentParameters, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// List - and filter - for ingested documents
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="listDocumentParameters"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ListDocumentResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<ListDocumentResponse>> SemanticSearchListWithHttpInfoAsync(ListDocumentParameters listDocumentParameters, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Query ingested documents using semantic search
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="queryDocumentRequest"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of QueryDocumentResponse</returns>
        System.Threading.Tasks.Task<QueryDocumentResponse> SemanticSearchQueryAsync(QueryDocumentRequest queryDocumentRequest, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Query ingested documents using semantic search
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="queryDocumentRequest"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (QueryDocumentResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<QueryDocumentResponse>> SemanticSearchQueryWithHttpInfoAsync(QueryDocumentRequest queryDocumentRequest, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Perform k-means clustering over semantic search log entries
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="semanticSearchQueryResultsClusteringRequest"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of KMeansCluster</returns>
        System.Threading.Tasks.Task<KMeansCluster> SemanticSearchQueryResultsClusteringAsync(SemanticSearchQueryResultsClusteringRequest semanticSearchQueryResultsClusteringRequest, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Perform k-means clustering over semantic search log entries
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="semanticSearchQueryResultsClusteringRequest"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (KMeansCluster)</returns>
        System.Threading.Tasks.Task<ApiResponse<KMeansCluster>> SemanticSearchQueryResultsClusteringWithHttpInfoAsync(SemanticSearchQueryResultsClusteringRequest semanticSearchQueryResultsClusteringRequest, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Rerank documents
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="reRankDocumentsRequest"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ReRankDocumentsResponse</returns>
        System.Threading.Tasks.Task<ReRankDocumentsResponse> SemanticSearchRerankAsync(ReRankDocumentsRequest reRankDocumentsRequest, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Rerank documents
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="reRankDocumentsRequest"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ReRankDocumentsResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<ReRankDocumentsResponse>> SemanticSearchRerankWithHttpInfoAsync(ReRankDocumentsRequest reRankDocumentsRequest, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Import plain text into semantic search
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="ingestTextDocumentRequest"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of IngestDocumentResponse</returns>
        System.Threading.Tasks.Task<IngestDocumentResponse> SemanticSearchTextIngestionAsync(IngestTextDocumentRequest ingestTextDocumentRequest, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Import plain text into semantic search
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="ingestTextDocumentRequest"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (IngestDocumentResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<IngestDocumentResponse>> SemanticSearchTextIngestionWithHttpInfoAsync(IngestTextDocumentRequest ingestTextDocumentRequest, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Import web page text into semantic search
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="ingestWebPageDocumentRequest"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of IngestDocumentResponse</returns>
        System.Threading.Tasks.Task<IngestDocumentResponse> SemanticSearchWebpageIngestionAsync(IngestWebPageDocumentRequest ingestWebPageDocumentRequest, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Import web page text into semantic search
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="ingestWebPageDocumentRequest"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (IngestDocumentResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<IngestDocumentResponse>> SemanticSearchWebpageIngestionWithHttpInfoAsync(IngestWebPageDocumentRequest ingestWebPageDocumentRequest, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        #endregion Asynchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface ISemanticSearchApi : ISemanticSearchApiSync, ISemanticSearchApiAsync
    {

    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public partial class SemanticSearchApi : ISemanticSearchApi
    {
        private Org.OpenAPITools.Client.ExceptionFactory _exceptionFactory = (name, response) => null;

        /// <summary>
        /// Initializes a new instance of the <see cref="SemanticSearchApi"/> class.
        /// </summary>
        /// <returns></returns>
        public SemanticSearchApi() : this((string)null)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SemanticSearchApi"/> class.
        /// </summary>
        /// <returns></returns>
        public SemanticSearchApi(string basePath)
        {
            this.Configuration = Org.OpenAPITools.Client.Configuration.MergeConfigurations(
                Org.OpenAPITools.Client.GlobalConfiguration.Instance,
                new Org.OpenAPITools.Client.Configuration { BasePath = basePath }
            );
            this.Client = new Org.OpenAPITools.Client.ApiClient(this.Configuration.BasePath);
            this.AsynchronousClient = new Org.OpenAPITools.Client.ApiClient(this.Configuration.BasePath);
            this.ExceptionFactory = Org.OpenAPITools.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SemanticSearchApi"/> class
        /// using Configuration object
        /// </summary>
        /// <param name="configuration">An instance of Configuration</param>
        /// <returns></returns>
        public SemanticSearchApi(Org.OpenAPITools.Client.Configuration configuration)
        {
            if (configuration == null) throw new ArgumentNullException("configuration");

            this.Configuration = Org.OpenAPITools.Client.Configuration.MergeConfigurations(
                Org.OpenAPITools.Client.GlobalConfiguration.Instance,
                configuration
            );
            this.Client = new Org.OpenAPITools.Client.ApiClient(this.Configuration.BasePath);
            this.AsynchronousClient = new Org.OpenAPITools.Client.ApiClient(this.Configuration.BasePath);
            ExceptionFactory = Org.OpenAPITools.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SemanticSearchApi"/> class
        /// using a Configuration object and client instance.
        /// </summary>
        /// <param name="client">The client interface for synchronous API access.</param>
        /// <param name="asyncClient">The client interface for asynchronous API access.</param>
        /// <param name="configuration">The configuration object.</param>
        public SemanticSearchApi(Org.OpenAPITools.Client.ISynchronousClient client, Org.OpenAPITools.Client.IAsynchronousClient asyncClient, Org.OpenAPITools.Client.IReadableConfiguration configuration)
        {
            if (client == null) throw new ArgumentNullException("client");
            if (asyncClient == null) throw new ArgumentNullException("asyncClient");
            if (configuration == null) throw new ArgumentNullException("configuration");

            this.Client = client;
            this.AsynchronousClient = asyncClient;
            this.Configuration = configuration;
            this.ExceptionFactory = Org.OpenAPITools.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// The client for accessing this underlying API asynchronously.
        /// </summary>
        public Org.OpenAPITools.Client.IAsynchronousClient AsynchronousClient { get; set; }

        /// <summary>
        /// The client for accessing this underlying API synchronously.
        /// </summary>
        public Org.OpenAPITools.Client.ISynchronousClient Client { get; set; }

        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public string GetBasePath()
        {
            return this.Configuration.BasePath;
        }

        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public Org.OpenAPITools.Client.IReadableConfiguration Configuration { get; set; }

        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public Org.OpenAPITools.Client.ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                {
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }
                return _exceptionFactory;
            }
            set { _exceptionFactory = value; }
        }

        /// <summary>
        ///  Ask questions over ingested documents
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="askDocumentRequest"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>AskDocumentResponse</returns>
        public AskDocumentResponse SemanticSearchAsk(AskDocumentRequest askDocumentRequest, int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<AskDocumentResponse> localVarResponse = SemanticSearchAskWithHttpInfo(askDocumentRequest);
            return localVarResponse.Data;
        }

        /// <summary>
        ///  Ask questions over ingested documents
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="askDocumentRequest"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of AskDocumentResponse</returns>
        public Org.OpenAPITools.Client.ApiResponse<AskDocumentResponse> SemanticSearchAskWithHttpInfo(AskDocumentRequest askDocumentRequest, int operationIndex = 0)
        {
            // verify the required parameter 'askDocumentRequest' is set
            if (askDocumentRequest == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'askDocumentRequest' when calling SemanticSearchApi->SemanticSearchAsk");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json",
                "application/problem+json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.Data = askDocumentRequest;

            localVarRequestOptions.Operation = "SemanticSearchApi.SemanticSearchAsk";
            localVarRequestOptions.OperationIndex = operationIndex;


            // make the HTTP request
            var localVarResponse = this.Client.Post<AskDocumentResponse>("/api/semantic/ask", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SemanticSearchAsk", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        ///  Ask questions over ingested documents
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="askDocumentRequest"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of AskDocumentResponse</returns>
        public async System.Threading.Tasks.Task<AskDocumentResponse> SemanticSearchAskAsync(AskDocumentRequest askDocumentRequest, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<AskDocumentResponse> localVarResponse = await SemanticSearchAskWithHttpInfoAsync(askDocumentRequest, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        ///  Ask questions over ingested documents
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="askDocumentRequest"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (AskDocumentResponse)</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<AskDocumentResponse>> SemanticSearchAskWithHttpInfoAsync(AskDocumentRequest askDocumentRequest, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'askDocumentRequest' is set
            if (askDocumentRequest == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'askDocumentRequest' when calling SemanticSearchApi->SemanticSearchAsk");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json",
                "application/problem+json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.Data = askDocumentRequest;

            localVarRequestOptions.Operation = "SemanticSearchApi.SemanticSearchAsk";
            localVarRequestOptions.OperationIndex = operationIndex;


            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<AskDocumentResponse>("/api/semantic/ask", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SemanticSearchAsk", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        ///  Delete specific document by id
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="documentId"></param>
        /// <param name="index"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        public void SemanticSearchDeleteDocument(string documentId, string index, int operationIndex = 0)
        {
            SemanticSearchDeleteDocumentWithHttpInfo(documentId, index);
        }

        /// <summary>
        ///  Delete specific document by id
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="documentId"></param>
        /// <param name="index"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public Org.OpenAPITools.Client.ApiResponse<Object> SemanticSearchDeleteDocumentWithHttpInfo(string documentId, string index, int operationIndex = 0)
        {
            // verify the required parameter 'documentId' is set
            if (documentId == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'documentId' when calling SemanticSearchApi->SemanticSearchDeleteDocument");
            }

            // verify the required parameter 'index' is set
            if (index == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'index' when calling SemanticSearchApi->SemanticSearchDeleteDocument");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/problem+json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("documentId", Org.OpenAPITools.Client.ClientUtils.ParameterToString(documentId)); // path parameter
            localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "index", index));

            localVarRequestOptions.Operation = "SemanticSearchApi.SemanticSearchDeleteDocument";
            localVarRequestOptions.OperationIndex = operationIndex;


            // make the HTTP request
            var localVarResponse = this.Client.Delete<Object>("/api/semantic/{documentId}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SemanticSearchDeleteDocument", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        ///  Delete specific document by id
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="documentId"></param>
        /// <param name="index"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task SemanticSearchDeleteDocumentAsync(string documentId, string index, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            await SemanticSearchDeleteDocumentWithHttpInfoAsync(documentId, index, operationIndex, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        ///  Delete specific document by id
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="documentId"></param>
        /// <param name="index"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<Object>> SemanticSearchDeleteDocumentWithHttpInfoAsync(string documentId, string index, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'documentId' is set
            if (documentId == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'documentId' when calling SemanticSearchApi->SemanticSearchDeleteDocument");
            }

            // verify the required parameter 'index' is set
            if (index == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'index' when calling SemanticSearchApi->SemanticSearchDeleteDocument");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/problem+json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("documentId", Org.OpenAPITools.Client.ClientUtils.ParameterToString(documentId)); // path parameter
            localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "index", index));

            localVarRequestOptions.Operation = "SemanticSearchApi.SemanticSearchDeleteDocument";
            localVarRequestOptions.OperationIndex = operationIndex;


            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.DeleteAsync<Object>("/api/semantic/{documentId}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SemanticSearchDeleteDocument", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        ///  Delete specific index by name
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        public void SemanticSearchDeleteIndex(string name, int operationIndex = 0)
        {
            SemanticSearchDeleteIndexWithHttpInfo(name);
        }

        /// <summary>
        ///  Delete specific index by name
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public Org.OpenAPITools.Client.ApiResponse<Object> SemanticSearchDeleteIndexWithHttpInfo(string name, int operationIndex = 0)
        {
            // verify the required parameter 'name' is set
            if (name == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'name' when calling SemanticSearchApi->SemanticSearchDeleteIndex");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/problem+json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("name", Org.OpenAPITools.Client.ClientUtils.ParameterToString(name)); // path parameter

            localVarRequestOptions.Operation = "SemanticSearchApi.SemanticSearchDeleteIndex";
            localVarRequestOptions.OperationIndex = operationIndex;


            // make the HTTP request
            var localVarResponse = this.Client.Delete<Object>("/api/semantic/index", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SemanticSearchDeleteIndex", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        ///  Delete specific index by name
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task SemanticSearchDeleteIndexAsync(string name, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            await SemanticSearchDeleteIndexWithHttpInfoAsync(name, operationIndex, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        ///  Delete specific index by name
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<Object>> SemanticSearchDeleteIndexWithHttpInfoAsync(string name, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'name' when calling SemanticSearchApi->SemanticSearchDeleteIndex");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/problem+json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("name", Org.OpenAPITools.Client.ClientUtils.ParameterToString(name)); // path parameter

            localVarRequestOptions.Operation = "SemanticSearchApi.SemanticSearchDeleteIndex";
            localVarRequestOptions.OperationIndex = operationIndex;


            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.DeleteAsync<Object>("/api/semantic/index", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SemanticSearchDeleteIndex", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        ///  Import file document into semantic search
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="files">The file object to ingest.</param>
        /// <param name="documentId">Id that uniquely identifies content within an index. Previously ingested documents with the same id will be overwritten schema. (optional)</param>
        /// <param name="index">Optional value to specify with index the document should be ingested. Defaults to &#39;default&#39;. (optional)</param>
        /// <param name="pipeline">Optional value to specify ingestion pipeline steps. Defaults to server configured defaults. (optional)</param>
        /// <param name="webHookUrl">Url to use for webhook callback when operation finishes or fails. (optional)</param>
        /// <param name="embeddingModel">Embedding model to use in ingestion. Optional. Default to configured default. (optional)</param>
        /// <param name="args"> (optional)</param>
        /// <param name="tags">Tags to associate with ingestion (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>IngestDocumentResponse</returns>
        public IngestDocumentResponse SemanticSearchFileIngestion(List<System.IO.Stream> files, string? documentId = default(string?), string? index = default(string?), List<string>? pipeline = default(List<string>?), string? webHookUrl = default(string?), string? embeddingModel = default(string?), Dictionary<string, Object>? args = default(Dictionary<string, Object>?), Dictionary<string, Object>? tags = default(Dictionary<string, Object>?), int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<IngestDocumentResponse> localVarResponse = SemanticSearchFileIngestionWithHttpInfo(files, documentId, index, pipeline, webHookUrl, embeddingModel, args, tags);
            return localVarResponse.Data;
        }

        /// <summary>
        ///  Import file document into semantic search
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="files">The file object to ingest.</param>
        /// <param name="documentId">Id that uniquely identifies content within an index. Previously ingested documents with the same id will be overwritten schema. (optional)</param>
        /// <param name="index">Optional value to specify with index the document should be ingested. Defaults to &#39;default&#39;. (optional)</param>
        /// <param name="pipeline">Optional value to specify ingestion pipeline steps. Defaults to server configured defaults. (optional)</param>
        /// <param name="webHookUrl">Url to use for webhook callback when operation finishes or fails. (optional)</param>
        /// <param name="embeddingModel">Embedding model to use in ingestion. Optional. Default to configured default. (optional)</param>
        /// <param name="args"> (optional)</param>
        /// <param name="tags">Tags to associate with ingestion (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of IngestDocumentResponse</returns>
        public Org.OpenAPITools.Client.ApiResponse<IngestDocumentResponse> SemanticSearchFileIngestionWithHttpInfo(List<System.IO.Stream> files, string? documentId = default(string?), string? index = default(string?), List<string>? pipeline = default(List<string>?), string? webHookUrl = default(string?), string? embeddingModel = default(string?), Dictionary<string, Object>? args = default(Dictionary<string, Object>?), Dictionary<string, Object>? tags = default(Dictionary<string, Object>?), int operationIndex = 0)
        {
            // verify the required parameter 'files' is set
            if (files == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'files' when calling SemanticSearchApi->SemanticSearchFileIngestion");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "multipart/form-data",
                "application/x-www-form-urlencoded"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json",
                "application/problem+json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (documentId != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "documentId", documentId));
            }
            if (index != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "index", index));
            }
            if (pipeline != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("multi", "pipeline", pipeline));
            }
            if (webHookUrl != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "webHookUrl", webHookUrl));
            }
            if (embeddingModel != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "embeddingModel", embeddingModel));
            }
            foreach (var file in files)
            {
                localVarRequestOptions.FileParameters.Add("files", file);
            }
            if (args != null)
            {
                localVarRequestOptions.FormParameters.Add("args", Org.OpenAPITools.Client.ClientUtils.Serialize(args)); // form parameter
            }
            if (tags != null)
            {
                localVarRequestOptions.FormParameters.Add("tags", Org.OpenAPITools.Client.ClientUtils.Serialize(tags)); // form parameter
            }

            localVarRequestOptions.Operation = "SemanticSearchApi.SemanticSearchFileIngestion";
            localVarRequestOptions.OperationIndex = operationIndex;


            // make the HTTP request
            var localVarResponse = this.Client.Post<IngestDocumentResponse>("/api/ingest/file", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SemanticSearchFileIngestion", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        ///  Import file document into semantic search
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="files">The file object to ingest.</param>
        /// <param name="documentId">Id that uniquely identifies content within an index. Previously ingested documents with the same id will be overwritten schema. (optional)</param>
        /// <param name="index">Optional value to specify with index the document should be ingested. Defaults to &#39;default&#39;. (optional)</param>
        /// <param name="pipeline">Optional value to specify ingestion pipeline steps. Defaults to server configured defaults. (optional)</param>
        /// <param name="webHookUrl">Url to use for webhook callback when operation finishes or fails. (optional)</param>
        /// <param name="embeddingModel">Embedding model to use in ingestion. Optional. Default to configured default. (optional)</param>
        /// <param name="args"> (optional)</param>
        /// <param name="tags">Tags to associate with ingestion (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of IngestDocumentResponse</returns>
        public async System.Threading.Tasks.Task<IngestDocumentResponse> SemanticSearchFileIngestionAsync(List<System.IO.Stream> files, string? documentId = default(string?), string? index = default(string?), List<string>? pipeline = default(List<string>?), string? webHookUrl = default(string?), string? embeddingModel = default(string?), Dictionary<string, Object>? args = default(Dictionary<string, Object>?), Dictionary<string, Object>? tags = default(Dictionary<string, Object>?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<IngestDocumentResponse> localVarResponse = await SemanticSearchFileIngestionWithHttpInfoAsync(files, documentId, index, pipeline, webHookUrl, embeddingModel, args, tags, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        ///  Import file document into semantic search
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="files">The file object to ingest.</param>
        /// <param name="documentId">Id that uniquely identifies content within an index. Previously ingested documents with the same id will be overwritten schema. (optional)</param>
        /// <param name="index">Optional value to specify with index the document should be ingested. Defaults to &#39;default&#39;. (optional)</param>
        /// <param name="pipeline">Optional value to specify ingestion pipeline steps. Defaults to server configured defaults. (optional)</param>
        /// <param name="webHookUrl">Url to use for webhook callback when operation finishes or fails. (optional)</param>
        /// <param name="embeddingModel">Embedding model to use in ingestion. Optional. Default to configured default. (optional)</param>
        /// <param name="args"> (optional)</param>
        /// <param name="tags">Tags to associate with ingestion (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (IngestDocumentResponse)</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<IngestDocumentResponse>> SemanticSearchFileIngestionWithHttpInfoAsync(List<System.IO.Stream> files, string? documentId = default(string?), string? index = default(string?), List<string>? pipeline = default(List<string>?), string? webHookUrl = default(string?), string? embeddingModel = default(string?), Dictionary<string, Object>? args = default(Dictionary<string, Object>?), Dictionary<string, Object>? tags = default(Dictionary<string, Object>?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'files' is set
            if (files == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'files' when calling SemanticSearchApi->SemanticSearchFileIngestion");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "multipart/form-data", 
                "application/x-www-form-urlencoded"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json",
                "application/problem+json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (documentId != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "documentId", documentId));
            }
            if (index != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "index", index));
            }
            if (pipeline != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("multi", "pipeline", pipeline));
            }
            if (webHookUrl != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "webHookUrl", webHookUrl));
            }
            if (embeddingModel != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "embeddingModel", embeddingModel));
            }
            foreach (var file in files)
            {
                localVarRequestOptions.FileParameters.Add("files", file);
            }
            if (args != null)
            {
                localVarRequestOptions.FormParameters.Add("args", Org.OpenAPITools.Client.ClientUtils.Serialize(args)); // form parameter
            }
            if (tags != null)
            {
                localVarRequestOptions.FormParameters.Add("tags", Org.OpenAPITools.Client.ClientUtils.Serialize(tags)); // form parameter
            }

            localVarRequestOptions.Operation = "SemanticSearchApi.SemanticSearchFileIngestion";
            localVarRequestOptions.OperationIndex = operationIndex;


            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<IngestDocumentResponse>("/api/ingest/file", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SemanticSearchFileIngestion", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        ///  Get queue status for ingestion job
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>DataPipelineStatus</returns>
        public DataPipelineStatus SemanticSearchIngestionStatus(Guid id, int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<DataPipelineStatus> localVarResponse = SemanticSearchIngestionStatusWithHttpInfo(id);
            return localVarResponse.Data;
        }

        /// <summary>
        ///  Get queue status for ingestion job
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of DataPipelineStatus</returns>
        public Org.OpenAPITools.Client.ApiResponse<DataPipelineStatus> SemanticSearchIngestionStatusWithHttpInfo(Guid id, int operationIndex = 0)
        {
            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json",
                "application/problem+json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "id", id));

            localVarRequestOptions.Operation = "SemanticSearchApi.SemanticSearchIngestionStatus";
            localVarRequestOptions.OperationIndex = operationIndex;


            // make the HTTP request
            var localVarResponse = this.Client.Get<DataPipelineStatus>("/api/ingest/status", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SemanticSearchIngestionStatus", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        ///  Get queue status for ingestion job
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of DataPipelineStatus</returns>
        public async System.Threading.Tasks.Task<DataPipelineStatus> SemanticSearchIngestionStatusAsync(Guid id, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<DataPipelineStatus> localVarResponse = await SemanticSearchIngestionStatusWithHttpInfoAsync(id, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        ///  Get queue status for ingestion job
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (DataPipelineStatus)</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<DataPipelineStatus>> SemanticSearchIngestionStatusWithHttpInfoAsync(Guid id, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json",
                "application/problem+json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "id", id));

            localVarRequestOptions.Operation = "SemanticSearchApi.SemanticSearchIngestionStatus";
            localVarRequestOptions.OperationIndex = operationIndex;


            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<DataPipelineStatus>("/api/ingest/status", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SemanticSearchIngestionStatus", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        ///  List - and filter - for ingested documents
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="listDocumentParameters"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ListDocumentResponse</returns>
        public ListDocumentResponse SemanticSearchList(ListDocumentParameters listDocumentParameters, int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<ListDocumentResponse> localVarResponse = SemanticSearchListWithHttpInfo(listDocumentParameters);
            return localVarResponse.Data;
        }

        /// <summary>
        ///  List - and filter - for ingested documents
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="listDocumentParameters"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of ListDocumentResponse</returns>
        public Org.OpenAPITools.Client.ApiResponse<ListDocumentResponse> SemanticSearchListWithHttpInfo(ListDocumentParameters listDocumentParameters, int operationIndex = 0)
        {
            // verify the required parameter 'listDocumentParameters' is set
            if (listDocumentParameters == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'listDocumentParameters' when calling SemanticSearchApi->SemanticSearchList");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json",
                "application/problem+json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.Data = listDocumentParameters;

            localVarRequestOptions.Operation = "SemanticSearchApi.SemanticSearchList";
            localVarRequestOptions.OperationIndex = operationIndex;


            // make the HTTP request
            var localVarResponse = this.Client.Post<ListDocumentResponse>("/api/semantic/list", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SemanticSearchList", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        ///  List - and filter - for ingested documents
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="listDocumentParameters"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ListDocumentResponse</returns>
        public async System.Threading.Tasks.Task<ListDocumentResponse> SemanticSearchListAsync(ListDocumentParameters listDocumentParameters, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<ListDocumentResponse> localVarResponse = await SemanticSearchListWithHttpInfoAsync(listDocumentParameters, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        ///  List - and filter - for ingested documents
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="listDocumentParameters"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ListDocumentResponse)</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<ListDocumentResponse>> SemanticSearchListWithHttpInfoAsync(ListDocumentParameters listDocumentParameters, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'listDocumentParameters' is set
            if (listDocumentParameters == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'listDocumentParameters' when calling SemanticSearchApi->SemanticSearchList");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json",
                "application/problem+json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.Data = listDocumentParameters;

            localVarRequestOptions.Operation = "SemanticSearchApi.SemanticSearchList";
            localVarRequestOptions.OperationIndex = operationIndex;


            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<ListDocumentResponse>("/api/semantic/list", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SemanticSearchList", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        ///  Query ingested documents using semantic search
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="queryDocumentRequest"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>QueryDocumentResponse</returns>
        public QueryDocumentResponse SemanticSearchQuery(QueryDocumentRequest queryDocumentRequest, int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<QueryDocumentResponse> localVarResponse = SemanticSearchQueryWithHttpInfo(queryDocumentRequest);
            return localVarResponse.Data;
        }

        /// <summary>
        ///  Query ingested documents using semantic search
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="queryDocumentRequest"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of QueryDocumentResponse</returns>
        public Org.OpenAPITools.Client.ApiResponse<QueryDocumentResponse> SemanticSearchQueryWithHttpInfo(QueryDocumentRequest queryDocumentRequest, int operationIndex = 0)
        {
            // verify the required parameter 'queryDocumentRequest' is set
            if (queryDocumentRequest == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'queryDocumentRequest' when calling SemanticSearchApi->SemanticSearchQuery");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json",
                "application/problem+json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.Data = queryDocumentRequest;

            localVarRequestOptions.Operation = "SemanticSearchApi.SemanticSearchQuery";
            localVarRequestOptions.OperationIndex = operationIndex;


            // make the HTTP request
            var localVarResponse = this.Client.Post<QueryDocumentResponse>("/api/semantic/query", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SemanticSearchQuery", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        ///  Query ingested documents using semantic search
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="queryDocumentRequest"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of QueryDocumentResponse</returns>
        public async System.Threading.Tasks.Task<QueryDocumentResponse> SemanticSearchQueryAsync(QueryDocumentRequest queryDocumentRequest, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<QueryDocumentResponse> localVarResponse = await SemanticSearchQueryWithHttpInfoAsync(queryDocumentRequest, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        ///  Query ingested documents using semantic search
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="queryDocumentRequest"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (QueryDocumentResponse)</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<QueryDocumentResponse>> SemanticSearchQueryWithHttpInfoAsync(QueryDocumentRequest queryDocumentRequest, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'queryDocumentRequest' is set
            if (queryDocumentRequest == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'queryDocumentRequest' when calling SemanticSearchApi->SemanticSearchQuery");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json",
                "application/problem+json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.Data = queryDocumentRequest;

            localVarRequestOptions.Operation = "SemanticSearchApi.SemanticSearchQuery";
            localVarRequestOptions.OperationIndex = operationIndex;


            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<QueryDocumentResponse>("/api/semantic/query", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SemanticSearchQuery", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        ///  Perform k-means clustering over semantic search log entries
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="semanticSearchQueryResultsClusteringRequest"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>KMeansCluster</returns>
        public KMeansCluster SemanticSearchQueryResultsClustering(SemanticSearchQueryResultsClusteringRequest semanticSearchQueryResultsClusteringRequest, int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<KMeansCluster> localVarResponse = SemanticSearchQueryResultsClusteringWithHttpInfo(semanticSearchQueryResultsClusteringRequest);
            return localVarResponse.Data;
        }

        /// <summary>
        ///  Perform k-means clustering over semantic search log entries
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="semanticSearchQueryResultsClusteringRequest"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of KMeansCluster</returns>
        public Org.OpenAPITools.Client.ApiResponse<KMeansCluster> SemanticSearchQueryResultsClusteringWithHttpInfo(SemanticSearchQueryResultsClusteringRequest semanticSearchQueryResultsClusteringRequest, int operationIndex = 0)
        {
            // verify the required parameter 'semanticSearchQueryResultsClusteringRequest' is set
            if (semanticSearchQueryResultsClusteringRequest == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'semanticSearchQueryResultsClusteringRequest' when calling SemanticSearchApi->SemanticSearchQueryResultsClustering");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json",
                "text/csv",
                "application/problem+json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.Data = semanticSearchQueryResultsClusteringRequest;

            localVarRequestOptions.Operation = "SemanticSearchApi.SemanticSearchQueryResultsClustering";
            localVarRequestOptions.OperationIndex = operationIndex;


            // make the HTTP request
            var localVarResponse = this.Client.Post<KMeansCluster>("/api/semantic/query-results-clustering", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SemanticSearchQueryResultsClustering", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        ///  Perform k-means clustering over semantic search log entries
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="semanticSearchQueryResultsClusteringRequest"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of KMeansCluster</returns>
        public async System.Threading.Tasks.Task<KMeansCluster> SemanticSearchQueryResultsClusteringAsync(SemanticSearchQueryResultsClusteringRequest semanticSearchQueryResultsClusteringRequest, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<KMeansCluster> localVarResponse = await SemanticSearchQueryResultsClusteringWithHttpInfoAsync(semanticSearchQueryResultsClusteringRequest, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        ///  Perform k-means clustering over semantic search log entries
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="semanticSearchQueryResultsClusteringRequest"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (KMeansCluster)</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<KMeansCluster>> SemanticSearchQueryResultsClusteringWithHttpInfoAsync(SemanticSearchQueryResultsClusteringRequest semanticSearchQueryResultsClusteringRequest, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'semanticSearchQueryResultsClusteringRequest' is set
            if (semanticSearchQueryResultsClusteringRequest == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'semanticSearchQueryResultsClusteringRequest' when calling SemanticSearchApi->SemanticSearchQueryResultsClustering");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json",
                "text/csv",
                "application/problem+json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.Data = semanticSearchQueryResultsClusteringRequest;

            localVarRequestOptions.Operation = "SemanticSearchApi.SemanticSearchQueryResultsClustering";
            localVarRequestOptions.OperationIndex = operationIndex;


            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<KMeansCluster>("/api/semantic/query-results-clustering", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SemanticSearchQueryResultsClustering", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        ///  Rerank documents
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="reRankDocumentsRequest"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ReRankDocumentsResponse</returns>
        public ReRankDocumentsResponse SemanticSearchRerank(ReRankDocumentsRequest reRankDocumentsRequest, int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<ReRankDocumentsResponse> localVarResponse = SemanticSearchRerankWithHttpInfo(reRankDocumentsRequest);
            return localVarResponse.Data;
        }

        /// <summary>
        ///  Rerank documents
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="reRankDocumentsRequest"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of ReRankDocumentsResponse</returns>
        public Org.OpenAPITools.Client.ApiResponse<ReRankDocumentsResponse> SemanticSearchRerankWithHttpInfo(ReRankDocumentsRequest reRankDocumentsRequest, int operationIndex = 0)
        {
            // verify the required parameter 'reRankDocumentsRequest' is set
            if (reRankDocumentsRequest == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'reRankDocumentsRequest' when calling SemanticSearchApi->SemanticSearchRerank");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json",
                "application/problem+json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.Data = reRankDocumentsRequest;

            localVarRequestOptions.Operation = "SemanticSearchApi.SemanticSearchRerank";
            localVarRequestOptions.OperationIndex = operationIndex;


            // make the HTTP request
            var localVarResponse = this.Client.Post<ReRankDocumentsResponse>("/api/semantic/rerank", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SemanticSearchRerank", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        ///  Rerank documents
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="reRankDocumentsRequest"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ReRankDocumentsResponse</returns>
        public async System.Threading.Tasks.Task<ReRankDocumentsResponse> SemanticSearchRerankAsync(ReRankDocumentsRequest reRankDocumentsRequest, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<ReRankDocumentsResponse> localVarResponse = await SemanticSearchRerankWithHttpInfoAsync(reRankDocumentsRequest, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        ///  Rerank documents
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="reRankDocumentsRequest"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ReRankDocumentsResponse)</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<ReRankDocumentsResponse>> SemanticSearchRerankWithHttpInfoAsync(ReRankDocumentsRequest reRankDocumentsRequest, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'reRankDocumentsRequest' is set
            if (reRankDocumentsRequest == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'reRankDocumentsRequest' when calling SemanticSearchApi->SemanticSearchRerank");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json",
                "application/problem+json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.Data = reRankDocumentsRequest;

            localVarRequestOptions.Operation = "SemanticSearchApi.SemanticSearchRerank";
            localVarRequestOptions.OperationIndex = operationIndex;


            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<ReRankDocumentsResponse>("/api/semantic/rerank", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SemanticSearchRerank", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        ///  Import plain text into semantic search
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="ingestTextDocumentRequest"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>IngestDocumentResponse</returns>
        public IngestDocumentResponse SemanticSearchTextIngestion(IngestTextDocumentRequest ingestTextDocumentRequest, int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<IngestDocumentResponse> localVarResponse = SemanticSearchTextIngestionWithHttpInfo(ingestTextDocumentRequest);
            return localVarResponse.Data;
        }

        /// <summary>
        ///  Import plain text into semantic search
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="ingestTextDocumentRequest"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of IngestDocumentResponse</returns>
        public Org.OpenAPITools.Client.ApiResponse<IngestDocumentResponse> SemanticSearchTextIngestionWithHttpInfo(IngestTextDocumentRequest ingestTextDocumentRequest, int operationIndex = 0)
        {
            // verify the required parameter 'ingestTextDocumentRequest' is set
            if (ingestTextDocumentRequest == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'ingestTextDocumentRequest' when calling SemanticSearchApi->SemanticSearchTextIngestion");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json",
                "application/problem+json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.Data = ingestTextDocumentRequest;

            localVarRequestOptions.Operation = "SemanticSearchApi.SemanticSearchTextIngestion";
            localVarRequestOptions.OperationIndex = operationIndex;


            // make the HTTP request
            var localVarResponse = this.Client.Post<IngestDocumentResponse>("/api/ingest/text", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SemanticSearchTextIngestion", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        ///  Import plain text into semantic search
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="ingestTextDocumentRequest"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of IngestDocumentResponse</returns>
        public async System.Threading.Tasks.Task<IngestDocumentResponse> SemanticSearchTextIngestionAsync(IngestTextDocumentRequest ingestTextDocumentRequest, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<IngestDocumentResponse> localVarResponse = await SemanticSearchTextIngestionWithHttpInfoAsync(ingestTextDocumentRequest, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        ///  Import plain text into semantic search
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="ingestTextDocumentRequest"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (IngestDocumentResponse)</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<IngestDocumentResponse>> SemanticSearchTextIngestionWithHttpInfoAsync(IngestTextDocumentRequest ingestTextDocumentRequest, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'ingestTextDocumentRequest' is set
            if (ingestTextDocumentRequest == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'ingestTextDocumentRequest' when calling SemanticSearchApi->SemanticSearchTextIngestion");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json",
                "application/problem+json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.Data = ingestTextDocumentRequest;

            localVarRequestOptions.Operation = "SemanticSearchApi.SemanticSearchTextIngestion";
            localVarRequestOptions.OperationIndex = operationIndex;


            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<IngestDocumentResponse>("/api/ingest/text", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SemanticSearchTextIngestion", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        ///  Import web page text into semantic search
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="ingestWebPageDocumentRequest"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>IngestDocumentResponse</returns>
        public IngestDocumentResponse SemanticSearchWebpageIngestion(IngestWebPageDocumentRequest ingestWebPageDocumentRequest, int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<IngestDocumentResponse> localVarResponse = SemanticSearchWebpageIngestionWithHttpInfo(ingestWebPageDocumentRequest);
            return localVarResponse.Data;
        }

        /// <summary>
        ///  Import web page text into semantic search
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="ingestWebPageDocumentRequest"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of IngestDocumentResponse</returns>
        public Org.OpenAPITools.Client.ApiResponse<IngestDocumentResponse> SemanticSearchWebpageIngestionWithHttpInfo(IngestWebPageDocumentRequest ingestWebPageDocumentRequest, int operationIndex = 0)
        {
            // verify the required parameter 'ingestWebPageDocumentRequest' is set
            if (ingestWebPageDocumentRequest == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'ingestWebPageDocumentRequest' when calling SemanticSearchApi->SemanticSearchWebpageIngestion");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json",
                "application/problem+json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.Data = ingestWebPageDocumentRequest;

            localVarRequestOptions.Operation = "SemanticSearchApi.SemanticSearchWebpageIngestion";
            localVarRequestOptions.OperationIndex = operationIndex;


            // make the HTTP request
            var localVarResponse = this.Client.Post<IngestDocumentResponse>("/api/ingest/webpage", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SemanticSearchWebpageIngestion", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        ///  Import web page text into semantic search
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="ingestWebPageDocumentRequest"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of IngestDocumentResponse</returns>
        public async System.Threading.Tasks.Task<IngestDocumentResponse> SemanticSearchWebpageIngestionAsync(IngestWebPageDocumentRequest ingestWebPageDocumentRequest, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<IngestDocumentResponse> localVarResponse = await SemanticSearchWebpageIngestionWithHttpInfoAsync(ingestWebPageDocumentRequest, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        ///  Import web page text into semantic search
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="ingestWebPageDocumentRequest"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (IngestDocumentResponse)</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<IngestDocumentResponse>> SemanticSearchWebpageIngestionWithHttpInfoAsync(IngestWebPageDocumentRequest ingestWebPageDocumentRequest, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'ingestWebPageDocumentRequest' is set
            if (ingestWebPageDocumentRequest == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'ingestWebPageDocumentRequest' when calling SemanticSearchApi->SemanticSearchWebpageIngestion");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json",
                "application/problem+json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.Data = ingestWebPageDocumentRequest;

            localVarRequestOptions.Operation = "SemanticSearchApi.SemanticSearchWebpageIngestion";
            localVarRequestOptions.OperationIndex = operationIndex;


            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<IngestDocumentResponse>("/api/ingest/webpage", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SemanticSearchWebpageIngestion", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

    }
}
