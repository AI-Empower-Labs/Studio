// <auto-generated>
/*
 * Studio - AI Empower Labs
 *
 * # Studio API Documentation  ## Introduction Welcome to Studio by AI Empower Labs API documentation! We are thrilled to offer developers around the world access to our cutting-edge artificial intelligence technology and semantic search. Our API is designed to empower your applications with state-of-the-art AI capabilities, including but not limited to natural language processing, audio transcription, embedding, and predictive analytics.  Our mission is to make AI technology accessible and easy to integrate, enabling you to enhance your applications, improve user experiences, and innovate in your field. Whether you're building complex systems, developing mobile apps, or creating web services, our API provides you with the tools you need to incorporate AI functionalities seamlessly.  Support and Feedback We are committed to providing exceptional support to our developer community. If you have any questions, encounter any issues, or have feedback on how we can improve our API, please don't hesitate to contact our support team @ support@AIEmpowerLabs.com.  Terms of Use Please review our terms of use and privacy policy before integrating our API into your application. By using our API, you agree to comply with these terms.
 *
 * The version of the OpenAPI document: v1
 * Contact: support@aiempowerlabs.com
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

#nullable enable

using System;
using System.Collections.Generic;
using System.Net;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text.Json;
using Org.OpenAPITools.Client;
using Org.OpenAPITools.Model;
using System.Diagnostics.CodeAnalysis;

namespace Org.OpenAPITools.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// This class is registered as transient.
    /// </summary>
    public interface ISemanticSearchApi : IApi
    {
        /// <summary>
        /// The class containing the events
        /// </summary>
        SemanticSearchApiEvents Events { get; }

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Delete specific document by id
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="documentId"></param>
        /// <param name="index"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISemanticSearchDeleteDocumentApiResponse"/>&gt;</returns>
        Task<ISemanticSearchDeleteDocumentApiResponse> SemanticSearchDeleteDocumentAsync(string documentId, string index, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Delete specific document by id
        /// </remarks>
        /// <param name="documentId"></param>
        /// <param name="index"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISemanticSearchDeleteDocumentApiResponse"/>?&gt;</returns>
        Task<ISemanticSearchDeleteDocumentApiResponse?> SemanticSearchDeleteDocumentOrDefaultAsync(string documentId, string index, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Delete specific index by name
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="name"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISemanticSearchDeleteIndexApiResponse"/>&gt;</returns>
        Task<ISemanticSearchDeleteIndexApiResponse> SemanticSearchDeleteIndexAsync(string name, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Delete specific index by name
        /// </remarks>
        /// <param name="name"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISemanticSearchDeleteIndexApiResponse"/>?&gt;</returns>
        Task<ISemanticSearchDeleteIndexApiResponse?> SemanticSearchDeleteIndexOrDefaultAsync(string name, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Ingest a File into Semantic Search
        /// </summary>
        /// <remarks>
        /// Uploads and ingests a file document into the semantic search index. Supports optional configuration of index, ingestion pipeline, embedding model, and webhook for processing status.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="documentId2">Unique identifier for the document to ingest.</param>
        /// <param name="files">A collection of files to be ingested. Must contain at least one file.</param>
        /// <param name="documentId">A unique identifier for the document within the index. Documents with the same ID will be overwritten. (optional)</param>
        /// <param name="index">The name of the index where the document will be ingested. Defaults to &#39;default&#39; if not specified. (optional)</param>
        /// <param name="pipeline">An array of ingestion pipeline step names. If not provided, server default steps will be used. (optional)</param>
        /// <param name="webHookUrl">A URL to receive a callback via webhook when the ingestion process is completed or fails. (optional)</param>
        /// <param name="embeddingModel">The embedding model to use during ingestion. If not specified, the server&#39;s default model will be applied. (optional)</param>
        /// <param name="index2">Optional index name where the document will be stored. (optional)</param>
        /// <param name="webHookUrl2">Optional webhook URL to notify upon completion. (optional)</param>
        /// <param name="embeddingModelName">Optional name of the embedding model to use during ingestion. (optional)</param>
        /// <param name="context">Optional key-value pairs for additional context or metadata. (optional)</param>
        /// <param name="tags">A collection of tags associated with the document. Tags can be language-specific. (optional)</param>
        /// <param name="ingestionPipeline">Optional list of ingestion pipeline steps. Allows custom processing. (optional)</param>
        /// <param name="languageAutoDetection">Enable automatic language detection for document content. (optional, default to false)</param>
        /// <param name="language">Force a specific language for full-text search. Use &#39;simple&#39; for no language or leave empty. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISemanticSearchFileIngestionApiResponse"/>&gt;</returns>
        Task<ISemanticSearchFileIngestionApiResponse> SemanticSearchFileIngestionAsync(string documentId2, List<System.IO.Stream> files, Option<string> documentId = default, Option<string> index = default, Option<List<string>> pipeline = default, Option<string?> webHookUrl = default, Option<string?> embeddingModel = default, Option<string?> index2 = default, Option<string?> webHookUrl2 = default, Option<string?> embeddingModelName = default, Option<Dictionary<string, string>?> context = default, Option<Dictionary<string, List<string>>?> tags = default, Option<List<string>?> ingestionPipeline = default, Option<bool> languageAutoDetection = default, Option<string?> language = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Ingest a File into Semantic Search
        /// </summary>
        /// <remarks>
        /// Uploads and ingests a file document into the semantic search index. Supports optional configuration of index, ingestion pipeline, embedding model, and webhook for processing status.
        /// </remarks>
        /// <param name="documentId2">Unique identifier for the document to ingest.</param>
        /// <param name="files">A collection of files to be ingested. Must contain at least one file.</param>
        /// <param name="documentId">A unique identifier for the document within the index. Documents with the same ID will be overwritten. (optional)</param>
        /// <param name="index">The name of the index where the document will be ingested. Defaults to &#39;default&#39; if not specified. (optional)</param>
        /// <param name="pipeline">An array of ingestion pipeline step names. If not provided, server default steps will be used. (optional)</param>
        /// <param name="webHookUrl">A URL to receive a callback via webhook when the ingestion process is completed or fails. (optional)</param>
        /// <param name="embeddingModel">The embedding model to use during ingestion. If not specified, the server&#39;s default model will be applied. (optional)</param>
        /// <param name="index2">Optional index name where the document will be stored. (optional)</param>
        /// <param name="webHookUrl2">Optional webhook URL to notify upon completion. (optional)</param>
        /// <param name="embeddingModelName">Optional name of the embedding model to use during ingestion. (optional)</param>
        /// <param name="context">Optional key-value pairs for additional context or metadata. (optional)</param>
        /// <param name="tags">A collection of tags associated with the document. Tags can be language-specific. (optional)</param>
        /// <param name="ingestionPipeline">Optional list of ingestion pipeline steps. Allows custom processing. (optional)</param>
        /// <param name="languageAutoDetection">Enable automatic language detection for document content. (optional, default to false)</param>
        /// <param name="language">Force a specific language for full-text search. Use &#39;simple&#39; for no language or leave empty. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISemanticSearchFileIngestionApiResponse"/>?&gt;</returns>
        Task<ISemanticSearchFileIngestionApiResponse?> SemanticSearchFileIngestionOrDefaultAsync(string documentId2, List<System.IO.Stream> files, Option<string> documentId = default, Option<string> index = default, Option<List<string>> pipeline = default, Option<string?> webHookUrl = default, Option<string?> embeddingModel = default, Option<string?> index2 = default, Option<string?> webHookUrl2 = default, Option<string?> embeddingModelName = default, Option<Dictionary<string, string>?> context = default, Option<Dictionary<string, List<string>>?> tags = default, Option<List<string>?> ingestionPipeline = default, Option<bool> languageAutoDetection = default, Option<string?> language = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Get queue status for ingestion job
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISemanticSearchIngestionStatusApiResponse"/>&gt;</returns>
        Task<ISemanticSearchIngestionStatusApiResponse> SemanticSearchIngestionStatusAsync(Guid id, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Get queue status for ingestion job
        /// </remarks>
        /// <param name="id"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISemanticSearchIngestionStatusApiResponse"/>?&gt;</returns>
        Task<ISemanticSearchIngestionStatusApiResponse?> SemanticSearchIngestionStatusOrDefaultAsync(Guid id, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// List - and filter - for ingested documents
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="listDocumentParameters"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISemanticSearchListApiResponse"/>&gt;</returns>
        Task<ISemanticSearchListApiResponse> SemanticSearchListAsync(ListDocumentParameters listDocumentParameters, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// List - and filter - for ingested documents
        /// </remarks>
        /// <param name="listDocumentParameters"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISemanticSearchListApiResponse"/>?&gt;</returns>
        Task<ISemanticSearchListApiResponse?> SemanticSearchListOrDefaultAsync(ListDocumentParameters listDocumentParameters, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Performs semantic or hybrid search over previously ingested data.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="queryDocumentRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISemanticSearchQueryApiResponse"/>&gt;</returns>
        Task<ISemanticSearchQueryApiResponse> SemanticSearchQueryAsync(QueryDocumentRequest queryDocumentRequest, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Performs semantic or hybrid search over previously ingested data.
        /// </remarks>
        /// <param name="queryDocumentRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISemanticSearchQueryApiResponse"/>?&gt;</returns>
        Task<ISemanticSearchQueryApiResponse?> SemanticSearchQueryOrDefaultAsync(QueryDocumentRequest queryDocumentRequest, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Perform k-means clustering over semantic search log entries
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="semanticSearchQueryResultsClusteringRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISemanticSearchQueryResultsClusteringApiResponse"/>&gt;</returns>
        Task<ISemanticSearchQueryResultsClusteringApiResponse> SemanticSearchQueryResultsClusteringAsync(SemanticSearchQueryResultsClusteringRequest semanticSearchQueryResultsClusteringRequest, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Perform k-means clustering over semantic search log entries
        /// </remarks>
        /// <param name="semanticSearchQueryResultsClusteringRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISemanticSearchQueryResultsClusteringApiResponse"/>?&gt;</returns>
        Task<ISemanticSearchQueryResultsClusteringApiResponse?> SemanticSearchQueryResultsClusteringOrDefaultAsync(SemanticSearchQueryResultsClusteringRequest semanticSearchQueryResultsClusteringRequest, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Rerank documents
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="reRankDocumentsRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISemanticSearchRerankApiResponse"/>&gt;</returns>
        Task<ISemanticSearchRerankApiResponse> SemanticSearchRerankAsync(ReRankDocumentsRequest reRankDocumentsRequest, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Rerank documents
        /// </remarks>
        /// <param name="reRankDocumentsRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISemanticSearchRerankApiResponse"/>?&gt;</returns>
        Task<ISemanticSearchRerankApiResponse?> SemanticSearchRerankOrDefaultAsync(ReRankDocumentsRequest reRankDocumentsRequest, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Ingest Plain Text for Semantic Search
        /// </summary>
        /// <remarks>
        /// Ingests a plain text document into the semantic search index. This endpoint allows associating tags and specifying the target index for enhanced search capabilities.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="ingestTextDocumentRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISemanticSearchTextIngestionApiResponse"/>&gt;</returns>
        Task<ISemanticSearchTextIngestionApiResponse> SemanticSearchTextIngestionAsync(IngestTextDocumentRequest ingestTextDocumentRequest, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Ingest Plain Text for Semantic Search
        /// </summary>
        /// <remarks>
        /// Ingests a plain text document into the semantic search index. This endpoint allows associating tags and specifying the target index for enhanced search capabilities.
        /// </remarks>
        /// <param name="ingestTextDocumentRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISemanticSearchTextIngestionApiResponse"/>?&gt;</returns>
        Task<ISemanticSearchTextIngestionApiResponse?> SemanticSearchTextIngestionOrDefaultAsync(IngestTextDocumentRequest ingestTextDocumentRequest, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Import web page text into semantic search
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="ingestWebPageDocumentRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISemanticSearchWebpageIngestionApiResponse"/>&gt;</returns>
        Task<ISemanticSearchWebpageIngestionApiResponse> SemanticSearchWebpageIngestionAsync(IngestWebPageDocumentRequest ingestWebPageDocumentRequest, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Import web page text into semantic search
        /// </remarks>
        /// <param name="ingestWebPageDocumentRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISemanticSearchWebpageIngestionApiResponse"/>?&gt;</returns>
        Task<ISemanticSearchWebpageIngestionApiResponse?> SemanticSearchWebpageIngestionOrDefaultAsync(IngestWebPageDocumentRequest ingestWebPageDocumentRequest, System.Threading.CancellationToken cancellationToken = default);
    }

    /// <summary>
    /// The <see cref="ISemanticSearchDeleteDocumentApiResponse"/>
    /// </summary>
    public interface ISemanticSearchDeleteDocumentApiResponse : Org.OpenAPITools.Client.IApiResponse, IBadRequest<Org.OpenAPITools.Model.HttpValidationProblemDetails?>, ITooManyRequests<Org.OpenAPITools.Model.ProblemDetails?>, IInternalServerError<Org.OpenAPITools.Model.ProblemDetails?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 429 TooManyRequests
        /// </summary>
        /// <returns></returns>
        bool IsTooManyRequests { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="ISemanticSearchDeleteIndexApiResponse"/>
    /// </summary>
    public interface ISemanticSearchDeleteIndexApiResponse : Org.OpenAPITools.Client.IApiResponse, IBadRequest<Org.OpenAPITools.Model.HttpValidationProblemDetails?>, ITooManyRequests<Org.OpenAPITools.Model.ProblemDetails?>, IInternalServerError<Org.OpenAPITools.Model.ProblemDetails?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 429 TooManyRequests
        /// </summary>
        /// <returns></returns>
        bool IsTooManyRequests { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="ISemanticSearchFileIngestionApiResponse"/>
    /// </summary>
    public interface ISemanticSearchFileIngestionApiResponse : Org.OpenAPITools.Client.IApiResponse, ICreated<Org.OpenAPITools.Model.IngestDocumentResponse?>, IBadRequest<Org.OpenAPITools.Model.HttpValidationProblemDetails?>, ITooManyRequests<Org.OpenAPITools.Model.ProblemDetails?>, IInternalServerError<Org.OpenAPITools.Model.ProblemDetails?>
    {
        /// <summary>
        /// Returns true if the response is 201 Created
        /// </summary>
        /// <returns></returns>
        bool IsCreated { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 429 TooManyRequests
        /// </summary>
        /// <returns></returns>
        bool IsTooManyRequests { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="ISemanticSearchIngestionStatusApiResponse"/>
    /// </summary>
    public interface ISemanticSearchIngestionStatusApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.DataPipelineStatus?>, IBadRequest<Org.OpenAPITools.Model.HttpValidationProblemDetails?>, INotFound<Org.OpenAPITools.Model.ProblemDetails?>, ITooManyRequests<Org.OpenAPITools.Model.ProblemDetails?>, IInternalServerError<Org.OpenAPITools.Model.ProblemDetails?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 429 TooManyRequests
        /// </summary>
        /// <returns></returns>
        bool IsTooManyRequests { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="ISemanticSearchListApiResponse"/>
    /// </summary>
    public interface ISemanticSearchListApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.ListDocumentResponse?>, IBadRequest<Org.OpenAPITools.Model.HttpValidationProblemDetails?>, ITooManyRequests<Org.OpenAPITools.Model.ProblemDetails?>, IInternalServerError<Org.OpenAPITools.Model.ProblemDetails?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 429 TooManyRequests
        /// </summary>
        /// <returns></returns>
        bool IsTooManyRequests { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="ISemanticSearchQueryApiResponse"/>
    /// </summary>
    public interface ISemanticSearchQueryApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.QueryDocumentResponse?>, IBadRequest<Org.OpenAPITools.Model.HttpValidationProblemDetails?>, ITooManyRequests<Org.OpenAPITools.Model.ProblemDetails?>, IInternalServerError<Org.OpenAPITools.Model.ProblemDetails?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 429 TooManyRequests
        /// </summary>
        /// <returns></returns>
        bool IsTooManyRequests { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="ISemanticSearchQueryResultsClusteringApiResponse"/>
    /// </summary>
    public interface ISemanticSearchQueryResultsClusteringApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.KMeansCluster?>, IBadRequest<Org.OpenAPITools.Model.HttpValidationProblemDetails?>, ITooManyRequests<Org.OpenAPITools.Model.ProblemDetails?>, IInternalServerError<Org.OpenAPITools.Model.ProblemDetails?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 429 TooManyRequests
        /// </summary>
        /// <returns></returns>
        bool IsTooManyRequests { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="ISemanticSearchRerankApiResponse"/>
    /// </summary>
    public interface ISemanticSearchRerankApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.ReRankDocumentsResponse?>, IBadRequest<Org.OpenAPITools.Model.HttpValidationProblemDetails?>, ITooManyRequests<Org.OpenAPITools.Model.ProblemDetails?>, IInternalServerError<Org.OpenAPITools.Model.ProblemDetails?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 429 TooManyRequests
        /// </summary>
        /// <returns></returns>
        bool IsTooManyRequests { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="ISemanticSearchTextIngestionApiResponse"/>
    /// </summary>
    public interface ISemanticSearchTextIngestionApiResponse : Org.OpenAPITools.Client.IApiResponse, ICreated<Org.OpenAPITools.Model.IngestDocumentResponse?>, IBadRequest<Org.OpenAPITools.Model.HttpValidationProblemDetails?>, ITooManyRequests<Org.OpenAPITools.Model.ProblemDetails?>, IInternalServerError<Org.OpenAPITools.Model.ProblemDetails?>
    {
        /// <summary>
        /// Returns true if the response is 201 Created
        /// </summary>
        /// <returns></returns>
        bool IsCreated { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 429 TooManyRequests
        /// </summary>
        /// <returns></returns>
        bool IsTooManyRequests { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="ISemanticSearchWebpageIngestionApiResponse"/>
    /// </summary>
    public interface ISemanticSearchWebpageIngestionApiResponse : Org.OpenAPITools.Client.IApiResponse, ICreated<Org.OpenAPITools.Model.IngestDocumentResponse?>, IBadRequest<Org.OpenAPITools.Model.HttpValidationProblemDetails?>, ITooManyRequests<Org.OpenAPITools.Model.ProblemDetails?>, IInternalServerError<Org.OpenAPITools.Model.ProblemDetails?>
    {
        /// <summary>
        /// Returns true if the response is 201 Created
        /// </summary>
        /// <returns></returns>
        bool IsCreated { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 429 TooManyRequests
        /// </summary>
        /// <returns></returns>
        bool IsTooManyRequests { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public class SemanticSearchApiEvents
    {
        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnSemanticSearchDeleteDocument;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorSemanticSearchDeleteDocument;

        internal void ExecuteOnSemanticSearchDeleteDocument(SemanticSearchApi.SemanticSearchDeleteDocumentApiResponse apiResponse)
        {
            OnSemanticSearchDeleteDocument?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorSemanticSearchDeleteDocument(Exception exception)
        {
            OnErrorSemanticSearchDeleteDocument?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnSemanticSearchDeleteIndex;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorSemanticSearchDeleteIndex;

        internal void ExecuteOnSemanticSearchDeleteIndex(SemanticSearchApi.SemanticSearchDeleteIndexApiResponse apiResponse)
        {
            OnSemanticSearchDeleteIndex?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorSemanticSearchDeleteIndex(Exception exception)
        {
            OnErrorSemanticSearchDeleteIndex?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnSemanticSearchFileIngestion;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorSemanticSearchFileIngestion;

        internal void ExecuteOnSemanticSearchFileIngestion(SemanticSearchApi.SemanticSearchFileIngestionApiResponse apiResponse)
        {
            OnSemanticSearchFileIngestion?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorSemanticSearchFileIngestion(Exception exception)
        {
            OnErrorSemanticSearchFileIngestion?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnSemanticSearchIngestionStatus;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorSemanticSearchIngestionStatus;

        internal void ExecuteOnSemanticSearchIngestionStatus(SemanticSearchApi.SemanticSearchIngestionStatusApiResponse apiResponse)
        {
            OnSemanticSearchIngestionStatus?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorSemanticSearchIngestionStatus(Exception exception)
        {
            OnErrorSemanticSearchIngestionStatus?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnSemanticSearchList;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorSemanticSearchList;

        internal void ExecuteOnSemanticSearchList(SemanticSearchApi.SemanticSearchListApiResponse apiResponse)
        {
            OnSemanticSearchList?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorSemanticSearchList(Exception exception)
        {
            OnErrorSemanticSearchList?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnSemanticSearchQuery;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorSemanticSearchQuery;

        internal void ExecuteOnSemanticSearchQuery(SemanticSearchApi.SemanticSearchQueryApiResponse apiResponse)
        {
            OnSemanticSearchQuery?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorSemanticSearchQuery(Exception exception)
        {
            OnErrorSemanticSearchQuery?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnSemanticSearchQueryResultsClustering;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorSemanticSearchQueryResultsClustering;

        internal void ExecuteOnSemanticSearchQueryResultsClustering(SemanticSearchApi.SemanticSearchQueryResultsClusteringApiResponse apiResponse)
        {
            OnSemanticSearchQueryResultsClustering?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorSemanticSearchQueryResultsClustering(Exception exception)
        {
            OnErrorSemanticSearchQueryResultsClustering?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnSemanticSearchRerank;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorSemanticSearchRerank;

        internal void ExecuteOnSemanticSearchRerank(SemanticSearchApi.SemanticSearchRerankApiResponse apiResponse)
        {
            OnSemanticSearchRerank?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorSemanticSearchRerank(Exception exception)
        {
            OnErrorSemanticSearchRerank?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnSemanticSearchTextIngestion;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorSemanticSearchTextIngestion;

        internal void ExecuteOnSemanticSearchTextIngestion(SemanticSearchApi.SemanticSearchTextIngestionApiResponse apiResponse)
        {
            OnSemanticSearchTextIngestion?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorSemanticSearchTextIngestion(Exception exception)
        {
            OnErrorSemanticSearchTextIngestion?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnSemanticSearchWebpageIngestion;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorSemanticSearchWebpageIngestion;

        internal void ExecuteOnSemanticSearchWebpageIngestion(SemanticSearchApi.SemanticSearchWebpageIngestionApiResponse apiResponse)
        {
            OnSemanticSearchWebpageIngestion?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorSemanticSearchWebpageIngestion(Exception exception)
        {
            OnErrorSemanticSearchWebpageIngestion?.Invoke(this, new ExceptionEventArgs(exception));
        }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public sealed partial class SemanticSearchApi : ISemanticSearchApi
    {
        private JsonSerializerOptions _jsonSerializerOptions;

        /// <summary>
        /// The logger factory
        /// </summary>
        public ILoggerFactory LoggerFactory { get; }

        /// <summary>
        /// The logger
        /// </summary>
        public ILogger<SemanticSearchApi> Logger { get; }

        /// <summary>
        /// The HttpClient
        /// </summary>
        public HttpClient HttpClient { get; }

        /// <summary>
        /// The class containing the events
        /// </summary>
        public SemanticSearchApiEvents Events { get; }

        /// <summary>
        /// Initializes a new instance of the <see cref="SemanticSearchApi"/> class.
        /// </summary>
        /// <returns></returns>
        public SemanticSearchApi(ILogger<SemanticSearchApi> logger, ILoggerFactory loggerFactory, HttpClient httpClient, JsonSerializerOptionsProvider jsonSerializerOptionsProvider, SemanticSearchApiEvents semanticSearchApiEvents)
        {
            _jsonSerializerOptions = jsonSerializerOptionsProvider.Options;
            LoggerFactory = loggerFactory;
            Logger = LoggerFactory.CreateLogger<SemanticSearchApi>();
            HttpClient = httpClient;
            Events = semanticSearchApiEvents;
        }

        partial void FormatSemanticSearchDeleteDocument(ref string documentId, ref string index);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="documentId"></param>
        /// <param name="index"></param>
        /// <returns></returns>
        private void ValidateSemanticSearchDeleteDocument(string documentId, string index)
        {
            if (documentId == null)
                throw new ArgumentNullException(nameof(documentId));

            if (index == null)
                throw new ArgumentNullException(nameof(index));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="documentId"></param>
        /// <param name="index"></param>
        private void AfterSemanticSearchDeleteDocumentDefaultImplementation(ISemanticSearchDeleteDocumentApiResponse apiResponseLocalVar, string documentId, string index)
        {
            bool suppressDefaultLog = false;
            AfterSemanticSearchDeleteDocument(ref suppressDefaultLog, apiResponseLocalVar, documentId, index);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="documentId"></param>
        /// <param name="index"></param>
        partial void AfterSemanticSearchDeleteDocument(ref bool suppressDefaultLog, ISemanticSearchDeleteDocumentApiResponse apiResponseLocalVar, string documentId, string index);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="documentId"></param>
        /// <param name="index"></param>
        private void OnErrorSemanticSearchDeleteDocumentDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string documentId, string index)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorSemanticSearchDeleteDocument(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, documentId, index);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="documentId"></param>
        /// <param name="index"></param>
        partial void OnErrorSemanticSearchDeleteDocument(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string documentId, string index);

        /// <summary>
        ///  Delete specific document by id
        /// </summary>
        /// <param name="documentId"></param>
        /// <param name="index"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISemanticSearchDeleteDocumentApiResponse"/>&gt;</returns>
        public async Task<ISemanticSearchDeleteDocumentApiResponse?> SemanticSearchDeleteDocumentOrDefaultAsync(string documentId, string index, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await SemanticSearchDeleteDocumentAsync(documentId, index, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        ///  Delete specific document by id
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="documentId"></param>
        /// <param name="index"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISemanticSearchDeleteDocumentApiResponse"/>&gt;</returns>
        public async Task<ISemanticSearchDeleteDocumentApiResponse> SemanticSearchDeleteDocumentAsync(string documentId, string index, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateSemanticSearchDeleteDocument(documentId, index);

                FormatSemanticSearchDeleteDocument(ref documentId, ref index);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/api/semantic/{documentId}";
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BdocumentId%7D", Uri.EscapeDataString(documentId.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["index"] = ClientUtils.ParameterToString(index);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/problem+json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Delete;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<SemanticSearchDeleteDocumentApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<SemanticSearchDeleteDocumentApiResponse>();

                        SemanticSearchDeleteDocumentApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/semantic/{documentId}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterSemanticSearchDeleteDocumentDefaultImplementation(apiResponseLocalVar, documentId, index);

                        Events.ExecuteOnSemanticSearchDeleteDocument(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorSemanticSearchDeleteDocumentDefaultImplementation(e, "/api/semantic/{documentId}", uriBuilderLocalVar.Path, documentId, index);
                Events.ExecuteOnErrorSemanticSearchDeleteDocument(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="SemanticSearchDeleteDocumentApiResponse"/>
        /// </summary>
        public partial class SemanticSearchDeleteDocumentApiResponse : Org.OpenAPITools.Client.ApiResponse, ISemanticSearchDeleteDocumentApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<SemanticSearchDeleteDocumentApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="SemanticSearchDeleteDocumentApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public SemanticSearchDeleteDocumentApiResponse(ILogger<SemanticSearchDeleteDocumentApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.HttpValidationProblemDetails? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.HttpValidationProblemDetails>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out Org.OpenAPITools.Model.HttpValidationProblemDetails? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 429 TooManyRequests
            /// </summary>
            /// <returns></returns>
            public bool IsTooManyRequests => 429 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 429 TooManyRequests
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.ProblemDetails? TooManyRequests()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsTooManyRequests
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.ProblemDetails>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 429 TooManyRequests and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryTooManyRequests([NotNullWhen(true)]out Org.OpenAPITools.Model.ProblemDetails? result)
            {
                result = null;

                try
                {
                    result = TooManyRequests();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)429);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.ProblemDetails? InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.ProblemDetails>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out Org.OpenAPITools.Model.ProblemDetails? result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatSemanticSearchDeleteIndex(ref string name);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="name"></param>
        /// <returns></returns>
        private void ValidateSemanticSearchDeleteIndex(string name)
        {
            if (name == null)
                throw new ArgumentNullException(nameof(name));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="name"></param>
        private void AfterSemanticSearchDeleteIndexDefaultImplementation(ISemanticSearchDeleteIndexApiResponse apiResponseLocalVar, string name)
        {
            bool suppressDefaultLog = false;
            AfterSemanticSearchDeleteIndex(ref suppressDefaultLog, apiResponseLocalVar, name);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="name"></param>
        partial void AfterSemanticSearchDeleteIndex(ref bool suppressDefaultLog, ISemanticSearchDeleteIndexApiResponse apiResponseLocalVar, string name);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="name"></param>
        private void OnErrorSemanticSearchDeleteIndexDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string name)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorSemanticSearchDeleteIndex(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, name);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="name"></param>
        partial void OnErrorSemanticSearchDeleteIndex(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string name);

        /// <summary>
        ///  Delete specific index by name
        /// </summary>
        /// <param name="name"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISemanticSearchDeleteIndexApiResponse"/>&gt;</returns>
        public async Task<ISemanticSearchDeleteIndexApiResponse?> SemanticSearchDeleteIndexOrDefaultAsync(string name, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await SemanticSearchDeleteIndexAsync(name, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        ///  Delete specific index by name
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="name"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISemanticSearchDeleteIndexApiResponse"/>&gt;</returns>
        public async Task<ISemanticSearchDeleteIndexApiResponse> SemanticSearchDeleteIndexAsync(string name, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateSemanticSearchDeleteIndex(name);

                FormatSemanticSearchDeleteIndex(ref name);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/api/semantic/index/{name}";
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bname%7D", Uri.EscapeDataString(name.ToString()));

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/problem+json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Delete;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<SemanticSearchDeleteIndexApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<SemanticSearchDeleteIndexApiResponse>();

                        SemanticSearchDeleteIndexApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/semantic/index/{name}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterSemanticSearchDeleteIndexDefaultImplementation(apiResponseLocalVar, name);

                        Events.ExecuteOnSemanticSearchDeleteIndex(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorSemanticSearchDeleteIndexDefaultImplementation(e, "/api/semantic/index/{name}", uriBuilderLocalVar.Path, name);
                Events.ExecuteOnErrorSemanticSearchDeleteIndex(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="SemanticSearchDeleteIndexApiResponse"/>
        /// </summary>
        public partial class SemanticSearchDeleteIndexApiResponse : Org.OpenAPITools.Client.ApiResponse, ISemanticSearchDeleteIndexApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<SemanticSearchDeleteIndexApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="SemanticSearchDeleteIndexApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public SemanticSearchDeleteIndexApiResponse(ILogger<SemanticSearchDeleteIndexApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.HttpValidationProblemDetails? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.HttpValidationProblemDetails>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out Org.OpenAPITools.Model.HttpValidationProblemDetails? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 429 TooManyRequests
            /// </summary>
            /// <returns></returns>
            public bool IsTooManyRequests => 429 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 429 TooManyRequests
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.ProblemDetails? TooManyRequests()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsTooManyRequests
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.ProblemDetails>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 429 TooManyRequests and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryTooManyRequests([NotNullWhen(true)]out Org.OpenAPITools.Model.ProblemDetails? result)
            {
                result = null;

                try
                {
                    result = TooManyRequests();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)429);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.ProblemDetails? InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.ProblemDetails>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out Org.OpenAPITools.Model.ProblemDetails? result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatSemanticSearchFileIngestion(ref string documentId2, List<System.IO.Stream> files, ref Option<string> documentId, ref Option<string> index, Option<List<string>> pipeline, ref Option<string?> webHookUrl, ref Option<string?> embeddingModel, ref Option<string?> index2, ref Option<string?> webHookUrl2, ref Option<string?> embeddingModelName, Option<Dictionary<string, string>?> context, Option<Dictionary<string, List<string>>?> tags, Option<List<string>?> ingestionPipeline, ref Option<bool> languageAutoDetection, ref Option<string?> language);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="documentId2"></param>
        /// <param name="files"></param>
        /// <param name="documentId"></param>
        /// <param name="index"></param>
        /// <param name="pipeline"></param>
        /// <returns></returns>
        private void ValidateSemanticSearchFileIngestion(string documentId2, List<System.IO.Stream> files, Option<string> documentId, Option<string> index, Option<List<string>> pipeline)
        {
            if (documentId2 == null)
                throw new ArgumentNullException(nameof(documentId2));

            if (files == null)
                throw new ArgumentNullException(nameof(files));

            if (documentId.IsSet && documentId.Value == null)
                throw new ArgumentNullException(nameof(documentId));

            if (index.IsSet && index.Value == null)
                throw new ArgumentNullException(nameof(index));

            if (pipeline.IsSet && pipeline.Value == null)
                throw new ArgumentNullException(nameof(pipeline));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="documentId2"></param>
        /// <param name="files"></param>
        /// <param name="documentId"></param>
        /// <param name="index"></param>
        /// <param name="pipeline"></param>
        /// <param name="webHookUrl"></param>
        /// <param name="embeddingModel"></param>
        /// <param name="index2"></param>
        /// <param name="webHookUrl2"></param>
        /// <param name="embeddingModelName"></param>
        /// <param name="context"></param>
        /// <param name="tags"></param>
        /// <param name="ingestionPipeline"></param>
        /// <param name="languageAutoDetection"></param>
        /// <param name="language"></param>
        private void AfterSemanticSearchFileIngestionDefaultImplementation(ISemanticSearchFileIngestionApiResponse apiResponseLocalVar, string documentId2, List<System.IO.Stream> files, Option<string> documentId, Option<string> index, Option<List<string>> pipeline, Option<string?> webHookUrl, Option<string?> embeddingModel, Option<string?> index2, Option<string?> webHookUrl2, Option<string?> embeddingModelName, Option<Dictionary<string, string>?> context, Option<Dictionary<string, List<string>>?> tags, Option<List<string>?> ingestionPipeline, Option<bool> languageAutoDetection, Option<string?> language)
        {
            bool suppressDefaultLog = false;
            AfterSemanticSearchFileIngestion(ref suppressDefaultLog, apiResponseLocalVar, documentId2, files, documentId, index, pipeline, webHookUrl, embeddingModel, index2, webHookUrl2, embeddingModelName, context, tags, ingestionPipeline, languageAutoDetection, language);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="documentId2"></param>
        /// <param name="files"></param>
        /// <param name="documentId"></param>
        /// <param name="index"></param>
        /// <param name="pipeline"></param>
        /// <param name="webHookUrl"></param>
        /// <param name="embeddingModel"></param>
        /// <param name="index2"></param>
        /// <param name="webHookUrl2"></param>
        /// <param name="embeddingModelName"></param>
        /// <param name="context"></param>
        /// <param name="tags"></param>
        /// <param name="ingestionPipeline"></param>
        /// <param name="languageAutoDetection"></param>
        /// <param name="language"></param>
        partial void AfterSemanticSearchFileIngestion(ref bool suppressDefaultLog, ISemanticSearchFileIngestionApiResponse apiResponseLocalVar, string documentId2, List<System.IO.Stream> files, Option<string> documentId, Option<string> index, Option<List<string>> pipeline, Option<string?> webHookUrl, Option<string?> embeddingModel, Option<string?> index2, Option<string?> webHookUrl2, Option<string?> embeddingModelName, Option<Dictionary<string, string>?> context, Option<Dictionary<string, List<string>>?> tags, Option<List<string>?> ingestionPipeline, Option<bool> languageAutoDetection, Option<string?> language);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="documentId2"></param>
        /// <param name="files"></param>
        /// <param name="documentId"></param>
        /// <param name="index"></param>
        /// <param name="pipeline"></param>
        /// <param name="webHookUrl"></param>
        /// <param name="embeddingModel"></param>
        /// <param name="index2"></param>
        /// <param name="webHookUrl2"></param>
        /// <param name="embeddingModelName"></param>
        /// <param name="context"></param>
        /// <param name="tags"></param>
        /// <param name="ingestionPipeline"></param>
        /// <param name="languageAutoDetection"></param>
        /// <param name="language"></param>
        private void OnErrorSemanticSearchFileIngestionDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string documentId2, List<System.IO.Stream> files, Option<string> documentId, Option<string> index, Option<List<string>> pipeline, Option<string?> webHookUrl, Option<string?> embeddingModel, Option<string?> index2, Option<string?> webHookUrl2, Option<string?> embeddingModelName, Option<Dictionary<string, string>?> context, Option<Dictionary<string, List<string>>?> tags, Option<List<string>?> ingestionPipeline, Option<bool> languageAutoDetection, Option<string?> language)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorSemanticSearchFileIngestion(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, documentId2, files, documentId, index, pipeline, webHookUrl, embeddingModel, index2, webHookUrl2, embeddingModelName, context, tags, ingestionPipeline, languageAutoDetection, language);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="documentId2"></param>
        /// <param name="files"></param>
        /// <param name="documentId"></param>
        /// <param name="index"></param>
        /// <param name="pipeline"></param>
        /// <param name="webHookUrl"></param>
        /// <param name="embeddingModel"></param>
        /// <param name="index2"></param>
        /// <param name="webHookUrl2"></param>
        /// <param name="embeddingModelName"></param>
        /// <param name="context"></param>
        /// <param name="tags"></param>
        /// <param name="ingestionPipeline"></param>
        /// <param name="languageAutoDetection"></param>
        /// <param name="language"></param>
        partial void OnErrorSemanticSearchFileIngestion(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string documentId2, List<System.IO.Stream> files, Option<string> documentId, Option<string> index, Option<List<string>> pipeline, Option<string?> webHookUrl, Option<string?> embeddingModel, Option<string?> index2, Option<string?> webHookUrl2, Option<string?> embeddingModelName, Option<Dictionary<string, string>?> context, Option<Dictionary<string, List<string>>?> tags, Option<List<string>?> ingestionPipeline, Option<bool> languageAutoDetection, Option<string?> language);

        /// <summary>
        /// Ingest a File into Semantic Search Uploads and ingests a file document into the semantic search index. Supports optional configuration of index, ingestion pipeline, embedding model, and webhook for processing status.
        /// </summary>
        /// <param name="documentId2">Unique identifier for the document to ingest.</param>
        /// <param name="files">A collection of files to be ingested. Must contain at least one file.</param>
        /// <param name="documentId">A unique identifier for the document within the index. Documents with the same ID will be overwritten. (optional)</param>
        /// <param name="index">The name of the index where the document will be ingested. Defaults to &#39;default&#39; if not specified. (optional)</param>
        /// <param name="pipeline">An array of ingestion pipeline step names. If not provided, server default steps will be used. (optional)</param>
        /// <param name="webHookUrl">A URL to receive a callback via webhook when the ingestion process is completed or fails. (optional)</param>
        /// <param name="embeddingModel">The embedding model to use during ingestion. If not specified, the server&#39;s default model will be applied. (optional)</param>
        /// <param name="index2">Optional index name where the document will be stored. (optional)</param>
        /// <param name="webHookUrl2">Optional webhook URL to notify upon completion. (optional)</param>
        /// <param name="embeddingModelName">Optional name of the embedding model to use during ingestion. (optional)</param>
        /// <param name="context">Optional key-value pairs for additional context or metadata. (optional)</param>
        /// <param name="tags">A collection of tags associated with the document. Tags can be language-specific. (optional)</param>
        /// <param name="ingestionPipeline">Optional list of ingestion pipeline steps. Allows custom processing. (optional)</param>
        /// <param name="languageAutoDetection">Enable automatic language detection for document content. (optional, default to false)</param>
        /// <param name="language">Force a specific language for full-text search. Use &#39;simple&#39; for no language or leave empty. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISemanticSearchFileIngestionApiResponse"/>&gt;</returns>
        public async Task<ISemanticSearchFileIngestionApiResponse?> SemanticSearchFileIngestionOrDefaultAsync(string documentId2, List<System.IO.Stream> files, Option<string> documentId = default, Option<string> index = default, Option<List<string>> pipeline = default, Option<string?> webHookUrl = default, Option<string?> embeddingModel = default, Option<string?> index2 = default, Option<string?> webHookUrl2 = default, Option<string?> embeddingModelName = default, Option<Dictionary<string, string>?> context = default, Option<Dictionary<string, List<string>>?> tags = default, Option<List<string>?> ingestionPipeline = default, Option<bool> languageAutoDetection = default, Option<string?> language = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await SemanticSearchFileIngestionAsync(documentId2, files, documentId, index, pipeline, webHookUrl, embeddingModel, index2, webHookUrl2, embeddingModelName, context, tags, ingestionPipeline, languageAutoDetection, language, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Ingest a File into Semantic Search Uploads and ingests a file document into the semantic search index. Supports optional configuration of index, ingestion pipeline, embedding model, and webhook for processing status.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="documentId2">Unique identifier for the document to ingest.</param>
        /// <param name="files">A collection of files to be ingested. Must contain at least one file.</param>
        /// <param name="documentId">A unique identifier for the document within the index. Documents with the same ID will be overwritten. (optional)</param>
        /// <param name="index">The name of the index where the document will be ingested. Defaults to &#39;default&#39; if not specified. (optional)</param>
        /// <param name="pipeline">An array of ingestion pipeline step names. If not provided, server default steps will be used. (optional)</param>
        /// <param name="webHookUrl">A URL to receive a callback via webhook when the ingestion process is completed or fails. (optional)</param>
        /// <param name="embeddingModel">The embedding model to use during ingestion. If not specified, the server&#39;s default model will be applied. (optional)</param>
        /// <param name="index2">Optional index name where the document will be stored. (optional)</param>
        /// <param name="webHookUrl2">Optional webhook URL to notify upon completion. (optional)</param>
        /// <param name="embeddingModelName">Optional name of the embedding model to use during ingestion. (optional)</param>
        /// <param name="context">Optional key-value pairs for additional context or metadata. (optional)</param>
        /// <param name="tags">A collection of tags associated with the document. Tags can be language-specific. (optional)</param>
        /// <param name="ingestionPipeline">Optional list of ingestion pipeline steps. Allows custom processing. (optional)</param>
        /// <param name="languageAutoDetection">Enable automatic language detection for document content. (optional, default to false)</param>
        /// <param name="language">Force a specific language for full-text search. Use &#39;simple&#39; for no language or leave empty. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISemanticSearchFileIngestionApiResponse"/>&gt;</returns>
        public async Task<ISemanticSearchFileIngestionApiResponse> SemanticSearchFileIngestionAsync(string documentId2, List<System.IO.Stream> files, Option<string> documentId = default, Option<string> index = default, Option<List<string>> pipeline = default, Option<string?> webHookUrl = default, Option<string?> embeddingModel = default, Option<string?> index2 = default, Option<string?> webHookUrl2 = default, Option<string?> embeddingModelName = default, Option<Dictionary<string, string>?> context = default, Option<Dictionary<string, List<string>>?> tags = default, Option<List<string>?> ingestionPipeline = default, Option<bool> languageAutoDetection = default, Option<string?> language = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateSemanticSearchFileIngestion(documentId2, files, documentId, index, pipeline);

                FormatSemanticSearchFileIngestion(ref documentId2, files, ref documentId, ref index, pipeline, ref webHookUrl, ref embeddingModel, ref index2, ref webHookUrl2, ref embeddingModelName, context, tags, ingestionPipeline, ref languageAutoDetection, ref language);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/api/ingest/file";

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (documentId.IsSet)
                        parseQueryStringLocalVar["documentId"] = ClientUtils.ParameterToString(documentId.Value);

                    if (index.IsSet)
                        parseQueryStringLocalVar["index"] = ClientUtils.ParameterToString(index.Value);

                    if (pipeline.IsSet)
                        parseQueryStringLocalVar["pipeline"] = ClientUtils.ParameterToString(pipeline.Value);

                    if (webHookUrl.IsSet)
                        parseQueryStringLocalVar["webHookUrl"] = ClientUtils.ParameterToString(webHookUrl.Value);

                    if (embeddingModel.IsSet)
                        parseQueryStringLocalVar["embeddingModel"] = ClientUtils.ParameterToString(embeddingModel.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    MultipartContent multipartContentLocalVar = new MultipartContent();

                    httpRequestMessageLocalVar.Content = multipartContentLocalVar;

                    List<KeyValuePair<string?, string?>> formParameterLocalVars = new List<KeyValuePair<string?, string?>>();

                    multipartContentLocalVar.Add(new FormUrlEncodedContent(formParameterLocalVars));

                    formParameterLocalVars.Add(new KeyValuePair<string?, string?>("documentId", ClientUtils.ParameterToString(documentId2)));

                    multipartContentLocalVar.Add(new StreamContent(files));

                    if (index2.IsSet)
                        formParameterLocalVars.Add(new KeyValuePair<string?, string?>("index", ClientUtils.ParameterToString(index2.Value)));

                    if (webHookUrl2.IsSet)
                        formParameterLocalVars.Add(new KeyValuePair<string?, string?>("webHookUrl", ClientUtils.ParameterToString(webHookUrl2.Value)));

                    if (embeddingModelName.IsSet)
                        formParameterLocalVars.Add(new KeyValuePair<string?, string?>("embeddingModelName", ClientUtils.ParameterToString(embeddingModelName.Value)));

                    if (context.IsSet)
                        formParameterLocalVars.Add(new KeyValuePair<string?, string?>("context", ClientUtils.ParameterToString(context.Value)));

                    if (tags.IsSet)
                        formParameterLocalVars.Add(new KeyValuePair<string?, string?>("tags", ClientUtils.ParameterToString(tags.Value)));

                    if (ingestionPipeline.IsSet)
                        formParameterLocalVars.Add(new KeyValuePair<string?, string?>("ingestionPipeline", ClientUtils.ParameterToString(ingestionPipeline.Value)));

                    if (languageAutoDetection.IsSet)
                        formParameterLocalVars.Add(new KeyValuePair<string?, string?>("languageAutoDetection", ClientUtils.ParameterToString(languageAutoDetection.Value)));

                    if (language.IsSet)
                        formParameterLocalVars.Add(new KeyValuePair<string?, string?>("language", ClientUtils.ParameterToString(language.Value)));

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] contentTypes = new string[] {
                        "multipart/form-data",
                        "application/x-www-form-urlencoded"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json",
                        "application/problem+json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<SemanticSearchFileIngestionApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<SemanticSearchFileIngestionApiResponse>();

                        SemanticSearchFileIngestionApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/ingest/file", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterSemanticSearchFileIngestionDefaultImplementation(apiResponseLocalVar, documentId2, files, documentId, index, pipeline, webHookUrl, embeddingModel, index2, webHookUrl2, embeddingModelName, context, tags, ingestionPipeline, languageAutoDetection, language);

                        Events.ExecuteOnSemanticSearchFileIngestion(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorSemanticSearchFileIngestionDefaultImplementation(e, "/api/ingest/file", uriBuilderLocalVar.Path, documentId2, files, documentId, index, pipeline, webHookUrl, embeddingModel, index2, webHookUrl2, embeddingModelName, context, tags, ingestionPipeline, languageAutoDetection, language);
                Events.ExecuteOnErrorSemanticSearchFileIngestion(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="SemanticSearchFileIngestionApiResponse"/>
        /// </summary>
        public partial class SemanticSearchFileIngestionApiResponse : Org.OpenAPITools.Client.ApiResponse, ISemanticSearchFileIngestionApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<SemanticSearchFileIngestionApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="SemanticSearchFileIngestionApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public SemanticSearchFileIngestionApiResponse(ILogger<SemanticSearchFileIngestionApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public bool IsCreated => 201 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.IngestDocumentResponse? Created()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsCreated
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.IngestDocumentResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 201 Created and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryCreated([NotNullWhen(true)]out Org.OpenAPITools.Model.IngestDocumentResponse? result)
            {
                result = null;

                try
                {
                    result = Created();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)201);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.HttpValidationProblemDetails? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.HttpValidationProblemDetails>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out Org.OpenAPITools.Model.HttpValidationProblemDetails? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 429 TooManyRequests
            /// </summary>
            /// <returns></returns>
            public bool IsTooManyRequests => 429 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 429 TooManyRequests
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.ProblemDetails? TooManyRequests()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsTooManyRequests
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.ProblemDetails>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 429 TooManyRequests and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryTooManyRequests([NotNullWhen(true)]out Org.OpenAPITools.Model.ProblemDetails? result)
            {
                result = null;

                try
                {
                    result = TooManyRequests();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)429);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.ProblemDetails? InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.ProblemDetails>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out Org.OpenAPITools.Model.ProblemDetails? result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatSemanticSearchIngestionStatus(ref Guid id);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        private void AfterSemanticSearchIngestionStatusDefaultImplementation(ISemanticSearchIngestionStatusApiResponse apiResponseLocalVar, Guid id)
        {
            bool suppressDefaultLog = false;
            AfterSemanticSearchIngestionStatus(ref suppressDefaultLog, apiResponseLocalVar, id);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        partial void AfterSemanticSearchIngestionStatus(ref bool suppressDefaultLog, ISemanticSearchIngestionStatusApiResponse apiResponseLocalVar, Guid id);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        private void OnErrorSemanticSearchIngestionStatusDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid id)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorSemanticSearchIngestionStatus(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, id);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        partial void OnErrorSemanticSearchIngestionStatus(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid id);

        /// <summary>
        ///  Get queue status for ingestion job
        /// </summary>
        /// <param name="id"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISemanticSearchIngestionStatusApiResponse"/>&gt;</returns>
        public async Task<ISemanticSearchIngestionStatusApiResponse?> SemanticSearchIngestionStatusOrDefaultAsync(Guid id, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await SemanticSearchIngestionStatusAsync(id, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        ///  Get queue status for ingestion job
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISemanticSearchIngestionStatusApiResponse"/>&gt;</returns>
        public async Task<ISemanticSearchIngestionStatusApiResponse> SemanticSearchIngestionStatusAsync(Guid id, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatSemanticSearchIngestionStatus(ref id);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/api/ingest/status";

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["id"] = ClientUtils.ParameterToString(id);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json",
                        "application/problem+json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<SemanticSearchIngestionStatusApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<SemanticSearchIngestionStatusApiResponse>();

                        SemanticSearchIngestionStatusApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/ingest/status", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterSemanticSearchIngestionStatusDefaultImplementation(apiResponseLocalVar, id);

                        Events.ExecuteOnSemanticSearchIngestionStatus(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorSemanticSearchIngestionStatusDefaultImplementation(e, "/api/ingest/status", uriBuilderLocalVar.Path, id);
                Events.ExecuteOnErrorSemanticSearchIngestionStatus(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="SemanticSearchIngestionStatusApiResponse"/>
        /// </summary>
        public partial class SemanticSearchIngestionStatusApiResponse : Org.OpenAPITools.Client.ApiResponse, ISemanticSearchIngestionStatusApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<SemanticSearchIngestionStatusApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="SemanticSearchIngestionStatusApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public SemanticSearchIngestionStatusApiResponse(ILogger<SemanticSearchIngestionStatusApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.DataPipelineStatus? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.DataPipelineStatus>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.DataPipelineStatus? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.HttpValidationProblemDetails? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.HttpValidationProblemDetails>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out Org.OpenAPITools.Model.HttpValidationProblemDetails? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.ProblemDetails? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.ProblemDetails>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out Org.OpenAPITools.Model.ProblemDetails? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 429 TooManyRequests
            /// </summary>
            /// <returns></returns>
            public bool IsTooManyRequests => 429 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 429 TooManyRequests
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.ProblemDetails? TooManyRequests()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsTooManyRequests
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.ProblemDetails>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 429 TooManyRequests and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryTooManyRequests([NotNullWhen(true)]out Org.OpenAPITools.Model.ProblemDetails? result)
            {
                result = null;

                try
                {
                    result = TooManyRequests();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)429);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.ProblemDetails? InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.ProblemDetails>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out Org.OpenAPITools.Model.ProblemDetails? result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatSemanticSearchList(ListDocumentParameters listDocumentParameters);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="listDocumentParameters"></param>
        /// <returns></returns>
        private void ValidateSemanticSearchList(ListDocumentParameters listDocumentParameters)
        {
            if (listDocumentParameters == null)
                throw new ArgumentNullException(nameof(listDocumentParameters));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="listDocumentParameters"></param>
        private void AfterSemanticSearchListDefaultImplementation(ISemanticSearchListApiResponse apiResponseLocalVar, ListDocumentParameters listDocumentParameters)
        {
            bool suppressDefaultLog = false;
            AfterSemanticSearchList(ref suppressDefaultLog, apiResponseLocalVar, listDocumentParameters);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="listDocumentParameters"></param>
        partial void AfterSemanticSearchList(ref bool suppressDefaultLog, ISemanticSearchListApiResponse apiResponseLocalVar, ListDocumentParameters listDocumentParameters);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="listDocumentParameters"></param>
        private void OnErrorSemanticSearchListDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, ListDocumentParameters listDocumentParameters)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorSemanticSearchList(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, listDocumentParameters);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="listDocumentParameters"></param>
        partial void OnErrorSemanticSearchList(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, ListDocumentParameters listDocumentParameters);

        /// <summary>
        ///  List - and filter - for ingested documents
        /// </summary>
        /// <param name="listDocumentParameters"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISemanticSearchListApiResponse"/>&gt;</returns>
        public async Task<ISemanticSearchListApiResponse?> SemanticSearchListOrDefaultAsync(ListDocumentParameters listDocumentParameters, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await SemanticSearchListAsync(listDocumentParameters, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        ///  List - and filter - for ingested documents
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="listDocumentParameters"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISemanticSearchListApiResponse"/>&gt;</returns>
        public async Task<ISemanticSearchListApiResponse> SemanticSearchListAsync(ListDocumentParameters listDocumentParameters, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateSemanticSearchList(listDocumentParameters);

                FormatSemanticSearchList(listDocumentParameters);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/api/semantic/list";

                    httpRequestMessageLocalVar.Content = (listDocumentParameters as object) is System.IO.Stream stream
                        ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                        : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(listDocumentParameters, _jsonSerializerOptions));

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json",
                        "application/problem+json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<SemanticSearchListApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<SemanticSearchListApiResponse>();

                        SemanticSearchListApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/semantic/list", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterSemanticSearchListDefaultImplementation(apiResponseLocalVar, listDocumentParameters);

                        Events.ExecuteOnSemanticSearchList(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorSemanticSearchListDefaultImplementation(e, "/api/semantic/list", uriBuilderLocalVar.Path, listDocumentParameters);
                Events.ExecuteOnErrorSemanticSearchList(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="SemanticSearchListApiResponse"/>
        /// </summary>
        public partial class SemanticSearchListApiResponse : Org.OpenAPITools.Client.ApiResponse, ISemanticSearchListApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<SemanticSearchListApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="SemanticSearchListApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public SemanticSearchListApiResponse(ILogger<SemanticSearchListApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.ListDocumentResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.ListDocumentResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.ListDocumentResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.HttpValidationProblemDetails? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.HttpValidationProblemDetails>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out Org.OpenAPITools.Model.HttpValidationProblemDetails? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 429 TooManyRequests
            /// </summary>
            /// <returns></returns>
            public bool IsTooManyRequests => 429 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 429 TooManyRequests
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.ProblemDetails? TooManyRequests()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsTooManyRequests
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.ProblemDetails>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 429 TooManyRequests and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryTooManyRequests([NotNullWhen(true)]out Org.OpenAPITools.Model.ProblemDetails? result)
            {
                result = null;

                try
                {
                    result = TooManyRequests();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)429);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.ProblemDetails? InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.ProblemDetails>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out Org.OpenAPITools.Model.ProblemDetails? result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatSemanticSearchQuery(QueryDocumentRequest queryDocumentRequest);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="queryDocumentRequest"></param>
        /// <returns></returns>
        private void ValidateSemanticSearchQuery(QueryDocumentRequest queryDocumentRequest)
        {
            if (queryDocumentRequest == null)
                throw new ArgumentNullException(nameof(queryDocumentRequest));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="queryDocumentRequest"></param>
        private void AfterSemanticSearchQueryDefaultImplementation(ISemanticSearchQueryApiResponse apiResponseLocalVar, QueryDocumentRequest queryDocumentRequest)
        {
            bool suppressDefaultLog = false;
            AfterSemanticSearchQuery(ref suppressDefaultLog, apiResponseLocalVar, queryDocumentRequest);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="queryDocumentRequest"></param>
        partial void AfterSemanticSearchQuery(ref bool suppressDefaultLog, ISemanticSearchQueryApiResponse apiResponseLocalVar, QueryDocumentRequest queryDocumentRequest);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="queryDocumentRequest"></param>
        private void OnErrorSemanticSearchQueryDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, QueryDocumentRequest queryDocumentRequest)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorSemanticSearchQuery(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, queryDocumentRequest);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="queryDocumentRequest"></param>
        partial void OnErrorSemanticSearchQuery(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, QueryDocumentRequest queryDocumentRequest);

        /// <summary>
        ///  Performs semantic or hybrid search over previously ingested data.
        /// </summary>
        /// <param name="queryDocumentRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISemanticSearchQueryApiResponse"/>&gt;</returns>
        public async Task<ISemanticSearchQueryApiResponse?> SemanticSearchQueryOrDefaultAsync(QueryDocumentRequest queryDocumentRequest, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await SemanticSearchQueryAsync(queryDocumentRequest, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        ///  Performs semantic or hybrid search over previously ingested data.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="queryDocumentRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISemanticSearchQueryApiResponse"/>&gt;</returns>
        public async Task<ISemanticSearchQueryApiResponse> SemanticSearchQueryAsync(QueryDocumentRequest queryDocumentRequest, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateSemanticSearchQuery(queryDocumentRequest);

                FormatSemanticSearchQuery(queryDocumentRequest);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/api/semantic/query";

                    httpRequestMessageLocalVar.Content = (queryDocumentRequest as object) is System.IO.Stream stream
                        ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                        : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(queryDocumentRequest, _jsonSerializerOptions));

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json",
                        "application/problem+json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<SemanticSearchQueryApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<SemanticSearchQueryApiResponse>();

                        SemanticSearchQueryApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/semantic/query", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterSemanticSearchQueryDefaultImplementation(apiResponseLocalVar, queryDocumentRequest);

                        Events.ExecuteOnSemanticSearchQuery(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorSemanticSearchQueryDefaultImplementation(e, "/api/semantic/query", uriBuilderLocalVar.Path, queryDocumentRequest);
                Events.ExecuteOnErrorSemanticSearchQuery(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="SemanticSearchQueryApiResponse"/>
        /// </summary>
        public partial class SemanticSearchQueryApiResponse : Org.OpenAPITools.Client.ApiResponse, ISemanticSearchQueryApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<SemanticSearchQueryApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="SemanticSearchQueryApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public SemanticSearchQueryApiResponse(ILogger<SemanticSearchQueryApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.QueryDocumentResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.QueryDocumentResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.QueryDocumentResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.HttpValidationProblemDetails? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.HttpValidationProblemDetails>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out Org.OpenAPITools.Model.HttpValidationProblemDetails? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 429 TooManyRequests
            /// </summary>
            /// <returns></returns>
            public bool IsTooManyRequests => 429 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 429 TooManyRequests
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.ProblemDetails? TooManyRequests()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsTooManyRequests
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.ProblemDetails>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 429 TooManyRequests and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryTooManyRequests([NotNullWhen(true)]out Org.OpenAPITools.Model.ProblemDetails? result)
            {
                result = null;

                try
                {
                    result = TooManyRequests();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)429);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.ProblemDetails? InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.ProblemDetails>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out Org.OpenAPITools.Model.ProblemDetails? result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatSemanticSearchQueryResultsClustering(SemanticSearchQueryResultsClusteringRequest semanticSearchQueryResultsClusteringRequest);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="semanticSearchQueryResultsClusteringRequest"></param>
        /// <returns></returns>
        private void ValidateSemanticSearchQueryResultsClustering(SemanticSearchQueryResultsClusteringRequest semanticSearchQueryResultsClusteringRequest)
        {
            if (semanticSearchQueryResultsClusteringRequest == null)
                throw new ArgumentNullException(nameof(semanticSearchQueryResultsClusteringRequest));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="semanticSearchQueryResultsClusteringRequest"></param>
        private void AfterSemanticSearchQueryResultsClusteringDefaultImplementation(ISemanticSearchQueryResultsClusteringApiResponse apiResponseLocalVar, SemanticSearchQueryResultsClusteringRequest semanticSearchQueryResultsClusteringRequest)
        {
            bool suppressDefaultLog = false;
            AfterSemanticSearchQueryResultsClustering(ref suppressDefaultLog, apiResponseLocalVar, semanticSearchQueryResultsClusteringRequest);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="semanticSearchQueryResultsClusteringRequest"></param>
        partial void AfterSemanticSearchQueryResultsClustering(ref bool suppressDefaultLog, ISemanticSearchQueryResultsClusteringApiResponse apiResponseLocalVar, SemanticSearchQueryResultsClusteringRequest semanticSearchQueryResultsClusteringRequest);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="semanticSearchQueryResultsClusteringRequest"></param>
        private void OnErrorSemanticSearchQueryResultsClusteringDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, SemanticSearchQueryResultsClusteringRequest semanticSearchQueryResultsClusteringRequest)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorSemanticSearchQueryResultsClustering(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, semanticSearchQueryResultsClusteringRequest);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="semanticSearchQueryResultsClusteringRequest"></param>
        partial void OnErrorSemanticSearchQueryResultsClustering(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, SemanticSearchQueryResultsClusteringRequest semanticSearchQueryResultsClusteringRequest);

        /// <summary>
        ///  Perform k-means clustering over semantic search log entries
        /// </summary>
        /// <param name="semanticSearchQueryResultsClusteringRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISemanticSearchQueryResultsClusteringApiResponse"/>&gt;</returns>
        public async Task<ISemanticSearchQueryResultsClusteringApiResponse?> SemanticSearchQueryResultsClusteringOrDefaultAsync(SemanticSearchQueryResultsClusteringRequest semanticSearchQueryResultsClusteringRequest, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await SemanticSearchQueryResultsClusteringAsync(semanticSearchQueryResultsClusteringRequest, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        ///  Perform k-means clustering over semantic search log entries
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="semanticSearchQueryResultsClusteringRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISemanticSearchQueryResultsClusteringApiResponse"/>&gt;</returns>
        public async Task<ISemanticSearchQueryResultsClusteringApiResponse> SemanticSearchQueryResultsClusteringAsync(SemanticSearchQueryResultsClusteringRequest semanticSearchQueryResultsClusteringRequest, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateSemanticSearchQueryResultsClustering(semanticSearchQueryResultsClusteringRequest);

                FormatSemanticSearchQueryResultsClustering(semanticSearchQueryResultsClusteringRequest);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/api/semantic/query-results-clustering";

                    httpRequestMessageLocalVar.Content = (semanticSearchQueryResultsClusteringRequest as object) is System.IO.Stream stream
                        ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                        : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(semanticSearchQueryResultsClusteringRequest, _jsonSerializerOptions));

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json",
                        "text/csv",
                        "application/problem+json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<SemanticSearchQueryResultsClusteringApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<SemanticSearchQueryResultsClusteringApiResponse>();

                        SemanticSearchQueryResultsClusteringApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/semantic/query-results-clustering", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterSemanticSearchQueryResultsClusteringDefaultImplementation(apiResponseLocalVar, semanticSearchQueryResultsClusteringRequest);

                        Events.ExecuteOnSemanticSearchQueryResultsClustering(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorSemanticSearchQueryResultsClusteringDefaultImplementation(e, "/api/semantic/query-results-clustering", uriBuilderLocalVar.Path, semanticSearchQueryResultsClusteringRequest);
                Events.ExecuteOnErrorSemanticSearchQueryResultsClustering(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="SemanticSearchQueryResultsClusteringApiResponse"/>
        /// </summary>
        public partial class SemanticSearchQueryResultsClusteringApiResponse : Org.OpenAPITools.Client.ApiResponse, ISemanticSearchQueryResultsClusteringApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<SemanticSearchQueryResultsClusteringApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="SemanticSearchQueryResultsClusteringApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public SemanticSearchQueryResultsClusteringApiResponse(ILogger<SemanticSearchQueryResultsClusteringApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.KMeansCluster? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.KMeansCluster>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.KMeansCluster? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.HttpValidationProblemDetails? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.HttpValidationProblemDetails>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out Org.OpenAPITools.Model.HttpValidationProblemDetails? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 429 TooManyRequests
            /// </summary>
            /// <returns></returns>
            public bool IsTooManyRequests => 429 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 429 TooManyRequests
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.ProblemDetails? TooManyRequests()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsTooManyRequests
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.ProblemDetails>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 429 TooManyRequests and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryTooManyRequests([NotNullWhen(true)]out Org.OpenAPITools.Model.ProblemDetails? result)
            {
                result = null;

                try
                {
                    result = TooManyRequests();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)429);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.ProblemDetails? InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.ProblemDetails>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out Org.OpenAPITools.Model.ProblemDetails? result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatSemanticSearchRerank(ReRankDocumentsRequest reRankDocumentsRequest);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="reRankDocumentsRequest"></param>
        /// <returns></returns>
        private void ValidateSemanticSearchRerank(ReRankDocumentsRequest reRankDocumentsRequest)
        {
            if (reRankDocumentsRequest == null)
                throw new ArgumentNullException(nameof(reRankDocumentsRequest));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="reRankDocumentsRequest"></param>
        private void AfterSemanticSearchRerankDefaultImplementation(ISemanticSearchRerankApiResponse apiResponseLocalVar, ReRankDocumentsRequest reRankDocumentsRequest)
        {
            bool suppressDefaultLog = false;
            AfterSemanticSearchRerank(ref suppressDefaultLog, apiResponseLocalVar, reRankDocumentsRequest);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="reRankDocumentsRequest"></param>
        partial void AfterSemanticSearchRerank(ref bool suppressDefaultLog, ISemanticSearchRerankApiResponse apiResponseLocalVar, ReRankDocumentsRequest reRankDocumentsRequest);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="reRankDocumentsRequest"></param>
        private void OnErrorSemanticSearchRerankDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, ReRankDocumentsRequest reRankDocumentsRequest)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorSemanticSearchRerank(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, reRankDocumentsRequest);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="reRankDocumentsRequest"></param>
        partial void OnErrorSemanticSearchRerank(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, ReRankDocumentsRequest reRankDocumentsRequest);

        /// <summary>
        ///  Rerank documents
        /// </summary>
        /// <param name="reRankDocumentsRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISemanticSearchRerankApiResponse"/>&gt;</returns>
        public async Task<ISemanticSearchRerankApiResponse?> SemanticSearchRerankOrDefaultAsync(ReRankDocumentsRequest reRankDocumentsRequest, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await SemanticSearchRerankAsync(reRankDocumentsRequest, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        ///  Rerank documents
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="reRankDocumentsRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISemanticSearchRerankApiResponse"/>&gt;</returns>
        public async Task<ISemanticSearchRerankApiResponse> SemanticSearchRerankAsync(ReRankDocumentsRequest reRankDocumentsRequest, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateSemanticSearchRerank(reRankDocumentsRequest);

                FormatSemanticSearchRerank(reRankDocumentsRequest);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/api/semantic/rerank";

                    httpRequestMessageLocalVar.Content = (reRankDocumentsRequest as object) is System.IO.Stream stream
                        ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                        : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(reRankDocumentsRequest, _jsonSerializerOptions));

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json",
                        "application/problem+json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<SemanticSearchRerankApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<SemanticSearchRerankApiResponse>();

                        SemanticSearchRerankApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/semantic/rerank", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterSemanticSearchRerankDefaultImplementation(apiResponseLocalVar, reRankDocumentsRequest);

                        Events.ExecuteOnSemanticSearchRerank(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorSemanticSearchRerankDefaultImplementation(e, "/api/semantic/rerank", uriBuilderLocalVar.Path, reRankDocumentsRequest);
                Events.ExecuteOnErrorSemanticSearchRerank(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="SemanticSearchRerankApiResponse"/>
        /// </summary>
        public partial class SemanticSearchRerankApiResponse : Org.OpenAPITools.Client.ApiResponse, ISemanticSearchRerankApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<SemanticSearchRerankApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="SemanticSearchRerankApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public SemanticSearchRerankApiResponse(ILogger<SemanticSearchRerankApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.ReRankDocumentsResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.ReRankDocumentsResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.ReRankDocumentsResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.HttpValidationProblemDetails? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.HttpValidationProblemDetails>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out Org.OpenAPITools.Model.HttpValidationProblemDetails? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 429 TooManyRequests
            /// </summary>
            /// <returns></returns>
            public bool IsTooManyRequests => 429 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 429 TooManyRequests
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.ProblemDetails? TooManyRequests()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsTooManyRequests
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.ProblemDetails>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 429 TooManyRequests and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryTooManyRequests([NotNullWhen(true)]out Org.OpenAPITools.Model.ProblemDetails? result)
            {
                result = null;

                try
                {
                    result = TooManyRequests();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)429);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.ProblemDetails? InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.ProblemDetails>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out Org.OpenAPITools.Model.ProblemDetails? result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatSemanticSearchTextIngestion(IngestTextDocumentRequest ingestTextDocumentRequest);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="ingestTextDocumentRequest"></param>
        /// <returns></returns>
        private void ValidateSemanticSearchTextIngestion(IngestTextDocumentRequest ingestTextDocumentRequest)
        {
            if (ingestTextDocumentRequest == null)
                throw new ArgumentNullException(nameof(ingestTextDocumentRequest));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="ingestTextDocumentRequest"></param>
        private void AfterSemanticSearchTextIngestionDefaultImplementation(ISemanticSearchTextIngestionApiResponse apiResponseLocalVar, IngestTextDocumentRequest ingestTextDocumentRequest)
        {
            bool suppressDefaultLog = false;
            AfterSemanticSearchTextIngestion(ref suppressDefaultLog, apiResponseLocalVar, ingestTextDocumentRequest);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="ingestTextDocumentRequest"></param>
        partial void AfterSemanticSearchTextIngestion(ref bool suppressDefaultLog, ISemanticSearchTextIngestionApiResponse apiResponseLocalVar, IngestTextDocumentRequest ingestTextDocumentRequest);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="ingestTextDocumentRequest"></param>
        private void OnErrorSemanticSearchTextIngestionDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, IngestTextDocumentRequest ingestTextDocumentRequest)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorSemanticSearchTextIngestion(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, ingestTextDocumentRequest);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="ingestTextDocumentRequest"></param>
        partial void OnErrorSemanticSearchTextIngestion(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, IngestTextDocumentRequest ingestTextDocumentRequest);

        /// <summary>
        /// Ingest Plain Text for Semantic Search Ingests a plain text document into the semantic search index. This endpoint allows associating tags and specifying the target index for enhanced search capabilities.
        /// </summary>
        /// <param name="ingestTextDocumentRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISemanticSearchTextIngestionApiResponse"/>&gt;</returns>
        public async Task<ISemanticSearchTextIngestionApiResponse?> SemanticSearchTextIngestionOrDefaultAsync(IngestTextDocumentRequest ingestTextDocumentRequest, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await SemanticSearchTextIngestionAsync(ingestTextDocumentRequest, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Ingest Plain Text for Semantic Search Ingests a plain text document into the semantic search index. This endpoint allows associating tags and specifying the target index for enhanced search capabilities.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="ingestTextDocumentRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISemanticSearchTextIngestionApiResponse"/>&gt;</returns>
        public async Task<ISemanticSearchTextIngestionApiResponse> SemanticSearchTextIngestionAsync(IngestTextDocumentRequest ingestTextDocumentRequest, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateSemanticSearchTextIngestion(ingestTextDocumentRequest);

                FormatSemanticSearchTextIngestion(ingestTextDocumentRequest);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/api/ingest/text";

                    httpRequestMessageLocalVar.Content = (ingestTextDocumentRequest as object) is System.IO.Stream stream
                        ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                        : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(ingestTextDocumentRequest, _jsonSerializerOptions));

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json",
                        "application/problem+json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<SemanticSearchTextIngestionApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<SemanticSearchTextIngestionApiResponse>();

                        SemanticSearchTextIngestionApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/ingest/text", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterSemanticSearchTextIngestionDefaultImplementation(apiResponseLocalVar, ingestTextDocumentRequest);

                        Events.ExecuteOnSemanticSearchTextIngestion(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorSemanticSearchTextIngestionDefaultImplementation(e, "/api/ingest/text", uriBuilderLocalVar.Path, ingestTextDocumentRequest);
                Events.ExecuteOnErrorSemanticSearchTextIngestion(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="SemanticSearchTextIngestionApiResponse"/>
        /// </summary>
        public partial class SemanticSearchTextIngestionApiResponse : Org.OpenAPITools.Client.ApiResponse, ISemanticSearchTextIngestionApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<SemanticSearchTextIngestionApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="SemanticSearchTextIngestionApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public SemanticSearchTextIngestionApiResponse(ILogger<SemanticSearchTextIngestionApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public bool IsCreated => 201 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.IngestDocumentResponse? Created()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsCreated
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.IngestDocumentResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 201 Created and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryCreated([NotNullWhen(true)]out Org.OpenAPITools.Model.IngestDocumentResponse? result)
            {
                result = null;

                try
                {
                    result = Created();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)201);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.HttpValidationProblemDetails? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.HttpValidationProblemDetails>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out Org.OpenAPITools.Model.HttpValidationProblemDetails? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 429 TooManyRequests
            /// </summary>
            /// <returns></returns>
            public bool IsTooManyRequests => 429 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 429 TooManyRequests
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.ProblemDetails? TooManyRequests()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsTooManyRequests
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.ProblemDetails>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 429 TooManyRequests and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryTooManyRequests([NotNullWhen(true)]out Org.OpenAPITools.Model.ProblemDetails? result)
            {
                result = null;

                try
                {
                    result = TooManyRequests();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)429);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.ProblemDetails? InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.ProblemDetails>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out Org.OpenAPITools.Model.ProblemDetails? result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatSemanticSearchWebpageIngestion(IngestWebPageDocumentRequest ingestWebPageDocumentRequest);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="ingestWebPageDocumentRequest"></param>
        /// <returns></returns>
        private void ValidateSemanticSearchWebpageIngestion(IngestWebPageDocumentRequest ingestWebPageDocumentRequest)
        {
            if (ingestWebPageDocumentRequest == null)
                throw new ArgumentNullException(nameof(ingestWebPageDocumentRequest));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="ingestWebPageDocumentRequest"></param>
        private void AfterSemanticSearchWebpageIngestionDefaultImplementation(ISemanticSearchWebpageIngestionApiResponse apiResponseLocalVar, IngestWebPageDocumentRequest ingestWebPageDocumentRequest)
        {
            bool suppressDefaultLog = false;
            AfterSemanticSearchWebpageIngestion(ref suppressDefaultLog, apiResponseLocalVar, ingestWebPageDocumentRequest);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="ingestWebPageDocumentRequest"></param>
        partial void AfterSemanticSearchWebpageIngestion(ref bool suppressDefaultLog, ISemanticSearchWebpageIngestionApiResponse apiResponseLocalVar, IngestWebPageDocumentRequest ingestWebPageDocumentRequest);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="ingestWebPageDocumentRequest"></param>
        private void OnErrorSemanticSearchWebpageIngestionDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, IngestWebPageDocumentRequest ingestWebPageDocumentRequest)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorSemanticSearchWebpageIngestion(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, ingestWebPageDocumentRequest);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="ingestWebPageDocumentRequest"></param>
        partial void OnErrorSemanticSearchWebpageIngestion(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, IngestWebPageDocumentRequest ingestWebPageDocumentRequest);

        /// <summary>
        ///  Import web page text into semantic search
        /// </summary>
        /// <param name="ingestWebPageDocumentRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISemanticSearchWebpageIngestionApiResponse"/>&gt;</returns>
        public async Task<ISemanticSearchWebpageIngestionApiResponse?> SemanticSearchWebpageIngestionOrDefaultAsync(IngestWebPageDocumentRequest ingestWebPageDocumentRequest, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await SemanticSearchWebpageIngestionAsync(ingestWebPageDocumentRequest, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        ///  Import web page text into semantic search
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="ingestWebPageDocumentRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISemanticSearchWebpageIngestionApiResponse"/>&gt;</returns>
        public async Task<ISemanticSearchWebpageIngestionApiResponse> SemanticSearchWebpageIngestionAsync(IngestWebPageDocumentRequest ingestWebPageDocumentRequest, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateSemanticSearchWebpageIngestion(ingestWebPageDocumentRequest);

                FormatSemanticSearchWebpageIngestion(ingestWebPageDocumentRequest);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/api/ingest/webpage";

                    httpRequestMessageLocalVar.Content = (ingestWebPageDocumentRequest as object) is System.IO.Stream stream
                        ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                        : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(ingestWebPageDocumentRequest, _jsonSerializerOptions));

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json",
                        "application/problem+json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<SemanticSearchWebpageIngestionApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<SemanticSearchWebpageIngestionApiResponse>();

                        SemanticSearchWebpageIngestionApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/ingest/webpage", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterSemanticSearchWebpageIngestionDefaultImplementation(apiResponseLocalVar, ingestWebPageDocumentRequest);

                        Events.ExecuteOnSemanticSearchWebpageIngestion(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorSemanticSearchWebpageIngestionDefaultImplementation(e, "/api/ingest/webpage", uriBuilderLocalVar.Path, ingestWebPageDocumentRequest);
                Events.ExecuteOnErrorSemanticSearchWebpageIngestion(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="SemanticSearchWebpageIngestionApiResponse"/>
        /// </summary>
        public partial class SemanticSearchWebpageIngestionApiResponse : Org.OpenAPITools.Client.ApiResponse, ISemanticSearchWebpageIngestionApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<SemanticSearchWebpageIngestionApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="SemanticSearchWebpageIngestionApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public SemanticSearchWebpageIngestionApiResponse(ILogger<SemanticSearchWebpageIngestionApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public bool IsCreated => 201 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.IngestDocumentResponse? Created()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsCreated
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.IngestDocumentResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 201 Created and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryCreated([NotNullWhen(true)]out Org.OpenAPITools.Model.IngestDocumentResponse? result)
            {
                result = null;

                try
                {
                    result = Created();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)201);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.HttpValidationProblemDetails? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.HttpValidationProblemDetails>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out Org.OpenAPITools.Model.HttpValidationProblemDetails? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 429 TooManyRequests
            /// </summary>
            /// <returns></returns>
            public bool IsTooManyRequests => 429 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 429 TooManyRequests
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.ProblemDetails? TooManyRequests()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsTooManyRequests
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.ProblemDetails>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 429 TooManyRequests and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryTooManyRequests([NotNullWhen(true)]out Org.OpenAPITools.Model.ProblemDetails? result)
            {
                result = null;

                try
                {
                    result = TooManyRequests();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)429);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.ProblemDetails? InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.ProblemDetails>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out Org.OpenAPITools.Model.ProblemDetails? result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }
    }
}
