// <auto-generated>
/*
 * Studio - AI Empower Labs
 *
 * # Studio API Documentation  ## Introduction Welcome to Studio by AI Empower Labs API documentation! We are thrilled to offer developers around the world access to our cutting-edge artificial intelligence technology and semantic search. Our API is designed to empower your applications with state-of-the-art AI capabilities, including but not limited to natural language processing, audio transcription, embedding, and predictive analytics.  Our mission is to make AI technology accessible and easy to integrate, enabling you to enhance your applications, improve user experiences, and innovate in your field. Whether you're building complex systems, developing mobile apps, or creating web services, our API provides you with the tools you need to incorporate AI functionalities seamlessly.  Support and Feedback We are committed to providing exceptional support to our developer community. If you have any questions, encounter any issues, or have feedback on how we can improve our API, please don't hesitate to contact our support team @ support@AIEmpowerLabs.com.  Terms of Use Please review our terms of use and privacy policy before integrating our API into your application. By using our API, you agree to comply with these terms.
 *
 * The version of the OpenAPI document: v1
 * Contact: support@aiempowerlabs.com
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

#nullable enable

using System;
using System.Collections.Generic;
using System.Net;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text.Json;
using Org.OpenAPITools.Client;
using Org.OpenAPITools.Model;
using System.Diagnostics.CodeAnalysis;

namespace Org.OpenAPITools.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// This class is registered as transient.
    /// </summary>
    public interface IKernelMemoryApi : IApi
    {
        /// <summary>
        /// The class containing the events
        /// </summary>
        KernelMemoryApiEvents Events { get; }

        /// <summary>
        /// Query documents and forward result to LLM
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="memoryQuery"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IKernelMemoryAskApiResponse"/>&gt;</returns>
        Task<IKernelMemoryAskApiResponse> KernelMemoryAskAsync(MemoryQuery memoryQuery, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Query documents and forward result to LLM
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="memoryQuery"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IKernelMemoryAskApiResponse"/>?&gt;</returns>
        Task<IKernelMemoryAskApiResponse?> KernelMemoryAskOrDefaultAsync(MemoryQuery memoryQuery, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Delete document from specific index
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="documentId"></param>
        /// <param name="index"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IKernelMemoryDeleteApiResponse"/>&gt;</returns>
        Task<IKernelMemoryDeleteApiResponse> KernelMemoryDeleteAsync(string documentId, Option<string> index = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Delete document from specific index
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="documentId"></param>
        /// <param name="index"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IKernelMemoryDeleteApiResponse"/>?&gt;</returns>
        Task<IKernelMemoryDeleteApiResponse?> KernelMemoryDeleteOrDefaultAsync(string documentId, Option<string> index = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Delete index
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="index"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IKernelMemoryDeleteIndexApiResponse"/>&gt;</returns>
        Task<IKernelMemoryDeleteIndexApiResponse> KernelMemoryDeleteIndexAsync(Option<string> index = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Delete index
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="index"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IKernelMemoryDeleteIndexApiResponse"/>?&gt;</returns>
        Task<IKernelMemoryDeleteIndexApiResponse?> KernelMemoryDeleteIndexOrDefaultAsync(Option<string> index = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Download specific document
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="documentId"></param>
        /// <param name="filename"></param>
        /// <param name="index"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IKernelMemoryDownloadApiResponse"/>&gt;</returns>
        Task<IKernelMemoryDownloadApiResponse> KernelMemoryDownloadAsync(string documentId, string filename, Option<string> index = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Download specific document
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="documentId"></param>
        /// <param name="filename"></param>
        /// <param name="index"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IKernelMemoryDownloadApiResponse"/>?&gt;</returns>
        Task<IKernelMemoryDownloadApiResponse?> KernelMemoryDownloadOrDefaultAsync(string documentId, string filename, Option<string> index = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// List indexes
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IKernelMemoryGetIndexApiResponse"/>&gt;</returns>
        Task<IKernelMemoryGetIndexApiResponse> KernelMemoryGetIndexAsync(System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// List indexes
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IKernelMemoryGetIndexApiResponse"/>?&gt;</returns>
        Task<IKernelMemoryGetIndexApiResponse?> KernelMemoryGetIndexOrDefaultAsync(System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Search for documents in specific index
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="searchQuery"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IKernelMemorySearchApiResponse"/>&gt;</returns>
        Task<IKernelMemorySearchApiResponse> KernelMemorySearchAsync(SearchQuery searchQuery, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Search for documents in specific index
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="searchQuery"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IKernelMemorySearchApiResponse"/>?&gt;</returns>
        Task<IKernelMemorySearchApiResponse?> KernelMemorySearchOrDefaultAsync(SearchQuery searchQuery, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Upload file for ingestion
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IKernelMemoryUploadApiResponse"/>&gt;</returns>
        Task<IKernelMemoryUploadApiResponse> KernelMemoryUploadAsync(System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Upload file for ingestion
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IKernelMemoryUploadApiResponse"/>?&gt;</returns>
        Task<IKernelMemoryUploadApiResponse?> KernelMemoryUploadOrDefaultAsync(System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get ingestion status for specific document
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="documentId"></param>
        /// <param name="index"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IKernelMemoryUploadStatusApiResponse"/>&gt;</returns>
        Task<IKernelMemoryUploadStatusApiResponse> KernelMemoryUploadStatusAsync(string documentId, Option<string> index = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get ingestion status for specific document
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="documentId"></param>
        /// <param name="index"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IKernelMemoryUploadStatusApiResponse"/>?&gt;</returns>
        Task<IKernelMemoryUploadStatusApiResponse?> KernelMemoryUploadStatusOrDefaultAsync(string documentId, Option<string> index = default, System.Threading.CancellationToken cancellationToken = default);
    }

    /// <summary>
    /// The <see cref="IKernelMemoryAskApiResponse"/>
    /// </summary>
    public interface IKernelMemoryAskApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.MemoryAnswer?>, ITooManyRequests<Org.OpenAPITools.Model.ProblemDetails?>, IServiceUnavailable<Org.OpenAPITools.Model.ProblemDetails?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 429 TooManyRequests
        /// </summary>
        /// <returns></returns>
        bool IsTooManyRequests { get; }

        /// <summary>
        /// Returns true if the response is 503 ServiceUnavailable
        /// </summary>
        /// <returns></returns>
        bool IsServiceUnavailable { get; }
    }

    /// <summary>
    /// The <see cref="IKernelMemoryDeleteApiResponse"/>
    /// </summary>
    public interface IKernelMemoryDeleteApiResponse : Org.OpenAPITools.Client.IApiResponse, IAccepted<Org.OpenAPITools.Model.DeleteAccepted?>, ITooManyRequests<Org.OpenAPITools.Model.ProblemDetails?>, IServiceUnavailable<Org.OpenAPITools.Model.ProblemDetails?>
    {
        /// <summary>
        /// Returns true if the response is 202 Accepted
        /// </summary>
        /// <returns></returns>
        bool IsAccepted { get; }

        /// <summary>
        /// Returns true if the response is 429 TooManyRequests
        /// </summary>
        /// <returns></returns>
        bool IsTooManyRequests { get; }

        /// <summary>
        /// Returns true if the response is 503 ServiceUnavailable
        /// </summary>
        /// <returns></returns>
        bool IsServiceUnavailable { get; }
    }

    /// <summary>
    /// The <see cref="IKernelMemoryDeleteIndexApiResponse"/>
    /// </summary>
    public interface IKernelMemoryDeleteIndexApiResponse : Org.OpenAPITools.Client.IApiResponse, IAccepted<Org.OpenAPITools.Model.DeleteAccepted?>, ITooManyRequests<Org.OpenAPITools.Model.ProblemDetails?>, IServiceUnavailable<Org.OpenAPITools.Model.ProblemDetails?>
    {
        /// <summary>
        /// Returns true if the response is 202 Accepted
        /// </summary>
        /// <returns></returns>
        bool IsAccepted { get; }

        /// <summary>
        /// Returns true if the response is 429 TooManyRequests
        /// </summary>
        /// <returns></returns>
        bool IsTooManyRequests { get; }

        /// <summary>
        /// Returns true if the response is 503 ServiceUnavailable
        /// </summary>
        /// <returns></returns>
        bool IsServiceUnavailable { get; }
    }

    /// <summary>
    /// The <see cref="IKernelMemoryDownloadApiResponse"/>
    /// </summary>
    public interface IKernelMemoryDownloadApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.StreamableFileContent?>, INotFound<Org.OpenAPITools.Model.ProblemDetails?>, ITooManyRequests<Org.OpenAPITools.Model.ProblemDetails?>, IServiceUnavailable<Org.OpenAPITools.Model.ProblemDetails?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 429 TooManyRequests
        /// </summary>
        /// <returns></returns>
        bool IsTooManyRequests { get; }

        /// <summary>
        /// Returns true if the response is 503 ServiceUnavailable
        /// </summary>
        /// <returns></returns>
        bool IsServiceUnavailable { get; }
    }

    /// <summary>
    /// The <see cref="IKernelMemoryGetIndexApiResponse"/>
    /// </summary>
    public interface IKernelMemoryGetIndexApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.IndexCollection?>, ITooManyRequests<Org.OpenAPITools.Model.ProblemDetails?>, IServiceUnavailable<Org.OpenAPITools.Model.ProblemDetails?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 429 TooManyRequests
        /// </summary>
        /// <returns></returns>
        bool IsTooManyRequests { get; }

        /// <summary>
        /// Returns true if the response is 503 ServiceUnavailable
        /// </summary>
        /// <returns></returns>
        bool IsServiceUnavailable { get; }
    }

    /// <summary>
    /// The <see cref="IKernelMemorySearchApiResponse"/>
    /// </summary>
    public interface IKernelMemorySearchApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.SearchResult?>, ITooManyRequests<Org.OpenAPITools.Model.ProblemDetails?>, IServiceUnavailable<Org.OpenAPITools.Model.ProblemDetails?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 429 TooManyRequests
        /// </summary>
        /// <returns></returns>
        bool IsTooManyRequests { get; }

        /// <summary>
        /// Returns true if the response is 503 ServiceUnavailable
        /// </summary>
        /// <returns></returns>
        bool IsServiceUnavailable { get; }
    }

    /// <summary>
    /// The <see cref="IKernelMemoryUploadApiResponse"/>
    /// </summary>
    public interface IKernelMemoryUploadApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.UploadAccepted?>, IBadRequest<Org.OpenAPITools.Model.ProblemDetails?>, ITooManyRequests<Org.OpenAPITools.Model.ProblemDetails?>, IServiceUnavailable<Org.OpenAPITools.Model.ProblemDetails?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 429 TooManyRequests
        /// </summary>
        /// <returns></returns>
        bool IsTooManyRequests { get; }

        /// <summary>
        /// Returns true if the response is 503 ServiceUnavailable
        /// </summary>
        /// <returns></returns>
        bool IsServiceUnavailable { get; }
    }

    /// <summary>
    /// The <see cref="IKernelMemoryUploadStatusApiResponse"/>
    /// </summary>
    public interface IKernelMemoryUploadStatusApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.DataPipelineStatus?>, IBadRequest<Org.OpenAPITools.Model.ProblemDetails?>, INotFound<Org.OpenAPITools.Model.ProblemDetails?>, ITooManyRequests<Org.OpenAPITools.Model.ProblemDetails?>, IServiceUnavailable<Org.OpenAPITools.Model.ProblemDetails?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 429 TooManyRequests
        /// </summary>
        /// <returns></returns>
        bool IsTooManyRequests { get; }

        /// <summary>
        /// Returns true if the response is 503 ServiceUnavailable
        /// </summary>
        /// <returns></returns>
        bool IsServiceUnavailable { get; }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public class KernelMemoryApiEvents
    {
        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnKernelMemoryAsk;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorKernelMemoryAsk;

        internal void ExecuteOnKernelMemoryAsk(KernelMemoryApi.KernelMemoryAskApiResponse apiResponse)
        {
            OnKernelMemoryAsk?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorKernelMemoryAsk(Exception exception)
        {
            OnErrorKernelMemoryAsk?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnKernelMemoryDelete;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorKernelMemoryDelete;

        internal void ExecuteOnKernelMemoryDelete(KernelMemoryApi.KernelMemoryDeleteApiResponse apiResponse)
        {
            OnKernelMemoryDelete?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorKernelMemoryDelete(Exception exception)
        {
            OnErrorKernelMemoryDelete?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnKernelMemoryDeleteIndex;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorKernelMemoryDeleteIndex;

        internal void ExecuteOnKernelMemoryDeleteIndex(KernelMemoryApi.KernelMemoryDeleteIndexApiResponse apiResponse)
        {
            OnKernelMemoryDeleteIndex?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorKernelMemoryDeleteIndex(Exception exception)
        {
            OnErrorKernelMemoryDeleteIndex?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnKernelMemoryDownload;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorKernelMemoryDownload;

        internal void ExecuteOnKernelMemoryDownload(KernelMemoryApi.KernelMemoryDownloadApiResponse apiResponse)
        {
            OnKernelMemoryDownload?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorKernelMemoryDownload(Exception exception)
        {
            OnErrorKernelMemoryDownload?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnKernelMemoryGetIndex;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorKernelMemoryGetIndex;

        internal void ExecuteOnKernelMemoryGetIndex(KernelMemoryApi.KernelMemoryGetIndexApiResponse apiResponse)
        {
            OnKernelMemoryGetIndex?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorKernelMemoryGetIndex(Exception exception)
        {
            OnErrorKernelMemoryGetIndex?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnKernelMemorySearch;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorKernelMemorySearch;

        internal void ExecuteOnKernelMemorySearch(KernelMemoryApi.KernelMemorySearchApiResponse apiResponse)
        {
            OnKernelMemorySearch?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorKernelMemorySearch(Exception exception)
        {
            OnErrorKernelMemorySearch?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnKernelMemoryUpload;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorKernelMemoryUpload;

        internal void ExecuteOnKernelMemoryUpload(KernelMemoryApi.KernelMemoryUploadApiResponse apiResponse)
        {
            OnKernelMemoryUpload?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorKernelMemoryUpload(Exception exception)
        {
            OnErrorKernelMemoryUpload?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnKernelMemoryUploadStatus;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorKernelMemoryUploadStatus;

        internal void ExecuteOnKernelMemoryUploadStatus(KernelMemoryApi.KernelMemoryUploadStatusApiResponse apiResponse)
        {
            OnKernelMemoryUploadStatus?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorKernelMemoryUploadStatus(Exception exception)
        {
            OnErrorKernelMemoryUploadStatus?.Invoke(this, new ExceptionEventArgs(exception));
        }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public sealed partial class KernelMemoryApi : IKernelMemoryApi
    {
        private JsonSerializerOptions _jsonSerializerOptions;

        /// <summary>
        /// The logger factory
        /// </summary>
        public ILoggerFactory LoggerFactory { get; }

        /// <summary>
        /// The logger
        /// </summary>
        public ILogger<KernelMemoryApi> Logger { get; }

        /// <summary>
        /// The HttpClient
        /// </summary>
        public HttpClient HttpClient { get; }

        /// <summary>
        /// The class containing the events
        /// </summary>
        public KernelMemoryApiEvents Events { get; }

        /// <summary>
        /// Initializes a new instance of the <see cref="KernelMemoryApi"/> class.
        /// </summary>
        /// <returns></returns>
        public KernelMemoryApi(ILogger<KernelMemoryApi> logger, ILoggerFactory loggerFactory, HttpClient httpClient, JsonSerializerOptionsProvider jsonSerializerOptionsProvider, KernelMemoryApiEvents kernelMemoryApiEvents)
        {
            _jsonSerializerOptions = jsonSerializerOptionsProvider.Options;
            LoggerFactory = loggerFactory;
            Logger = LoggerFactory.CreateLogger<KernelMemoryApi>();
            HttpClient = httpClient;
            Events = kernelMemoryApiEvents;
        }

        partial void FormatKernelMemoryAsk(MemoryQuery memoryQuery);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="memoryQuery"></param>
        /// <returns></returns>
        private void ValidateKernelMemoryAsk(MemoryQuery memoryQuery)
        {
            if (memoryQuery == null)
                throw new ArgumentNullException(nameof(memoryQuery));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="memoryQuery"></param>
        private void AfterKernelMemoryAskDefaultImplementation(IKernelMemoryAskApiResponse apiResponseLocalVar, MemoryQuery memoryQuery)
        {
            bool suppressDefaultLog = false;
            AfterKernelMemoryAsk(ref suppressDefaultLog, apiResponseLocalVar, memoryQuery);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="memoryQuery"></param>
        partial void AfterKernelMemoryAsk(ref bool suppressDefaultLog, IKernelMemoryAskApiResponse apiResponseLocalVar, MemoryQuery memoryQuery);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="memoryQuery"></param>
        private void OnErrorKernelMemoryAskDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, MemoryQuery memoryQuery)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorKernelMemoryAsk(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, memoryQuery);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="memoryQuery"></param>
        partial void OnErrorKernelMemoryAsk(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, MemoryQuery memoryQuery);

        /// <summary>
        /// Query documents and forward result to LLM 
        /// </summary>
        /// <param name="memoryQuery"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IKernelMemoryAskApiResponse"/>&gt;</returns>
        public async Task<IKernelMemoryAskApiResponse?> KernelMemoryAskOrDefaultAsync(MemoryQuery memoryQuery, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await KernelMemoryAskAsync(memoryQuery, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Query documents and forward result to LLM 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="memoryQuery"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IKernelMemoryAskApiResponse"/>&gt;</returns>
        public async Task<IKernelMemoryAskApiResponse> KernelMemoryAskAsync(MemoryQuery memoryQuery, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateKernelMemoryAsk(memoryQuery);

                FormatKernelMemoryAsk(memoryQuery);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/api/kernelmemory/ask";

                    httpRequestMessageLocalVar.Content = (memoryQuery as object) is System.IO.Stream stream
                        ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                        : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(memoryQuery, _jsonSerializerOptions));

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json",
                        "application/problem+json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<KernelMemoryAskApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<KernelMemoryAskApiResponse>();

                        KernelMemoryAskApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/kernelmemory/ask", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterKernelMemoryAskDefaultImplementation(apiResponseLocalVar, memoryQuery);

                        Events.ExecuteOnKernelMemoryAsk(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorKernelMemoryAskDefaultImplementation(e, "/api/kernelmemory/ask", uriBuilderLocalVar.Path, memoryQuery);
                Events.ExecuteOnErrorKernelMemoryAsk(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="KernelMemoryAskApiResponse"/>
        /// </summary>
        public partial class KernelMemoryAskApiResponse : Org.OpenAPITools.Client.ApiResponse, IKernelMemoryAskApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<KernelMemoryAskApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="KernelMemoryAskApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public KernelMemoryAskApiResponse(ILogger<KernelMemoryAskApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.MemoryAnswer? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.MemoryAnswer>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.MemoryAnswer? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 429 TooManyRequests
            /// </summary>
            /// <returns></returns>
            public bool IsTooManyRequests => 429 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 429 TooManyRequests
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.ProblemDetails? TooManyRequests()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsTooManyRequests
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.ProblemDetails>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 429 TooManyRequests and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryTooManyRequests([NotNullWhen(true)]out Org.OpenAPITools.Model.ProblemDetails? result)
            {
                result = null;

                try
                {
                    result = TooManyRequests();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)429);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 503 ServiceUnavailable
            /// </summary>
            /// <returns></returns>
            public bool IsServiceUnavailable => 503 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 503 ServiceUnavailable
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.ProblemDetails? ServiceUnavailable()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsServiceUnavailable
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.ProblemDetails>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 503 ServiceUnavailable and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryServiceUnavailable([NotNullWhen(true)]out Org.OpenAPITools.Model.ProblemDetails? result)
            {
                result = null;

                try
                {
                    result = ServiceUnavailable();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)503);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatKernelMemoryDelete(ref string documentId, ref Option<string> index);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="documentId"></param>
        /// <param name="index"></param>
        /// <returns></returns>
        private void ValidateKernelMemoryDelete(string documentId, Option<string> index)
        {
            if (documentId == null)
                throw new ArgumentNullException(nameof(documentId));

            if (index.IsSet && index.Value == null)
                throw new ArgumentNullException(nameof(index));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="documentId"></param>
        /// <param name="index"></param>
        private void AfterKernelMemoryDeleteDefaultImplementation(IKernelMemoryDeleteApiResponse apiResponseLocalVar, string documentId, Option<string> index)
        {
            bool suppressDefaultLog = false;
            AfterKernelMemoryDelete(ref suppressDefaultLog, apiResponseLocalVar, documentId, index);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="documentId"></param>
        /// <param name="index"></param>
        partial void AfterKernelMemoryDelete(ref bool suppressDefaultLog, IKernelMemoryDeleteApiResponse apiResponseLocalVar, string documentId, Option<string> index);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="documentId"></param>
        /// <param name="index"></param>
        private void OnErrorKernelMemoryDeleteDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string documentId, Option<string> index)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorKernelMemoryDelete(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, documentId, index);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="documentId"></param>
        /// <param name="index"></param>
        partial void OnErrorKernelMemoryDelete(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string documentId, Option<string> index);

        /// <summary>
        /// Delete document from specific index 
        /// </summary>
        /// <param name="documentId"></param>
        /// <param name="index"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IKernelMemoryDeleteApiResponse"/>&gt;</returns>
        public async Task<IKernelMemoryDeleteApiResponse?> KernelMemoryDeleteOrDefaultAsync(string documentId, Option<string> index = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await KernelMemoryDeleteAsync(documentId, index, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Delete document from specific index 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="documentId"></param>
        /// <param name="index"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IKernelMemoryDeleteApiResponse"/>&gt;</returns>
        public async Task<IKernelMemoryDeleteApiResponse> KernelMemoryDeleteAsync(string documentId, Option<string> index = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateKernelMemoryDelete(documentId, index);

                FormatKernelMemoryDelete(ref documentId, ref index);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/api/kernelmemory/documents";

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["documentId"] = ClientUtils.ParameterToString(documentId);

                    if (index.IsSet)
                        parseQueryStringLocalVar["index"] = ClientUtils.ParameterToString(index.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json",
                        "application/problem+json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Delete;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<KernelMemoryDeleteApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<KernelMemoryDeleteApiResponse>();

                        KernelMemoryDeleteApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/kernelmemory/documents", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterKernelMemoryDeleteDefaultImplementation(apiResponseLocalVar, documentId, index);

                        Events.ExecuteOnKernelMemoryDelete(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorKernelMemoryDeleteDefaultImplementation(e, "/api/kernelmemory/documents", uriBuilderLocalVar.Path, documentId, index);
                Events.ExecuteOnErrorKernelMemoryDelete(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="KernelMemoryDeleteApiResponse"/>
        /// </summary>
        public partial class KernelMemoryDeleteApiResponse : Org.OpenAPITools.Client.ApiResponse, IKernelMemoryDeleteApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<KernelMemoryDeleteApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="KernelMemoryDeleteApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public KernelMemoryDeleteApiResponse(ILogger<KernelMemoryDeleteApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 202 Accepted
            /// </summary>
            /// <returns></returns>
            public bool IsAccepted => 202 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 202 Accepted
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.DeleteAccepted? Accepted()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsAccepted
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.DeleteAccepted>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 202 Accepted and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryAccepted([NotNullWhen(true)]out Org.OpenAPITools.Model.DeleteAccepted? result)
            {
                result = null;

                try
                {
                    result = Accepted();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)202);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 429 TooManyRequests
            /// </summary>
            /// <returns></returns>
            public bool IsTooManyRequests => 429 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 429 TooManyRequests
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.ProblemDetails? TooManyRequests()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsTooManyRequests
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.ProblemDetails>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 429 TooManyRequests and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryTooManyRequests([NotNullWhen(true)]out Org.OpenAPITools.Model.ProblemDetails? result)
            {
                result = null;

                try
                {
                    result = TooManyRequests();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)429);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 503 ServiceUnavailable
            /// </summary>
            /// <returns></returns>
            public bool IsServiceUnavailable => 503 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 503 ServiceUnavailable
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.ProblemDetails? ServiceUnavailable()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsServiceUnavailable
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.ProblemDetails>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 503 ServiceUnavailable and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryServiceUnavailable([NotNullWhen(true)]out Org.OpenAPITools.Model.ProblemDetails? result)
            {
                result = null;

                try
                {
                    result = ServiceUnavailable();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)503);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatKernelMemoryDeleteIndex(ref Option<string> index);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="index"></param>
        /// <returns></returns>
        private void ValidateKernelMemoryDeleteIndex(Option<string> index)
        {
            if (index.IsSet && index.Value == null)
                throw new ArgumentNullException(nameof(index));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="index"></param>
        private void AfterKernelMemoryDeleteIndexDefaultImplementation(IKernelMemoryDeleteIndexApiResponse apiResponseLocalVar, Option<string> index)
        {
            bool suppressDefaultLog = false;
            AfterKernelMemoryDeleteIndex(ref suppressDefaultLog, apiResponseLocalVar, index);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="index"></param>
        partial void AfterKernelMemoryDeleteIndex(ref bool suppressDefaultLog, IKernelMemoryDeleteIndexApiResponse apiResponseLocalVar, Option<string> index);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="index"></param>
        private void OnErrorKernelMemoryDeleteIndexDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<string> index)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorKernelMemoryDeleteIndex(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, index);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="index"></param>
        partial void OnErrorKernelMemoryDeleteIndex(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<string> index);

        /// <summary>
        /// Delete index 
        /// </summary>
        /// <param name="index"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IKernelMemoryDeleteIndexApiResponse"/>&gt;</returns>
        public async Task<IKernelMemoryDeleteIndexApiResponse?> KernelMemoryDeleteIndexOrDefaultAsync(Option<string> index = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await KernelMemoryDeleteIndexAsync(index, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Delete index 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="index"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IKernelMemoryDeleteIndexApiResponse"/>&gt;</returns>
        public async Task<IKernelMemoryDeleteIndexApiResponse> KernelMemoryDeleteIndexAsync(Option<string> index = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateKernelMemoryDeleteIndex(index);

                FormatKernelMemoryDeleteIndex(ref index);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/api/kernelmemory/indexes";

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (index.IsSet)
                        parseQueryStringLocalVar["index"] = ClientUtils.ParameterToString(index.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json",
                        "application/problem+json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Delete;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<KernelMemoryDeleteIndexApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<KernelMemoryDeleteIndexApiResponse>();

                        KernelMemoryDeleteIndexApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/kernelmemory/indexes", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterKernelMemoryDeleteIndexDefaultImplementation(apiResponseLocalVar, index);

                        Events.ExecuteOnKernelMemoryDeleteIndex(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorKernelMemoryDeleteIndexDefaultImplementation(e, "/api/kernelmemory/indexes", uriBuilderLocalVar.Path, index);
                Events.ExecuteOnErrorKernelMemoryDeleteIndex(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="KernelMemoryDeleteIndexApiResponse"/>
        /// </summary>
        public partial class KernelMemoryDeleteIndexApiResponse : Org.OpenAPITools.Client.ApiResponse, IKernelMemoryDeleteIndexApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<KernelMemoryDeleteIndexApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="KernelMemoryDeleteIndexApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public KernelMemoryDeleteIndexApiResponse(ILogger<KernelMemoryDeleteIndexApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 202 Accepted
            /// </summary>
            /// <returns></returns>
            public bool IsAccepted => 202 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 202 Accepted
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.DeleteAccepted? Accepted()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsAccepted
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.DeleteAccepted>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 202 Accepted and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryAccepted([NotNullWhen(true)]out Org.OpenAPITools.Model.DeleteAccepted? result)
            {
                result = null;

                try
                {
                    result = Accepted();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)202);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 429 TooManyRequests
            /// </summary>
            /// <returns></returns>
            public bool IsTooManyRequests => 429 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 429 TooManyRequests
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.ProblemDetails? TooManyRequests()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsTooManyRequests
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.ProblemDetails>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 429 TooManyRequests and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryTooManyRequests([NotNullWhen(true)]out Org.OpenAPITools.Model.ProblemDetails? result)
            {
                result = null;

                try
                {
                    result = TooManyRequests();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)429);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 503 ServiceUnavailable
            /// </summary>
            /// <returns></returns>
            public bool IsServiceUnavailable => 503 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 503 ServiceUnavailable
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.ProblemDetails? ServiceUnavailable()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsServiceUnavailable
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.ProblemDetails>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 503 ServiceUnavailable and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryServiceUnavailable([NotNullWhen(true)]out Org.OpenAPITools.Model.ProblemDetails? result)
            {
                result = null;

                try
                {
                    result = ServiceUnavailable();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)503);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatKernelMemoryDownload(ref string documentId, ref string filename, ref Option<string> index);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="documentId"></param>
        /// <param name="filename"></param>
        /// <param name="index"></param>
        /// <returns></returns>
        private void ValidateKernelMemoryDownload(string documentId, string filename, Option<string> index)
        {
            if (documentId == null)
                throw new ArgumentNullException(nameof(documentId));

            if (filename == null)
                throw new ArgumentNullException(nameof(filename));

            if (index.IsSet && index.Value == null)
                throw new ArgumentNullException(nameof(index));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="documentId"></param>
        /// <param name="filename"></param>
        /// <param name="index"></param>
        private void AfterKernelMemoryDownloadDefaultImplementation(IKernelMemoryDownloadApiResponse apiResponseLocalVar, string documentId, string filename, Option<string> index)
        {
            bool suppressDefaultLog = false;
            AfterKernelMemoryDownload(ref suppressDefaultLog, apiResponseLocalVar, documentId, filename, index);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="documentId"></param>
        /// <param name="filename"></param>
        /// <param name="index"></param>
        partial void AfterKernelMemoryDownload(ref bool suppressDefaultLog, IKernelMemoryDownloadApiResponse apiResponseLocalVar, string documentId, string filename, Option<string> index);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="documentId"></param>
        /// <param name="filename"></param>
        /// <param name="index"></param>
        private void OnErrorKernelMemoryDownloadDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string documentId, string filename, Option<string> index)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorKernelMemoryDownload(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, documentId, filename, index);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="documentId"></param>
        /// <param name="filename"></param>
        /// <param name="index"></param>
        partial void OnErrorKernelMemoryDownload(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string documentId, string filename, Option<string> index);

        /// <summary>
        /// Download specific document 
        /// </summary>
        /// <param name="documentId"></param>
        /// <param name="filename"></param>
        /// <param name="index"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IKernelMemoryDownloadApiResponse"/>&gt;</returns>
        public async Task<IKernelMemoryDownloadApiResponse?> KernelMemoryDownloadOrDefaultAsync(string documentId, string filename, Option<string> index = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await KernelMemoryDownloadAsync(documentId, filename, index, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Download specific document 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="documentId"></param>
        /// <param name="filename"></param>
        /// <param name="index"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IKernelMemoryDownloadApiResponse"/>&gt;</returns>
        public async Task<IKernelMemoryDownloadApiResponse> KernelMemoryDownloadAsync(string documentId, string filename, Option<string> index = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateKernelMemoryDownload(documentId, filename, index);

                FormatKernelMemoryDownload(ref documentId, ref filename, ref index);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/api/kernelmemory/download";

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["documentId"] = ClientUtils.ParameterToString(documentId);
                    parseQueryStringLocalVar["filename"] = ClientUtils.ParameterToString(filename);

                    if (index.IsSet)
                        parseQueryStringLocalVar["index"] = ClientUtils.ParameterToString(index.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json",
                        "application/problem+json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<KernelMemoryDownloadApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<KernelMemoryDownloadApiResponse>();

                        KernelMemoryDownloadApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/kernelmemory/download", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterKernelMemoryDownloadDefaultImplementation(apiResponseLocalVar, documentId, filename, index);

                        Events.ExecuteOnKernelMemoryDownload(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorKernelMemoryDownloadDefaultImplementation(e, "/api/kernelmemory/download", uriBuilderLocalVar.Path, documentId, filename, index);
                Events.ExecuteOnErrorKernelMemoryDownload(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="KernelMemoryDownloadApiResponse"/>
        /// </summary>
        public partial class KernelMemoryDownloadApiResponse : Org.OpenAPITools.Client.ApiResponse, IKernelMemoryDownloadApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<KernelMemoryDownloadApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="KernelMemoryDownloadApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public KernelMemoryDownloadApiResponse(ILogger<KernelMemoryDownloadApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.StreamableFileContent? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.StreamableFileContent>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.StreamableFileContent? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.ProblemDetails? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.ProblemDetails>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out Org.OpenAPITools.Model.ProblemDetails? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 429 TooManyRequests
            /// </summary>
            /// <returns></returns>
            public bool IsTooManyRequests => 429 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 429 TooManyRequests
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.ProblemDetails? TooManyRequests()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsTooManyRequests
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.ProblemDetails>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 429 TooManyRequests and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryTooManyRequests([NotNullWhen(true)]out Org.OpenAPITools.Model.ProblemDetails? result)
            {
                result = null;

                try
                {
                    result = TooManyRequests();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)429);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 503 ServiceUnavailable
            /// </summary>
            /// <returns></returns>
            public bool IsServiceUnavailable => 503 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 503 ServiceUnavailable
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.ProblemDetails? ServiceUnavailable()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsServiceUnavailable
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.ProblemDetails>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 503 ServiceUnavailable and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryServiceUnavailable([NotNullWhen(true)]out Org.OpenAPITools.Model.ProblemDetails? result)
            {
                result = null;

                try
                {
                    result = ServiceUnavailable();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)503);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        private void AfterKernelMemoryGetIndexDefaultImplementation(IKernelMemoryGetIndexApiResponse apiResponseLocalVar)
        {
            bool suppressDefaultLog = false;
            AfterKernelMemoryGetIndex(ref suppressDefaultLog, apiResponseLocalVar);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        partial void AfterKernelMemoryGetIndex(ref bool suppressDefaultLog, IKernelMemoryGetIndexApiResponse apiResponseLocalVar);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        private void OnErrorKernelMemoryGetIndexDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorKernelMemoryGetIndex(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        partial void OnErrorKernelMemoryGetIndex(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar);

        /// <summary>
        /// List indexes 
        /// </summary>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IKernelMemoryGetIndexApiResponse"/>&gt;</returns>
        public async Task<IKernelMemoryGetIndexApiResponse?> KernelMemoryGetIndexOrDefaultAsync(System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await KernelMemoryGetIndexAsync(cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// List indexes 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IKernelMemoryGetIndexApiResponse"/>&gt;</returns>
        public async Task<IKernelMemoryGetIndexApiResponse> KernelMemoryGetIndexAsync(System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/api/kernelmemory/indexes";

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json",
                        "application/problem+json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<KernelMemoryGetIndexApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<KernelMemoryGetIndexApiResponse>();

                        KernelMemoryGetIndexApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/kernelmemory/indexes", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterKernelMemoryGetIndexDefaultImplementation(apiResponseLocalVar);

                        Events.ExecuteOnKernelMemoryGetIndex(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorKernelMemoryGetIndexDefaultImplementation(e, "/api/kernelmemory/indexes", uriBuilderLocalVar.Path);
                Events.ExecuteOnErrorKernelMemoryGetIndex(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="KernelMemoryGetIndexApiResponse"/>
        /// </summary>
        public partial class KernelMemoryGetIndexApiResponse : Org.OpenAPITools.Client.ApiResponse, IKernelMemoryGetIndexApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<KernelMemoryGetIndexApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="KernelMemoryGetIndexApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public KernelMemoryGetIndexApiResponse(ILogger<KernelMemoryGetIndexApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.IndexCollection? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.IndexCollection>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.IndexCollection? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 429 TooManyRequests
            /// </summary>
            /// <returns></returns>
            public bool IsTooManyRequests => 429 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 429 TooManyRequests
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.ProblemDetails? TooManyRequests()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsTooManyRequests
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.ProblemDetails>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 429 TooManyRequests and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryTooManyRequests([NotNullWhen(true)]out Org.OpenAPITools.Model.ProblemDetails? result)
            {
                result = null;

                try
                {
                    result = TooManyRequests();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)429);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 503 ServiceUnavailable
            /// </summary>
            /// <returns></returns>
            public bool IsServiceUnavailable => 503 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 503 ServiceUnavailable
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.ProblemDetails? ServiceUnavailable()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsServiceUnavailable
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.ProblemDetails>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 503 ServiceUnavailable and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryServiceUnavailable([NotNullWhen(true)]out Org.OpenAPITools.Model.ProblemDetails? result)
            {
                result = null;

                try
                {
                    result = ServiceUnavailable();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)503);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatKernelMemorySearch(SearchQuery searchQuery);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="searchQuery"></param>
        /// <returns></returns>
        private void ValidateKernelMemorySearch(SearchQuery searchQuery)
        {
            if (searchQuery == null)
                throw new ArgumentNullException(nameof(searchQuery));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="searchQuery"></param>
        private void AfterKernelMemorySearchDefaultImplementation(IKernelMemorySearchApiResponse apiResponseLocalVar, SearchQuery searchQuery)
        {
            bool suppressDefaultLog = false;
            AfterKernelMemorySearch(ref suppressDefaultLog, apiResponseLocalVar, searchQuery);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="searchQuery"></param>
        partial void AfterKernelMemorySearch(ref bool suppressDefaultLog, IKernelMemorySearchApiResponse apiResponseLocalVar, SearchQuery searchQuery);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="searchQuery"></param>
        private void OnErrorKernelMemorySearchDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, SearchQuery searchQuery)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorKernelMemorySearch(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, searchQuery);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="searchQuery"></param>
        partial void OnErrorKernelMemorySearch(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, SearchQuery searchQuery);

        /// <summary>
        /// Search for documents in specific index 
        /// </summary>
        /// <param name="searchQuery"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IKernelMemorySearchApiResponse"/>&gt;</returns>
        public async Task<IKernelMemorySearchApiResponse?> KernelMemorySearchOrDefaultAsync(SearchQuery searchQuery, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await KernelMemorySearchAsync(searchQuery, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Search for documents in specific index 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="searchQuery"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IKernelMemorySearchApiResponse"/>&gt;</returns>
        public async Task<IKernelMemorySearchApiResponse> KernelMemorySearchAsync(SearchQuery searchQuery, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateKernelMemorySearch(searchQuery);

                FormatKernelMemorySearch(searchQuery);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/api/kernelmemory/search";

                    httpRequestMessageLocalVar.Content = (searchQuery as object) is System.IO.Stream stream
                        ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                        : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(searchQuery, _jsonSerializerOptions));

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json",
                        "application/problem+json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<KernelMemorySearchApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<KernelMemorySearchApiResponse>();

                        KernelMemorySearchApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/kernelmemory/search", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterKernelMemorySearchDefaultImplementation(apiResponseLocalVar, searchQuery);

                        Events.ExecuteOnKernelMemorySearch(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorKernelMemorySearchDefaultImplementation(e, "/api/kernelmemory/search", uriBuilderLocalVar.Path, searchQuery);
                Events.ExecuteOnErrorKernelMemorySearch(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="KernelMemorySearchApiResponse"/>
        /// </summary>
        public partial class KernelMemorySearchApiResponse : Org.OpenAPITools.Client.ApiResponse, IKernelMemorySearchApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<KernelMemorySearchApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="KernelMemorySearchApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public KernelMemorySearchApiResponse(ILogger<KernelMemorySearchApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.SearchResult? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.SearchResult>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.SearchResult? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 429 TooManyRequests
            /// </summary>
            /// <returns></returns>
            public bool IsTooManyRequests => 429 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 429 TooManyRequests
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.ProblemDetails? TooManyRequests()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsTooManyRequests
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.ProblemDetails>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 429 TooManyRequests and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryTooManyRequests([NotNullWhen(true)]out Org.OpenAPITools.Model.ProblemDetails? result)
            {
                result = null;

                try
                {
                    result = TooManyRequests();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)429);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 503 ServiceUnavailable
            /// </summary>
            /// <returns></returns>
            public bool IsServiceUnavailable => 503 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 503 ServiceUnavailable
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.ProblemDetails? ServiceUnavailable()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsServiceUnavailable
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.ProblemDetails>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 503 ServiceUnavailable and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryServiceUnavailable([NotNullWhen(true)]out Org.OpenAPITools.Model.ProblemDetails? result)
            {
                result = null;

                try
                {
                    result = ServiceUnavailable();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)503);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        private void AfterKernelMemoryUploadDefaultImplementation(IKernelMemoryUploadApiResponse apiResponseLocalVar)
        {
            bool suppressDefaultLog = false;
            AfterKernelMemoryUpload(ref suppressDefaultLog, apiResponseLocalVar);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        partial void AfterKernelMemoryUpload(ref bool suppressDefaultLog, IKernelMemoryUploadApiResponse apiResponseLocalVar);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        private void OnErrorKernelMemoryUploadDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorKernelMemoryUpload(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        partial void OnErrorKernelMemoryUpload(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar);

        /// <summary>
        /// Upload file for ingestion 
        /// </summary>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IKernelMemoryUploadApiResponse"/>&gt;</returns>
        public async Task<IKernelMemoryUploadApiResponse?> KernelMemoryUploadOrDefaultAsync(System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await KernelMemoryUploadAsync(cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Upload file for ingestion 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IKernelMemoryUploadApiResponse"/>&gt;</returns>
        public async Task<IKernelMemoryUploadApiResponse> KernelMemoryUploadAsync(System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/api/kernelmemory/upload";

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json",
                        "application/problem+json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<KernelMemoryUploadApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<KernelMemoryUploadApiResponse>();

                        KernelMemoryUploadApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/kernelmemory/upload", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterKernelMemoryUploadDefaultImplementation(apiResponseLocalVar);

                        Events.ExecuteOnKernelMemoryUpload(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorKernelMemoryUploadDefaultImplementation(e, "/api/kernelmemory/upload", uriBuilderLocalVar.Path);
                Events.ExecuteOnErrorKernelMemoryUpload(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="KernelMemoryUploadApiResponse"/>
        /// </summary>
        public partial class KernelMemoryUploadApiResponse : Org.OpenAPITools.Client.ApiResponse, IKernelMemoryUploadApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<KernelMemoryUploadApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="KernelMemoryUploadApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public KernelMemoryUploadApiResponse(ILogger<KernelMemoryUploadApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.UploadAccepted? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.UploadAccepted>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.UploadAccepted? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.ProblemDetails? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.ProblemDetails>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out Org.OpenAPITools.Model.ProblemDetails? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 429 TooManyRequests
            /// </summary>
            /// <returns></returns>
            public bool IsTooManyRequests => 429 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 429 TooManyRequests
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.ProblemDetails? TooManyRequests()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsTooManyRequests
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.ProblemDetails>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 429 TooManyRequests and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryTooManyRequests([NotNullWhen(true)]out Org.OpenAPITools.Model.ProblemDetails? result)
            {
                result = null;

                try
                {
                    result = TooManyRequests();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)429);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 503 ServiceUnavailable
            /// </summary>
            /// <returns></returns>
            public bool IsServiceUnavailable => 503 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 503 ServiceUnavailable
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.ProblemDetails? ServiceUnavailable()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsServiceUnavailable
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.ProblemDetails>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 503 ServiceUnavailable and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryServiceUnavailable([NotNullWhen(true)]out Org.OpenAPITools.Model.ProblemDetails? result)
            {
                result = null;

                try
                {
                    result = ServiceUnavailable();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)503);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatKernelMemoryUploadStatus(ref string documentId, ref Option<string> index);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="documentId"></param>
        /// <param name="index"></param>
        /// <returns></returns>
        private void ValidateKernelMemoryUploadStatus(string documentId, Option<string> index)
        {
            if (documentId == null)
                throw new ArgumentNullException(nameof(documentId));

            if (index.IsSet && index.Value == null)
                throw new ArgumentNullException(nameof(index));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="documentId"></param>
        /// <param name="index"></param>
        private void AfterKernelMemoryUploadStatusDefaultImplementation(IKernelMemoryUploadStatusApiResponse apiResponseLocalVar, string documentId, Option<string> index)
        {
            bool suppressDefaultLog = false;
            AfterKernelMemoryUploadStatus(ref suppressDefaultLog, apiResponseLocalVar, documentId, index);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="documentId"></param>
        /// <param name="index"></param>
        partial void AfterKernelMemoryUploadStatus(ref bool suppressDefaultLog, IKernelMemoryUploadStatusApiResponse apiResponseLocalVar, string documentId, Option<string> index);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="documentId"></param>
        /// <param name="index"></param>
        private void OnErrorKernelMemoryUploadStatusDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string documentId, Option<string> index)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorKernelMemoryUploadStatus(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, documentId, index);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="documentId"></param>
        /// <param name="index"></param>
        partial void OnErrorKernelMemoryUploadStatus(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string documentId, Option<string> index);

        /// <summary>
        /// Get ingestion status for specific document 
        /// </summary>
        /// <param name="documentId"></param>
        /// <param name="index"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IKernelMemoryUploadStatusApiResponse"/>&gt;</returns>
        public async Task<IKernelMemoryUploadStatusApiResponse?> KernelMemoryUploadStatusOrDefaultAsync(string documentId, Option<string> index = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await KernelMemoryUploadStatusAsync(documentId, index, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get ingestion status for specific document 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="documentId"></param>
        /// <param name="index"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IKernelMemoryUploadStatusApiResponse"/>&gt;</returns>
        public async Task<IKernelMemoryUploadStatusApiResponse> KernelMemoryUploadStatusAsync(string documentId, Option<string> index = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateKernelMemoryUploadStatus(documentId, index);

                FormatKernelMemoryUploadStatus(ref documentId, ref index);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/api/kernelmemory/upload-status";

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["documentId"] = ClientUtils.ParameterToString(documentId);

                    if (index.IsSet)
                        parseQueryStringLocalVar["index"] = ClientUtils.ParameterToString(index.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json",
                        "application/problem+json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<KernelMemoryUploadStatusApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<KernelMemoryUploadStatusApiResponse>();

                        KernelMemoryUploadStatusApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/kernelmemory/upload-status", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterKernelMemoryUploadStatusDefaultImplementation(apiResponseLocalVar, documentId, index);

                        Events.ExecuteOnKernelMemoryUploadStatus(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorKernelMemoryUploadStatusDefaultImplementation(e, "/api/kernelmemory/upload-status", uriBuilderLocalVar.Path, documentId, index);
                Events.ExecuteOnErrorKernelMemoryUploadStatus(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="KernelMemoryUploadStatusApiResponse"/>
        /// </summary>
        public partial class KernelMemoryUploadStatusApiResponse : Org.OpenAPITools.Client.ApiResponse, IKernelMemoryUploadStatusApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<KernelMemoryUploadStatusApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="KernelMemoryUploadStatusApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public KernelMemoryUploadStatusApiResponse(ILogger<KernelMemoryUploadStatusApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.DataPipelineStatus? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.DataPipelineStatus>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.DataPipelineStatus? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.ProblemDetails? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.ProblemDetails>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out Org.OpenAPITools.Model.ProblemDetails? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.ProblemDetails? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.ProblemDetails>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out Org.OpenAPITools.Model.ProblemDetails? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 429 TooManyRequests
            /// </summary>
            /// <returns></returns>
            public bool IsTooManyRequests => 429 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 429 TooManyRequests
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.ProblemDetails? TooManyRequests()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsTooManyRequests
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.ProblemDetails>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 429 TooManyRequests and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryTooManyRequests([NotNullWhen(true)]out Org.OpenAPITools.Model.ProblemDetails? result)
            {
                result = null;

                try
                {
                    result = TooManyRequests();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)429);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 503 ServiceUnavailable
            /// </summary>
            /// <returns></returns>
            public bool IsServiceUnavailable => 503 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 503 ServiceUnavailable
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.ProblemDetails? ServiceUnavailable()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsServiceUnavailable
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.ProblemDetails>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 503 ServiceUnavailable and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryServiceUnavailable([NotNullWhen(true)]out Org.OpenAPITools.Model.ProblemDetails? result)
            {
                result = null;

                try
                {
                    result = ServiceUnavailable();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)503);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }
    }
}
