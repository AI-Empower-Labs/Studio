/*
 * Studio - AI Empower Labs
 *
 * # Studio API Documentation  ## Introduction Welcome to Studio by AI Empower Labs API documentation! We are thrilled to offer developers around the world access to our cutting-edge artificial intelligence technology and semantic search. Our API is designed to empower your applications with state-of-the-art AI capabilities, including but not limited to natural language processing, audio transcription, embedding, and predictive analytics.  Our mission is to make AI technology accessible and easy to integrate, enabling you to enhance your applications, improve user experiences, and innovate in your field. Whether you're building complex systems, developing mobile apps, or creating web services, our API provides you with the tools you need to incorporate AI functionalities seamlessly.  Support and Feedback We are committed to providing exceptional support to our developer community. If you have any questions, encounter any issues, or have feedback on how we can improve our API, please don't hesitate to contact our support team @ support@AIEmpowerLabs.com.  Terms of Use Please review our terms of use and privacy policy before integrating our API into your application. By using our API, you agree to comply with these terms.
 *
 * The version of the OpenAPI document: v1
 * Contact: support@aiempowerlabs.com
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`semantic_search_delete_document`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SemanticSearchDeleteDocumentError {
    Status400(models::HttpValidationProblemDetails),
    Status429(models::ProblemDetails),
    Status500(models::ProblemDetails),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`semantic_search_delete_index`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SemanticSearchDeleteIndexError {
    Status400(models::HttpValidationProblemDetails),
    Status429(models::ProblemDetails),
    Status500(models::ProblemDetails),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`semantic_search_file_ingestion`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SemanticSearchFileIngestionError {
    Status400(models::HttpValidationProblemDetails),
    Status429(models::ProblemDetails),
    Status500(models::ProblemDetails),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`semantic_search_ingestion_status`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SemanticSearchIngestionStatusError {
    Status400(models::HttpValidationProblemDetails),
    Status404(models::ProblemDetails),
    Status429(models::ProblemDetails),
    Status500(models::ProblemDetails),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`semantic_search_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SemanticSearchListError {
    Status400(models::HttpValidationProblemDetails),
    Status429(models::ProblemDetails),
    Status500(models::ProblemDetails),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`semantic_search_query`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SemanticSearchQueryError {
    Status400(models::HttpValidationProblemDetails),
    Status429(models::ProblemDetails),
    Status500(models::ProblemDetails),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`semantic_search_query_results_clustering`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SemanticSearchQueryResultsClusteringError {
    Status400(models::HttpValidationProblemDetails),
    Status429(models::ProblemDetails),
    Status500(models::ProblemDetails),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`semantic_search_rerank`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SemanticSearchRerankError {
    Status400(models::HttpValidationProblemDetails),
    Status429(models::ProblemDetails),
    Status500(models::ProblemDetails),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`semantic_search_text_ingestion`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SemanticSearchTextIngestionError {
    Status400(models::HttpValidationProblemDetails),
    Status429(models::ProblemDetails),
    Status500(models::ProblemDetails),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`semantic_search_webpage_ingestion`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SemanticSearchWebpageIngestionError {
    Status400(models::HttpValidationProblemDetails),
    Status429(models::ProblemDetails),
    Status500(models::ProblemDetails),
    UnknownValue(serde_json::Value),
}


/// Delete specific document by id
pub async fn semantic_search_delete_document(configuration: &configuration::Configuration, document_id: &str, index: &str) -> Result<(), Error<SemanticSearchDeleteDocumentError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_document_id = document_id;
    let p_index = index;

    let uri_str = format!("{}/api/semantic/{documentId}", configuration.base_path, documentId=crate::apis::urlencode(p_document_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    req_builder = req_builder.query(&[("index", &p_index.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<SemanticSearchDeleteDocumentError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Delete specific index by name
pub async fn semantic_search_delete_index(configuration: &configuration::Configuration, name: &str) -> Result<(), Error<SemanticSearchDeleteIndexError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_name = name;

    let uri_str = format!("{}/api/semantic/index/{name}", configuration.base_path, name=crate::apis::urlencode(p_name));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<SemanticSearchDeleteIndexError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Uploads and ingests a file document into the semantic search index. Supports optional configuration of index, ingestion pipeline, embedding model, and webhook for processing status.
pub async fn semantic_search_file_ingestion(configuration: &configuration::Configuration, files: Vec<std::path::PathBuf>, document_id: Option<&str>, index: Option<&str>, pipeline: Option<Vec<String>>, web_hook_url: Option<&str>, embedding_model: Option<&str>, document_id2: Option<&str>, index2: Option<&str>, web_hook_url2: Option<&str>, embedding_model_name: Option<&str>, context: Option<std::collections::HashMap<String, String>>, tags: Option<std::collections::HashMap<String, Vec<String>>>, ingestion_pipeline: Option<Vec<String>>, language_auto_detection: Option<bool>, language: Option<&str>) -> Result<models::IngestDocumentResponse, Error<SemanticSearchFileIngestionError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_files = files;
    let p_document_id = document_id;
    let p_index = index;
    let p_pipeline = pipeline;
    let p_web_hook_url = web_hook_url;
    let p_embedding_model = embedding_model;
    let p_document_id = document_id2;
    let p_index = index2;
    let p_web_hook_url = web_hook_url2;
    let p_embedding_model_name = embedding_model_name;
    let p_context = context;
    let p_tags = tags;
    let p_ingestion_pipeline = ingestion_pipeline;
    let p_language_auto_detection = language_auto_detection;
    let p_language = language;

    let uri_str = format!("{}/api/ingest/file", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_document_id {
        req_builder = req_builder.query(&[("documentId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_index {
        req_builder = req_builder.query(&[("index", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_pipeline {
        req_builder = match "multi" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("pipeline".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("pipeline", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref param_value) = p_web_hook_url {
        req_builder = req_builder.query(&[("webHookUrl", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_embedding_model {
        req_builder = req_builder.query(&[("embeddingModel", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    let mut multipart_form = reqwest::multipart::Form::new();
    if let Some(param_value) = p_document_id {
        multipart_form = multipart_form.text("documentId", param_value.to_string());
    }
    if let Some(param_value) = p_index {
        multipart_form = multipart_form.text("index", param_value.to_string());
    }
    if let Some(param_value) = p_web_hook_url {
        multipart_form = multipart_form.text("webHookUrl", param_value.to_string());
    }
    if let Some(param_value) = p_embedding_model_name {
        multipart_form = multipart_form.text("embeddingModelName", param_value.to_string());
    }
    // TODO: support file upload for 'files' parameter
    if let Some(param_value) = p_context {
        multipart_form = multipart_form.text("context", param_value.to_string());
    }
    if let Some(param_value) = p_tags {
        multipart_form = multipart_form.text("tags", param_value.to_string());
    }
    if let Some(param_value) = p_ingestion_pipeline {
        multipart_form = multipart_form.text("ingestionPipeline", param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string());
    }
    if let Some(param_value) = p_language_auto_detection {
        multipart_form = multipart_form.text("languageAutoDetection", param_value.to_string());
    }
    if let Some(param_value) = p_language {
        multipart_form = multipart_form.text("language", param_value.to_string());
    }
    req_builder = req_builder.multipart(multipart_form);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::IngestDocumentResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::IngestDocumentResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SemanticSearchFileIngestionError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get queue status for ingestion job
pub async fn semantic_search_ingestion_status(configuration: &configuration::Configuration, id: &str) -> Result<models::DataPipelineStatus, Error<SemanticSearchIngestionStatusError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;

    let uri_str = format!("{}/api/ingest/status", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("id", &p_id.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DataPipelineStatus`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DataPipelineStatus`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SemanticSearchIngestionStatusError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// List - and filter - for ingested documents
pub async fn semantic_search_list(configuration: &configuration::Configuration, list_document_parameters: models::ListDocumentParameters) -> Result<models::ListDocumentResponse, Error<SemanticSearchListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_list_document_parameters = list_document_parameters;

    let uri_str = format!("{}/api/semantic/list", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_list_document_parameters);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ListDocumentResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ListDocumentResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SemanticSearchListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Performs semantic or hybrid search over previously ingested data.
pub async fn semantic_search_query(configuration: &configuration::Configuration, query_document_request: models::QueryDocumentRequest) -> Result<models::QueryDocumentResponse, Error<SemanticSearchQueryError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_document_request = query_document_request;

    let uri_str = format!("{}/api/semantic/query", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_query_document_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::QueryDocumentResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::QueryDocumentResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SemanticSearchQueryError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Perform k-means clustering over semantic search log entries
pub async fn semantic_search_query_results_clustering(configuration: &configuration::Configuration, semantic_search_query_results_clustering_request: models::SemanticSearchQueryResultsClusteringRequest) -> Result<models::KMeansCluster, Error<SemanticSearchQueryResultsClusteringError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_semantic_search_query_results_clustering_request = semantic_search_query_results_clustering_request;

    let uri_str = format!("{}/api/semantic/query-results-clustering", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_semantic_search_query_results_clustering_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::KMeansCluster`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::KMeansCluster`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SemanticSearchQueryResultsClusteringError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Rerank documents
pub async fn semantic_search_rerank(configuration: &configuration::Configuration, re_rank_documents_request: models::ReRankDocumentsRequest) -> Result<models::ReRankDocumentsResponse, Error<SemanticSearchRerankError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_re_rank_documents_request = re_rank_documents_request;

    let uri_str = format!("{}/api/semantic/rerank", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_re_rank_documents_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ReRankDocumentsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ReRankDocumentsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SemanticSearchRerankError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Ingests a plain text document into the semantic search index. This endpoint allows associating tags and specifying the target index for enhanced search capabilities.
pub async fn semantic_search_text_ingestion(configuration: &configuration::Configuration, ingest_text_document_request: models::IngestTextDocumentRequest) -> Result<models::IngestDocumentResponse, Error<SemanticSearchTextIngestionError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_ingest_text_document_request = ingest_text_document_request;

    let uri_str = format!("{}/api/ingest/text", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_ingest_text_document_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::IngestDocumentResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::IngestDocumentResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SemanticSearchTextIngestionError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Import web page text into semantic search
pub async fn semantic_search_webpage_ingestion(configuration: &configuration::Configuration, ingest_web_page_document_request: models::IngestWebPageDocumentRequest) -> Result<models::IngestDocumentResponse, Error<SemanticSearchWebpageIngestionError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_ingest_web_page_document_request = ingest_web_page_document_request;

    let uri_str = format!("{}/api/ingest/webpage", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_ingest_web_page_document_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::IngestDocumentResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::IngestDocumentResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SemanticSearchWebpageIngestionError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

